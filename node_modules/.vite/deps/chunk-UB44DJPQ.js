import {
  require_react_dom
} from "./chunk-KXTM2JPT.js";
import {
  require_prop_types,
  require_react_is
} from "./chunk-LRKUXM6X.js";
import {
  require_react
} from "./chunk-IGOAJGOA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@braintree/sanitize-url/dist/index.js
var require_dist = __commonJS({
  "node_modules/@braintree/sanitize-url/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeUrl = void 0;
    var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    var urlSchemeRegex = /^([^:]+):/gm;
    var relativeFirstCharacters = [".", "/"];
    function isRelativeUrlWithoutProtocol(url) {
      return relativeFirstCharacters.indexOf(url[0]) > -1;
    }
    function decodeHtmlCharacters(str) {
      return str.replace(htmlEntitiesRegex, function(match, dec) {
        return String.fromCharCode(dec);
      });
    }
    function sanitizeUrl(url) {
      var sanitizedUrl = decodeHtmlCharacters(url || "").replace(ctrlCharactersRegex, "").trim();
      if (!sanitizedUrl) {
        return "about:blank";
      }
      if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
      }
      var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
      if (!urlSchemeParseResults) {
        return sanitizedUrl;
      }
      var urlScheme = urlSchemeParseResults[0];
      if (invalidProtocolRegex.test(urlScheme)) {
        return "about:blank";
      }
      return sanitizedUrl;
    }
    exports.sanitizeUrl = sanitizeUrl;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $2 = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t2, e2, n3) {
        var r3 = String(t2);
        return !r3 || r3.length >= e2 ? t2 : "" + Array(e2 + 1 - r3.length).join(n3) + t2;
      }, g2 = { s: m2, z: function(t2) {
        var e2 = -t2.utcOffset(), n3 = Math.abs(e2), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e2 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
      }, m: function t2(e2, n3) {
        if (e2.date() < n3.date())
          return -t2(n3, e2);
        var r3 = 12 * (n3.year() - e2.year()) + (n3.month() - e2.month()), i3 = e2.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e2.clone().add(r3 + (s3 ? -1 : 1), f2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, v2 = "en", D2 = {};
      D2[v2] = M2;
      var p2 = function(t2) {
        return t2 instanceof _2;
      }, S2 = function t2(e2, n3, r3) {
        var i3;
        if (!e2)
          return v2;
        if ("string" == typeof e2) {
          var s3 = e2.toLowerCase();
          D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
          var u3 = e2.split("-");
          if (!i3 && u3.length > 1)
            return t2(u3[0]);
        } else {
          var a3 = e2.name;
          D2[a3] = e2, i3 = a3;
        }
        return !r3 && i3 && (v2 = i3), i3 || !r3 && v2;
      }, w2 = function(t2, e2) {
        if (p2(t2))
          return t2.clone();
        var n3 = "object" == typeof e2 ? e2 : {};
        return n3.date = t2, n3.args = arguments, new _2(n3);
      }, O2 = g2;
      O2.l = S2, O2.i = p2, O2.w = function(t2, e2) {
        return w2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _2 = function() {
        function M3(t2) {
          this.$L = S2(t2.locale, null, true), this.parse(t2);
        }
        var m3 = M3.prototype;
        return m3.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n3 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (O2.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r3 = e2.match(l2);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m3.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m3.$utils = function() {
          return O2;
        }, m3.isValid = function() {
          return !(this.$d.toString() === $2);
        }, m3.isSame = function(t2, e2) {
          var n3 = w2(t2);
          return this.startOf(e2) <= n3 && n3 <= this.endOf(e2);
        }, m3.isAfter = function(t2, e2) {
          return w2(t2) < this.startOf(e2);
        }, m3.isBefore = function(t2, e2) {
          return this.endOf(e2) < w2(t2);
        }, m3.$g = function(t2, e2, n3) {
          return O2.u(t2) ? this[e2] : this.set(n3, t2);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t2, e2) {
          var n3 = this, r3 = !!O2.u(e2) || e2, h3 = O2.p(t2), $3 = function(t3, e3) {
            var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e3, t3) : new Date(n3.$y, e3, t3), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, l3 = function(t3, e3) {
            return O2.w(n3.toDate()[t3].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n3);
          }, y3 = this.$W, M4 = this.$M, m4 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
          switch (h3) {
            case c2:
              return r3 ? $3(1, 0) : $3(31, 11);
            case f2:
              return r3 ? $3(1, M4) : $3(0, M4 + 1);
            case o2:
              var v3 = this.$locale().weekStart || 0, D3 = (y3 < v3 ? y3 + 7 : y3) - v3;
              return $3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
            case a2:
            case d2:
              return l3(g3 + "Hours", 0);
            case u2:
              return l3(g3 + "Minutes", 1);
            case s2:
              return l3(g3 + "Seconds", 2);
            case i2:
              return l3(g3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m3.$set = function(t2, e2) {
          var n3, o3 = O2.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $3 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], l3 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
          if (o3 === f2 || o3 === c2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[$3](l3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            $3 && this.$d[$3](l3);
          return this.init(), this;
        }, m3.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m3.get = function(t2) {
          return this[O2.p(t2)]();
        }, m3.add = function(r3, h3) {
          var d3, $3 = this;
          r3 = Number(r3);
          var l3 = O2.p(h3), y3 = function(t2) {
            var e2 = w2($3);
            return O2.w(e2.date(e2.date() + Math.round(t2 * r3)), $3);
          };
          if (l3 === f2)
            return this.set(f2, this.$M + r3);
          if (l3 === c2)
            return this.set(c2, this.$y + r3);
          if (l3 === a2)
            return y3(1);
          if (l3 === o2)
            return y3(7);
          var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n2, d3[i2] = t, d3)[l3] || 1, m4 = this.$d.getTime() + r3 * M4;
          return O2.w(m4, this);
        }, m3.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m3.format = function(t2) {
          var e2 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || $2;
          var r3 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t3, n4, i4, s4) {
            return t3 && (t3[n4] || t3(e2, r3)) || i4[n4].slice(0, s4);
          }, c3 = function(t3) {
            return O2.s(s3 % 12 || 12, t3, "0");
          }, d3 = n3.meridiem || function(t3, e3, n4) {
            var r4 = t3 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          }, l3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i3 };
          return r3.replace(y2, function(t3, e3) {
            return e3 || l3[t3] || i3.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d3, $3) {
          var l3, y3 = O2.p(d3), M4 = w2(r3), m4 = (M4.utcOffset() - this.utcOffset()) * e, g3 = this - M4, v3 = O2.m(this, M4);
          return v3 = (l3 = {}, l3[c2] = v3 / 12, l3[f2] = v3, l3[h2] = v3 / 3, l3[o2] = (g3 - m4) / 6048e5, l3[a2] = (g3 - m4) / 864e5, l3[u2] = g3 / n2, l3[s2] = g3 / e, l3[i2] = g3 / t, l3)[y3] || g3, $3 ? v3 : O2.a(v3);
        }, m3.daysInMonth = function() {
          return this.endOf(f2).$D;
        }, m3.$locale = function() {
          return D2[this.$L];
        }, m3.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n3 = this.clone(), r3 = S2(t2, e2, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return O2.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), T2 = _2.prototype;
      return w2.prototype = T2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t2) {
        T2[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w2.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _2, w2), t2.$i = true), w2;
      }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t2) {
        return w2(1e3 * t2);
      }, w2.en = D2[v2], w2.Ls = D2, w2.p = {}, w2;
    });
  }
});

// node_modules/linkifyjs/lib/linkify/utils/class.js
var require_class = __commonJS({
  "node_modules/linkifyjs/lib/linkify/utils/class.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.inherits = inherits;
    function inherits(parent, child) {
      var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var extended = Object.create(parent.prototype);
      for (var p2 in props) {
        extended[p2] = props[p2];
      }
      extended.constructor = child;
      child.prototype = extended;
      return child;
    }
  }
});

// node_modules/linkifyjs/lib/linkify/utils/options.js
var require_options = __commonJS({
  "node_modules/linkifyjs/lib/linkify/utils/options.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var defaults = {
      defaultProtocol: "http",
      events: null,
      format: noop2,
      formatHref: noop2,
      nl2br: false,
      tagName: "a",
      target: typeToTarget,
      validate: true,
      ignoreTags: [],
      attributes: null,
      className: "linkified"
    };
    exports.defaults = defaults;
    exports.Options = Options;
    exports.contains = contains;
    function Options(opts) {
      opts = opts || {};
      this.defaultProtocol = opts.hasOwnProperty("defaultProtocol") ? opts.defaultProtocol : defaults.defaultProtocol;
      this.events = opts.hasOwnProperty("events") ? opts.events : defaults.events;
      this.format = opts.hasOwnProperty("format") ? opts.format : defaults.format;
      this.formatHref = opts.hasOwnProperty("formatHref") ? opts.formatHref : defaults.formatHref;
      this.nl2br = opts.hasOwnProperty("nl2br") ? opts.nl2br : defaults.nl2br;
      this.tagName = opts.hasOwnProperty("tagName") ? opts.tagName : defaults.tagName;
      this.target = opts.hasOwnProperty("target") ? opts.target : defaults.target;
      this.validate = opts.hasOwnProperty("validate") ? opts.validate : defaults.validate;
      this.ignoreTags = [];
      this.attributes = opts.attributes || opts.linkAttributes || defaults.attributes;
      this.className = opts.hasOwnProperty("className") ? opts.className : opts.linkClass || defaults.className;
      var ignoredTags = opts.hasOwnProperty("ignoreTags") ? opts.ignoreTags : defaults.ignoreTags;
      for (var i2 = 0; i2 < ignoredTags.length; i2++) {
        this.ignoreTags.push(ignoredTags[i2].toUpperCase());
      }
    }
    Options.prototype = {
      resolve: function resolve(token) {
        var href = token.toHref(this.defaultProtocol);
        return {
          formatted: this.get("format", token.toString(), token),
          formattedHref: this.get("formatHref", href, token),
          tagName: this.get("tagName", href, token),
          className: this.get("className", href, token),
          target: this.get("target", href, token),
          events: this.getObject("events", href, token),
          attributes: this.getObject("attributes", href, token)
        };
      },
      check: function check(token) {
        return this.get("validate", token.toString(), token);
      },
      get: function get(key, operator, token) {
        var optionValue = void 0, option = this[key];
        if (!option) {
          return option;
        }
        switch (typeof option === "undefined" ? "undefined" : _typeof(option)) {
          case "function":
            return option(operator, token.type);
          case "object":
            optionValue = option.hasOwnProperty(token.type) ? option[token.type] : defaults[key];
            return typeof optionValue === "function" ? optionValue(operator, token.type) : optionValue;
        }
        return option;
      },
      getObject: function getObject(key, operator, token) {
        var option = this[key];
        return typeof option === "function" ? option(operator, token.type) : option;
      }
    };
    function contains(arr, value) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2] === value) {
          return true;
        }
      }
      return false;
    }
    function noop2(val) {
      return val;
    }
    function typeToTarget(href, type) {
      return type === "url" ? "_blank" : null;
    }
  }
});

// node_modules/linkifyjs/lib/linkify/core/state.js
var require_state = __commonJS({
  "node_modules/linkifyjs/lib/linkify/core/state.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.stateify = exports.TokenState = exports.CharacterState = void 0;
    var _class = require_class();
    function createStateClass() {
      return function(tClass) {
        this.j = [];
        this.T = tClass || null;
      };
    }
    var BaseState = createStateClass();
    BaseState.prototype = {
      defaultTransition: false,
      on: function on2(symbol, state) {
        if (symbol instanceof Array) {
          for (var i2 = 0; i2 < symbol.length; i2++) {
            this.j.push([symbol[i2], state]);
          }
          return this;
        }
        this.j.push([symbol, state]);
        return this;
      },
      next: function next(item) {
        for (var i2 = 0; i2 < this.j.length; i2++) {
          var jump = this.j[i2];
          var symbol = jump[0];
          var state = jump[1];
          if (this.test(item, symbol)) {
            return state;
          }
        }
        return this.defaultTransition;
      },
      accepts: function accepts() {
        return !!this.T;
      },
      test: function test(item, symbol) {
        return item === symbol;
      },
      emit: function emit() {
        return this.T;
      }
    };
    var CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {
      test: function test(character, charOrRegExp) {
        return character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);
      }
    });
    var TokenState = (0, _class.inherits)(BaseState, createStateClass(), {
      jump: function jump(token) {
        var tClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var state = this.next(new token(""));
        if (state === this.defaultTransition) {
          state = new this.constructor(tClass);
          this.on(token, state);
        } else if (tClass) {
          state.T = tClass;
        }
        return state;
      },
      test: function test(token, tokenClass) {
        return token instanceof tokenClass;
      }
    });
    function stateify(str, start, endToken, defaultToken) {
      var i2 = 0, len = str.length, state = start, newStates = [], nextState = void 0;
      while (i2 < len && (nextState = state.next(str[i2]))) {
        state = nextState;
        i2++;
      }
      if (i2 >= len) {
        return [];
      }
      while (i2 < len - 1) {
        nextState = new CharacterState(defaultToken);
        newStates.push(nextState);
        state.on(str[i2], nextState);
        state = nextState;
        i2++;
      }
      nextState = new CharacterState(endToken);
      newStates.push(nextState);
      state.on(str[len - 1], nextState);
      return newStates;
    }
    exports.CharacterState = CharacterState;
    exports.TokenState = TokenState;
    exports.stateify = stateify;
  }
});

// node_modules/linkifyjs/lib/linkify/core/tokens/create-token-class.js
var require_create_token_class = __commonJS({
  "node_modules/linkifyjs/lib/linkify/core/tokens/create-token-class.js"(exports) {
    "use strict";
    exports.__esModule = true;
    function createTokenClass() {
      return function(value) {
        if (value) {
          this.v = value;
        }
      };
    }
    exports.createTokenClass = createTokenClass;
  }
});

// node_modules/linkifyjs/lib/linkify/core/tokens/text.js
var require_text = __commonJS({
  "node_modules/linkifyjs/lib/linkify/core/tokens/text.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.AMPERSAND = exports.CLOSEPAREN = exports.CLOSEANGLEBRACKET = exports.CLOSEBRACKET = exports.CLOSEBRACE = exports.OPENPAREN = exports.OPENANGLEBRACKET = exports.OPENBRACKET = exports.OPENBRACE = exports.WS = exports.TLD = exports.SYM = exports.UNDERSCORE = exports.SLASH = exports.MAILTO = exports.PROTOCOL = exports.QUERY = exports.POUND = exports.PLUS = exports.NUM = exports.NL = exports.LOCALHOST = exports.PUNCTUATION = exports.DOT = exports.COLON = exports.AT = exports.DOMAIN = exports.Base = void 0;
    var _createTokenClass = require_create_token_class();
    var _class = require_class();
    var TextToken = (0, _createTokenClass.createTokenClass)();
    TextToken.prototype = {
      toString: function toString() {
        return this.v + "";
      }
    };
    function inheritsToken(value) {
      var props = value ? { v: value } : {};
      return (0, _class.inherits)(TextToken, (0, _createTokenClass.createTokenClass)(), props);
    }
    var DOMAIN = inheritsToken();
    var AT = inheritsToken("@");
    var COLON = inheritsToken(":");
    var DOT = inheritsToken(".");
    var PUNCTUATION = inheritsToken();
    var LOCALHOST = inheritsToken();
    var NL = inheritsToken("\n");
    var NUM = inheritsToken();
    var PLUS = inheritsToken("+");
    var POUND = inheritsToken("#");
    var PROTOCOL = inheritsToken();
    var MAILTO = inheritsToken("mailto:");
    var QUERY = inheritsToken("?");
    var SLASH = inheritsToken("/");
    var UNDERSCORE = inheritsToken("_");
    var SYM = inheritsToken();
    var TLD = inheritsToken();
    var WS = inheritsToken();
    var OPENBRACE = inheritsToken("{");
    var OPENBRACKET = inheritsToken("[");
    var OPENANGLEBRACKET = inheritsToken("<");
    var OPENPAREN = inheritsToken("(");
    var CLOSEBRACE = inheritsToken("}");
    var CLOSEBRACKET = inheritsToken("]");
    var CLOSEANGLEBRACKET = inheritsToken(">");
    var CLOSEPAREN = inheritsToken(")");
    var AMPERSAND = inheritsToken("&");
    exports.Base = TextToken;
    exports.DOMAIN = DOMAIN;
    exports.AT = AT;
    exports.COLON = COLON;
    exports.DOT = DOT;
    exports.PUNCTUATION = PUNCTUATION;
    exports.LOCALHOST = LOCALHOST;
    exports.NL = NL;
    exports.NUM = NUM;
    exports.PLUS = PLUS;
    exports.POUND = POUND;
    exports.QUERY = QUERY;
    exports.PROTOCOL = PROTOCOL;
    exports.MAILTO = MAILTO;
    exports.SLASH = SLASH;
    exports.UNDERSCORE = UNDERSCORE;
    exports.SYM = SYM;
    exports.TLD = TLD;
    exports.WS = WS;
    exports.OPENBRACE = OPENBRACE;
    exports.OPENBRACKET = OPENBRACKET;
    exports.OPENANGLEBRACKET = OPENANGLEBRACKET;
    exports.OPENPAREN = OPENPAREN;
    exports.CLOSEBRACE = CLOSEBRACE;
    exports.CLOSEBRACKET = CLOSEBRACKET;
    exports.CLOSEANGLEBRACKET = CLOSEANGLEBRACKET;
    exports.CLOSEPAREN = CLOSEPAREN;
    exports.AMPERSAND = AMPERSAND;
  }
});

// node_modules/linkifyjs/lib/linkify/core/scanner.js
var require_scanner = __commonJS({
  "node_modules/linkifyjs/lib/linkify/core/scanner.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.start = exports.run = exports.TOKENS = exports.State = void 0;
    var _state = require_state();
    var _text = require_text();
    var TOKENS = _interopRequireWildcard(_text);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    var tlds = "aaa|aarp|abarth|abb|abbott|abbvie|abc|able|abogado|abudhabi|ac|academy|accenture|accountant|accountants|aco|active|actor|ad|adac|ads|adult|ae|aeg|aero|aetna|af|afamilycompany|afl|africa|ag|agakhan|agency|ai|aig|aigo|airbus|airforce|airtel|akdn|al|alfaromeo|alibaba|alipay|allfinanz|allstate|ally|alsace|alstom|am|americanexpress|americanfamily|amex|amfam|amica|amsterdam|analytics|android|anquan|anz|ao|aol|apartments|app|apple|aq|aquarelle|ar|arab|aramco|archi|army|arpa|art|arte|as|asda|asia|associates|at|athleta|attorney|au|auction|audi|audible|audio|auspost|author|auto|autos|avianca|aw|aws|ax|axa|az|azure|ba|baby|baidu|banamex|bananarepublic|band|bank|bar|barcelona|barclaycard|barclays|barefoot|bargains|baseball|basketball|bauhaus|bayern|bb|bbc|bbt|bbva|bcg|bcn|bd|be|beats|beauty|beer|bentley|berlin|best|bestbuy|bet|bf|bg|bh|bharti|bi|bible|bid|bike|bing|bingo|bio|biz|bj|black|blackfriday|blanco|blockbuster|blog|bloomberg|blue|bm|bms|bmw|bn|bnl|bnpparibas|bo|boats|boehringer|bofa|bom|bond|boo|book|booking|boots|bosch|bostik|boston|bot|boutique|box|br|bradesco|bridgestone|broadway|broker|brother|brussels|bs|bt|budapest|bugatti|build|builders|business|buy|buzz|bv|bw|by|bz|bzh|ca|cab|cafe|cal|call|calvinklein|cam|camera|camp|cancerresearch|canon|capetown|capital|capitalone|car|caravan|cards|care|career|careers|cars|cartier|casa|case|caseih|cash|casino|cat|catering|catholic|cba|cbn|cbre|cbs|cc|cd|ceb|center|ceo|cern|cf|cfa|cfd|cg|ch|chanel|channel|chase|chat|cheap|chintai|chloe|christmas|chrome|chrysler|church|ci|cipriani|circle|cisco|citadel|citi|citic|city|cityeats|ck|cl|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|cm|cn|co|coach|codes|coffee|college|cologne|com|comcast|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cookingchannel|cool|coop|corsica|country|coupon|coupons|courses|cr|credit|creditcard|creditunion|cricket|crown|crs|cruise|cruises|csc|cu|cuisinella|cv|cw|cx|cy|cymru|cyou|cz|dabur|dad|dance|data|date|dating|datsun|day|dclk|dds|de|deal|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|dhl|diamonds|diet|digital|direct|directory|discount|discover|dish|diy|dj|dk|dm|dnp|do|docs|doctor|dodge|dog|doha|domains|dot|download|drive|dtv|dubai|duck|dunlop|duns|dupont|durban|dvag|dvr|dz|earth|eat|ec|eco|edeka|edu|education|ee|eg|email|emerck|energy|engineer|engineering|enterprises|epost|epson|equipment|er|ericsson|erni|es|esq|estate|esurance|et|etisalat|eu|eurovision|eus|events|everbank|exchange|expert|exposed|express|extraspace|fage|fail|fairwinds|faith|family|fan|fans|farm|farmers|fashion|fast|fedex|feedback|ferrari|ferrero|fi|fiat|fidelity|fido|film|final|finance|financial|fire|firestone|firmdale|fish|fishing|fit|fitness|fj|fk|flickr|flights|flir|florist|flowers|fly|fm|fo|foo|food|foodnetwork|football|ford|forex|forsale|forum|foundation|fox|fr|free|fresenius|frl|frogans|frontdoor|frontier|ftr|fujitsu|fujixerox|fun|fund|furniture|futbol|fyi|ga|gal|gallery|gallo|gallup|game|games|gap|garden|gb|gbiz|gd|gdn|ge|gea|gent|genting|george|gf|gg|ggee|gh|gi|gift|gifts|gives|giving|gl|glade|glass|gle|global|globo|gm|gmail|gmbh|gmo|gmx|gn|godaddy|gold|goldpoint|golf|goo|goodhands|goodyear|goog|google|gop|got|gov|gp|gq|gr|grainger|graphics|gratis|green|gripe|grocery|group|gs|gt|gu|guardian|gucci|guge|guide|guitars|guru|gw|gy|hair|hamburg|hangout|haus|hbo|hdfc|hdfcbank|health|healthcare|help|helsinki|here|hermes|hgtv|hiphop|hisamitsu|hitachi|hiv|hk|hkt|hm|hn|hockey|holdings|holiday|homedepot|homegoods|homes|homesense|honda|honeywell|horse|hospital|host|hosting|hot|hoteles|hotels|hotmail|house|how|hr|hsbc|ht|htc|hu|hughes|hyatt|hyundai|ibm|icbc|ice|icu|id|ie|ieee|ifm|ikano|il|im|imamat|imdb|immo|immobilien|in|industries|infiniti|info|ing|ink|institute|insurance|insure|int|intel|international|intuit|investments|io|ipiranga|iq|ir|irish|is|iselect|ismaili|ist|istanbul|it|itau|itv|iveco|iwc|jaguar|java|jcb|jcp|je|jeep|jetzt|jewelry|jio|jlc|jll|jm|jmp|jnj|jo|jobs|joburg|jot|joy|jp|jpmorgan|jprs|juegos|juniper|kaufen|kddi|ke|kerryhotels|kerrylogistics|kerryproperties|kfh|kg|kh|ki|kia|kim|kinder|kindle|kitchen|kiwi|km|kn|koeln|komatsu|kosher|kp|kpmg|kpn|kr|krd|kred|kuokgroup|kw|ky|kyoto|kz|la|lacaixa|ladbrokes|lamborghini|lamer|lancaster|lancia|lancome|land|landrover|lanxess|lasalle|lat|latino|latrobe|law|lawyer|lb|lc|lds|lease|leclerc|lefrak|legal|lego|lexus|lgbt|li|liaison|lidl|life|lifeinsurance|lifestyle|lighting|like|lilly|limited|limo|lincoln|linde|link|lipsy|live|living|lixil|lk|loan|loans|locker|locus|loft|lol|london|lotte|lotto|love|lpl|lplfinancial|lr|ls|lt|ltd|ltda|lu|lundbeck|lupin|luxe|luxury|lv|ly|ma|macys|madrid|maif|maison|makeup|man|management|mango|map|market|marketing|markets|marriott|marshalls|maserati|mattel|mba|mc|mckinsey|md|me|med|media|meet|melbourne|meme|memorial|men|menu|meo|merckmsd|metlife|mg|mh|miami|microsoft|mil|mini|mint|mit|mitsubishi|mk|ml|mlb|mls|mm|mma|mn|mo|mobi|mobile|mobily|moda|moe|moi|mom|monash|money|monster|mopar|mormon|mortgage|moscow|moto|motorcycles|mov|movie|movistar|mp|mq|mr|ms|msd|mt|mtn|mtr|mu|museum|mutual|mv|mw|mx|my|mz|na|nab|nadex|nagoya|name|nationwide|natura|navy|nba|nc|ne|nec|net|netbank|netflix|network|neustar|new|newholland|news|next|nextdirect|nexus|nf|nfl|ng|ngo|nhk|ni|nico|nike|nikon|ninja|nissan|nissay|nl|no|nokia|northwesternmutual|norton|now|nowruz|nowtv|np|nr|nra|nrw|ntt|nu|nyc|nz|obi|observer|off|office|okinawa|olayan|olayangroup|oldnavy|ollo|om|omega|one|ong|onl|online|onyourside|ooo|open|oracle|orange|org|organic|origins|osaka|otsuka|ott|ovh|pa|page|panasonic|panerai|paris|pars|partners|parts|party|passagens|pay|pccw|pe|pet|pf|pfizer|pg|ph|pharmacy|phd|philips|phone|photo|photography|photos|physio|piaget|pics|pictet|pictures|pid|pin|ping|pink|pioneer|pizza|pk|pl|place|play|playstation|plumbing|plus|pm|pn|pnc|pohl|poker|politie|porn|post|pr|pramerica|praxi|press|prime|pro|prod|productions|prof|progressive|promo|properties|property|protection|pru|prudential|ps|pt|pub|pw|pwc|py|qa|qpon|quebec|quest|qvc|racing|radio|raid|re|read|realestate|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|reliance|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|richardli|ricoh|rightathome|ril|rio|rip|rmit|ro|rocher|rocks|rodeo|rogers|room|rs|rsvp|ru|rugby|ruhr|run|rw|rwe|ryukyu|sa|saarland|safe|safety|sakura|sale|salon|samsclub|samsung|sandvik|sandvikcoromant|sanofi|sap|sapo|sarl|sas|save|saxo|sb|sbi|sbs|sc|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scjohnson|scor|scot|sd|se|search|seat|secure|security|seek|select|sener|services|ses|seven|sew|sex|sexy|sfr|sg|sh|shangrila|sharp|shaw|shell|shia|shiksha|shoes|shop|shopping|shouji|show|showtime|shriram|si|silk|sina|singles|site|sj|sk|ski|skin|sky|skype|sl|sling|sm|smart|smile|sn|sncf|so|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|space|spiegel|spot|spreadbetting|sr|srl|srt|st|stada|staples|star|starhub|statebank|statefarm|statoil|stc|stcgroup|stockholm|storage|store|stream|studio|study|style|su|sucks|supplies|supply|support|surf|surgery|suzuki|sv|swatch|swiftcover|swiss|sx|sy|sydney|symantec|systems|sz|tab|taipei|talk|taobao|target|tatamotors|tatar|tattoo|tax|taxi|tc|tci|td|tdk|team|tech|technology|tel|telecity|telefonica|temasek|tennis|teva|tf|tg|th|thd|theater|theatre|tiaa|tickets|tienda|tiffany|tips|tires|tirol|tj|tjmaxx|tjx|tk|tkmaxx|tl|tm|tmall|tn|to|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|tr|trade|trading|training|travel|travelchannel|travelers|travelersinsurance|trust|trv|tt|tube|tui|tunes|tushu|tv|tvs|tw|tz|ua|ubank|ubs|uconnect|ug|uk|unicom|university|uno|uol|ups|us|uy|uz|va|vacations|vana|vanguard|vc|ve|vegas|ventures|verisign|versicherung|vet|vg|vi|viajes|video|vig|viking|villas|vin|vip|virgin|visa|vision|vista|vistaprint|viva|vivo|vlaanderen|vn|vodka|volkswagen|volvo|vote|voting|voto|voyage|vu|vuelos|wales|walmart|walter|wang|wanggou|warman|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weibo|weir|wf|whoswho|wien|wiki|williamhill|win|windows|wine|winners|wme|wolterskluwer|woodside|work|works|world|wow|ws|wtc|wtf|xbox|xerox|xfinity|xihuan|xin|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--30rr7y|xn--3bst00m|xn--3ds443g|xn--3e0b707e|xn--3hcrj9c|xn--3oq18vl8pn36a|xn--3pxu8k|xn--42c2d9a|xn--45br5cyl|xn--45brj9c|xn--45q11c|xn--4gbrim|xn--54b7fta0cc|xn--55qw42g|xn--55qx5d|xn--5su34j936bgsg|xn--5tzm5g|xn--6frz82g|xn--6qq986b3xl|xn--80adxhks|xn--80ao21a|xn--80aqecdr1a|xn--80asehdb|xn--80aswg|xn--8y0a063a|xn--90a3ac|xn--90ae|xn--90ais|xn--9dbq2a|xn--9et52u|xn--9krt00a|xn--b4w605ferd|xn--bck1b9a5dre4c|xn--c1avg|xn--c2br7g|xn--cck2b3b|xn--cg4bki|xn--clchc0ea0b2g2a9gcd|xn--czr694b|xn--czrs0t|xn--czru2d|xn--d1acj3b|xn--d1alf|xn--e1a4c|xn--eckvdtc9d|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fhbei|xn--fiq228c5hs|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--fjq720a|xn--flw351e|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--fzys8d69uvgm|xn--g2xx48c|xn--gckr3f0f|xn--gecrj9c|xn--gk3at1e|xn--h2breg3eve|xn--h2brj9c|xn--h2brj9c8c|xn--hxt814e|xn--i1b6b1a6a2e|xn--imr513n|xn--io0a7i|xn--j1aef|xn--j1amh|xn--j6w193g|xn--jlq61u9w7b|xn--jvr189m|xn--kcrx77d1x4a|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--kput3i|xn--l1acc|xn--lgbbat1ad8j|xn--mgb9awbf|xn--mgba3a3ejt|xn--mgba3a4f16a|xn--mgba7c0bbn0a|xn--mgbaakc7dvf|xn--mgbaam7a8h|xn--mgbab2bd|xn--mgbai9azgqp6j|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a|xn--mgbbh1a71e|xn--mgbc0a9azcg|xn--mgbca7dzdo|xn--mgberp4a5d4ar|xn--mgbgu82a|xn--mgbi4ecexp|xn--mgbpl2fh|xn--mgbt3dhd|xn--mgbtx2b|xn--mgbx4cd0ab|xn--mix891f|xn--mk1bu44c|xn--mxtq1m|xn--ngbc5azd|xn--ngbe9e0a|xn--ngbrx|xn--node|xn--nqv7f|xn--nqv7fs00ema|xn--nyqy26a|xn--o3cw4h|xn--ogbpf8fl|xn--p1acf|xn--p1ai|xn--pbt977c|xn--pgbs0dh|xn--pssy2u|xn--q9jyb4c|xn--qcka1pmc|xn--qxam|xn--rhqv96g|xn--rovu88b|xn--rvc1e0am3e|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--tckwe|xn--tiq49xqyj|xn--unup4y|xn--vermgensberater-ctb|xn--vermgensberatung-pwb|xn--vhquv|xn--vuq861b|xn--w4r85el8fhu5dnra|xn--w4rs40l|xn--wgbh1c|xn--wgbl6a|xn--xhq521b|xn--xkc2al3hye2a|xn--xkc2dl3a5ee0h|xn--y9a3aq|xn--yfro4i67o|xn--ygbi2ammx|xn--zfr164b|xperia|xxx|xyz|yachts|yahoo|yamaxun|yandex|ye|yodobashi|yoga|yokohama|you|youtube|yt|yun|za|zappos|zara|zero|zip|zippo|zm|zone|zuerich|zw".split("|");
    var NUMBERS = "0123456789".split("");
    var ALPHANUM = "0123456789abcdefghijklmnopqrstuvwxyz".split("");
    var WHITESPACE = [" ", "\f", "\r", "	", "\v", "\xA0", "\u1680", "\u180E"];
    var domainStates = [];
    var makeState = function makeState2(tokenClass) {
      return new _state.CharacterState(tokenClass);
    };
    var S_START = makeState();
    var S_NUM = makeState(_text.NUM);
    var S_DOMAIN = makeState(_text.DOMAIN);
    var S_DOMAIN_HYPHEN = makeState();
    var S_WS = makeState(_text.WS);
    S_START.on("@", makeState(_text.AT)).on(".", makeState(_text.DOT)).on("+", makeState(_text.PLUS)).on("#", makeState(_text.POUND)).on("?", makeState(_text.QUERY)).on("/", makeState(_text.SLASH)).on("_", makeState(_text.UNDERSCORE)).on(":", makeState(_text.COLON)).on("{", makeState(_text.OPENBRACE)).on("[", makeState(_text.OPENBRACKET)).on("<", makeState(_text.OPENANGLEBRACKET)).on("(", makeState(_text.OPENPAREN)).on("}", makeState(_text.CLOSEBRACE)).on("]", makeState(_text.CLOSEBRACKET)).on(">", makeState(_text.CLOSEANGLEBRACKET)).on(")", makeState(_text.CLOSEPAREN)).on("&", makeState(_text.AMPERSAND)).on([",", ";", "!", '"', "'"], makeState(_text.PUNCTUATION));
    S_START.on("\n", makeState(_text.NL)).on(WHITESPACE, S_WS);
    S_WS.on(WHITESPACE, S_WS);
    for (i2 = 0; i2 < tlds.length; i2++) {
      newStates = (0, _state.stateify)(tlds[i2], S_START, _text.TLD, _text.DOMAIN);
      domainStates.push.apply(domainStates, newStates);
    }
    var newStates;
    var i2;
    var partialProtocolFileStates = (0, _state.stateify)("file", S_START, _text.DOMAIN, _text.DOMAIN);
    var partialProtocolFtpStates = (0, _state.stateify)("ftp", S_START, _text.DOMAIN, _text.DOMAIN);
    var partialProtocolHttpStates = (0, _state.stateify)("http", S_START, _text.DOMAIN, _text.DOMAIN);
    var partialProtocolMailtoStates = (0, _state.stateify)("mailto", S_START, _text.DOMAIN, _text.DOMAIN);
    domainStates.push.apply(domainStates, partialProtocolFileStates);
    domainStates.push.apply(domainStates, partialProtocolFtpStates);
    domainStates.push.apply(domainStates, partialProtocolHttpStates);
    domainStates.push.apply(domainStates, partialProtocolMailtoStates);
    var S_PROTOCOL_FILE = partialProtocolFileStates.pop();
    var S_PROTOCOL_FTP = partialProtocolFtpStates.pop();
    var S_PROTOCOL_HTTP = partialProtocolHttpStates.pop();
    var S_MAILTO = partialProtocolMailtoStates.pop();
    var S_PROTOCOL_SECURE = makeState(_text.DOMAIN);
    var S_FULL_PROTOCOL = makeState(_text.PROTOCOL);
    var S_FULL_MAILTO = makeState(_text.MAILTO);
    S_PROTOCOL_FTP.on("s", S_PROTOCOL_SECURE).on(":", S_FULL_PROTOCOL);
    S_PROTOCOL_HTTP.on("s", S_PROTOCOL_SECURE).on(":", S_FULL_PROTOCOL);
    domainStates.push(S_PROTOCOL_SECURE);
    S_PROTOCOL_FILE.on(":", S_FULL_PROTOCOL);
    S_PROTOCOL_SECURE.on(":", S_FULL_PROTOCOL);
    S_MAILTO.on(":", S_FULL_MAILTO);
    var partialLocalhostStates = (0, _state.stateify)("localhost", S_START, _text.LOCALHOST, _text.DOMAIN);
    domainStates.push.apply(domainStates, partialLocalhostStates);
    S_START.on(NUMBERS, S_NUM);
    S_NUM.on("-", S_DOMAIN_HYPHEN).on(NUMBERS, S_NUM).on(ALPHANUM, S_DOMAIN);
    S_DOMAIN.on("-", S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);
    for (_i = 0; _i < domainStates.length; _i++) {
      domainStates[_i].on("-", S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);
    }
    var _i;
    S_DOMAIN_HYPHEN.on("-", S_DOMAIN_HYPHEN).on(NUMBERS, S_DOMAIN).on(ALPHANUM, S_DOMAIN);
    S_START.defaultTransition = makeState(_text.SYM);
    var run = function run2(str) {
      var lowerStr = str.replace(/[A-Z]/g, function(c2) {
        return c2.toLowerCase();
      });
      var len = str.length;
      var tokens = [];
      var cursor = 0;
      while (cursor < len) {
        var state = S_START;
        var nextState = null;
        var tokenLength = 0;
        var latestAccepting = null;
        var sinceAccepts = -1;
        while (cursor < len && (nextState = state.next(lowerStr[cursor]))) {
          state = nextState;
          if (state.accepts()) {
            sinceAccepts = 0;
            latestAccepting = state;
          } else if (sinceAccepts >= 0) {
            sinceAccepts++;
          }
          tokenLength++;
          cursor++;
        }
        if (sinceAccepts < 0) {
          continue;
        }
        cursor -= sinceAccepts;
        tokenLength -= sinceAccepts;
        var TOKEN = latestAccepting.emit();
        tokens.push(new TOKEN(str.substr(cursor - tokenLength, tokenLength)));
      }
      return tokens;
    };
    var start = S_START;
    exports.State = _state.CharacterState;
    exports.TOKENS = TOKENS;
    exports.run = run;
    exports.start = start;
  }
});

// node_modules/linkifyjs/lib/linkify/core/tokens/multi.js
var require_multi = __commonJS({
  "node_modules/linkifyjs/lib/linkify/core/tokens/multi.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.URL = exports.TEXT = exports.NL = exports.EMAIL = exports.MAILTOEMAIL = exports.Base = void 0;
    var _createTokenClass = require_create_token_class();
    var _class = require_class();
    var _text = require_text();
    function isDomainToken(token) {
      return token instanceof _text.DOMAIN || token instanceof _text.TLD;
    }
    var MultiToken = (0, _createTokenClass.createTokenClass)();
    MultiToken.prototype = {
      type: "token",
      isLink: false,
      toString: function toString() {
        var result = [];
        for (var i2 = 0; i2 < this.v.length; i2++) {
          result.push(this.v[i2].toString());
        }
        return result.join("");
      },
      toHref: function toHref() {
        return this.toString();
      },
      toObject: function toObject() {
        var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "http";
        return {
          type: this.type,
          value: this.toString(),
          href: this.toHref(protocol)
        };
      }
    };
    var MAILTOEMAIL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
      type: "email",
      isLink: true
    });
    var EMAIL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
      type: "email",
      isLink: true,
      toHref: function toHref() {
        return "mailto:" + this.toString();
      }
    });
    var TEXT = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), { type: "text" });
    var NL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), { type: "nl" });
    var URL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
      type: "url",
      isLink: true,
      toHref: function toHref() {
        var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "http";
        var hasProtocol = false;
        var hasSlashSlash = false;
        var tokens = this.v;
        var result = [];
        var i2 = 0;
        while (tokens[i2] instanceof _text.PROTOCOL) {
          hasProtocol = true;
          result.push(tokens[i2].toString().toLowerCase());
          i2++;
        }
        while (tokens[i2] instanceof _text.SLASH) {
          hasSlashSlash = true;
          result.push(tokens[i2].toString());
          i2++;
        }
        while (isDomainToken(tokens[i2])) {
          result.push(tokens[i2].toString().toLowerCase());
          i2++;
        }
        for (; i2 < tokens.length; i2++) {
          result.push(tokens[i2].toString());
        }
        result = result.join("");
        if (!(hasProtocol || hasSlashSlash)) {
          result = protocol + "://" + result;
        }
        return result;
      },
      hasProtocol: function hasProtocol() {
        return this.v[0] instanceof _text.PROTOCOL;
      }
    });
    exports.Base = MultiToken;
    exports.MAILTOEMAIL = MAILTOEMAIL;
    exports.EMAIL = EMAIL;
    exports.NL = NL;
    exports.TEXT = TEXT;
    exports.URL = URL;
  }
});

// node_modules/linkifyjs/lib/linkify/core/parser.js
var require_parser = __commonJS({
  "node_modules/linkifyjs/lib/linkify/core/parser.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.start = exports.run = exports.TOKENS = exports.State = void 0;
    var _state = require_state();
    var _multi = require_multi();
    var MULTI_TOKENS = _interopRequireWildcard(_multi);
    var _text = require_text();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    var makeState = function makeState2(tokenClass) {
      return new _state.TokenState(tokenClass);
    };
    var S_START = makeState();
    var S_PROTOCOL = makeState();
    var S_MAILTO = makeState();
    var S_PROTOCOL_SLASH = makeState();
    var S_PROTOCOL_SLASH_SLASH = makeState();
    var S_DOMAIN = makeState();
    var S_DOMAIN_DOT = makeState();
    var S_TLD = makeState(_multi.URL);
    var S_TLD_COLON = makeState();
    var S_TLD_PORT = makeState(_multi.URL);
    var S_URL = makeState(_multi.URL);
    var S_URL_NON_ACCEPTING = makeState();
    var S_URL_OPENBRACE = makeState();
    var S_URL_OPENBRACKET = makeState();
    var S_URL_OPENANGLEBRACKET = makeState();
    var S_URL_OPENPAREN = makeState();
    var S_URL_OPENBRACE_Q = makeState(_multi.URL);
    var S_URL_OPENBRACKET_Q = makeState(_multi.URL);
    var S_URL_OPENANGLEBRACKET_Q = makeState(_multi.URL);
    var S_URL_OPENPAREN_Q = makeState(_multi.URL);
    var S_URL_OPENBRACE_SYMS = makeState();
    var S_URL_OPENBRACKET_SYMS = makeState();
    var S_URL_OPENANGLEBRACKET_SYMS = makeState();
    var S_URL_OPENPAREN_SYMS = makeState();
    var S_EMAIL_DOMAIN = makeState();
    var S_EMAIL_DOMAIN_DOT = makeState();
    var S_EMAIL = makeState(_multi.EMAIL);
    var S_EMAIL_COLON = makeState();
    var S_EMAIL_PORT = makeState(_multi.EMAIL);
    var S_MAILTO_EMAIL = makeState(_multi.MAILTOEMAIL);
    var S_MAILTO_EMAIL_NON_ACCEPTING = makeState();
    var S_LOCALPART = makeState();
    var S_LOCALPART_AT = makeState();
    var S_LOCALPART_DOT = makeState();
    var S_NL = makeState(_multi.NL);
    S_START.on(_text.NL, S_NL).on(_text.PROTOCOL, S_PROTOCOL).on(_text.MAILTO, S_MAILTO).on(_text.SLASH, S_PROTOCOL_SLASH);
    S_PROTOCOL.on(_text.SLASH, S_PROTOCOL_SLASH);
    S_PROTOCOL_SLASH.on(_text.SLASH, S_PROTOCOL_SLASH_SLASH);
    S_START.on(_text.TLD, S_DOMAIN).on(_text.DOMAIN, S_DOMAIN).on(_text.LOCALHOST, S_TLD).on(_text.NUM, S_DOMAIN);
    S_PROTOCOL_SLASH_SLASH.on(_text.TLD, S_URL).on(_text.DOMAIN, S_URL).on(_text.NUM, S_URL).on(_text.LOCALHOST, S_URL);
    S_DOMAIN.on(_text.DOT, S_DOMAIN_DOT);
    S_EMAIL_DOMAIN.on(_text.DOT, S_EMAIL_DOMAIN_DOT);
    S_DOMAIN_DOT.on(_text.TLD, S_TLD).on(_text.DOMAIN, S_DOMAIN).on(_text.NUM, S_DOMAIN).on(_text.LOCALHOST, S_DOMAIN);
    S_EMAIL_DOMAIN_DOT.on(_text.TLD, S_EMAIL).on(_text.DOMAIN, S_EMAIL_DOMAIN).on(_text.NUM, S_EMAIL_DOMAIN).on(_text.LOCALHOST, S_EMAIL_DOMAIN);
    S_TLD.on(_text.DOT, S_DOMAIN_DOT);
    S_EMAIL.on(_text.DOT, S_EMAIL_DOMAIN_DOT);
    S_TLD.on(_text.COLON, S_TLD_COLON).on(_text.SLASH, S_URL);
    S_TLD_COLON.on(_text.NUM, S_TLD_PORT);
    S_TLD_PORT.on(_text.SLASH, S_URL);
    S_EMAIL.on(_text.COLON, S_EMAIL_COLON);
    S_EMAIL_COLON.on(_text.NUM, S_EMAIL_PORT);
    var qsAccepting = [_text.DOMAIN, _text.AT, _text.LOCALHOST, _text.NUM, _text.PLUS, _text.POUND, _text.PROTOCOL, _text.SLASH, _text.TLD, _text.UNDERSCORE, _text.SYM, _text.AMPERSAND];
    var qsNonAccepting = [_text.COLON, _text.DOT, _text.QUERY, _text.PUNCTUATION, _text.CLOSEBRACE, _text.CLOSEBRACKET, _text.CLOSEANGLEBRACKET, _text.CLOSEPAREN, _text.OPENBRACE, _text.OPENBRACKET, _text.OPENANGLEBRACKET, _text.OPENPAREN];
    S_URL.on(_text.OPENBRACE, S_URL_OPENBRACE).on(_text.OPENBRACKET, S_URL_OPENBRACKET).on(_text.OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET).on(_text.OPENPAREN, S_URL_OPENPAREN);
    S_URL_NON_ACCEPTING.on(_text.OPENBRACE, S_URL_OPENBRACE).on(_text.OPENBRACKET, S_URL_OPENBRACKET).on(_text.OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET).on(_text.OPENPAREN, S_URL_OPENPAREN);
    S_URL_OPENBRACE.on(_text.CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET.on(_text.CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET.on(_text.CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN.on(_text.CLOSEPAREN, S_URL);
    S_URL_OPENBRACE_Q.on(_text.CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET_Q.on(_text.CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET_Q.on(_text.CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN_Q.on(_text.CLOSEPAREN, S_URL);
    S_URL_OPENBRACE_SYMS.on(_text.CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET_SYMS.on(_text.CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET_SYMS.on(_text.CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN_SYMS.on(_text.CLOSEPAREN, S_URL);
    S_URL_OPENBRACE.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
    S_URL_OPENBRACKET.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    S_URL_OPENANGLEBRACKET.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    S_URL_OPENPAREN.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);
    S_URL_OPENBRACE_Q.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_Q.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_Q.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_Q.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE_Q.on(qsNonAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_Q.on(qsNonAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_Q.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_Q.on(qsNonAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE_SYMS.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_SYMS.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_SYMS.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_SYMS.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE_SYMS.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
    S_URL_OPENBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    S_URL_OPENANGLEBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    S_URL_OPENPAREN_SYMS.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);
    S_URL.on(qsAccepting, S_URL);
    S_URL_NON_ACCEPTING.on(qsAccepting, S_URL);
    S_URL.on(qsNonAccepting, S_URL_NON_ACCEPTING);
    S_URL_NON_ACCEPTING.on(qsNonAccepting, S_URL_NON_ACCEPTING);
    S_MAILTO.on(_text.TLD, S_MAILTO_EMAIL).on(_text.DOMAIN, S_MAILTO_EMAIL).on(_text.NUM, S_MAILTO_EMAIL).on(_text.LOCALHOST, S_MAILTO_EMAIL);
    S_MAILTO_EMAIL.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
    S_MAILTO_EMAIL_NON_ACCEPTING.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
    var localpartAccepting = [_text.DOMAIN, _text.NUM, _text.PLUS, _text.POUND, _text.QUERY, _text.UNDERSCORE, _text.SYM, _text.AMPERSAND, _text.TLD];
    S_DOMAIN.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT);
    S_TLD.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT);
    S_DOMAIN_DOT.on(localpartAccepting, S_LOCALPART);
    S_LOCALPART.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT).on(_text.DOT, S_LOCALPART_DOT);
    S_LOCALPART_DOT.on(localpartAccepting, S_LOCALPART);
    S_LOCALPART_AT.on(_text.TLD, S_EMAIL_DOMAIN).on(_text.DOMAIN, S_EMAIL_DOMAIN).on(_text.LOCALHOST, S_EMAIL);
    var run = function run2(tokens) {
      var len = tokens.length;
      var cursor = 0;
      var multis = [];
      var textTokens = [];
      while (cursor < len) {
        var state = S_START;
        var secondState = null;
        var nextState = null;
        var multiLength = 0;
        var latestAccepting = null;
        var sinceAccepts = -1;
        while (cursor < len && !(secondState = state.next(tokens[cursor]))) {
          textTokens.push(tokens[cursor++]);
        }
        while (cursor < len && (nextState = secondState || state.next(tokens[cursor]))) {
          secondState = null;
          state = nextState;
          if (state.accepts()) {
            sinceAccepts = 0;
            latestAccepting = state;
          } else if (sinceAccepts >= 0) {
            sinceAccepts++;
          }
          cursor++;
          multiLength++;
        }
        if (sinceAccepts < 0) {
          for (var i2 = cursor - multiLength; i2 < cursor; i2++) {
            textTokens.push(tokens[i2]);
          }
        } else {
          if (textTokens.length > 0) {
            multis.push(new _multi.TEXT(textTokens));
            textTokens = [];
          }
          cursor -= sinceAccepts;
          multiLength -= sinceAccepts;
          var MULTI = latestAccepting.emit();
          multis.push(new MULTI(tokens.slice(cursor - multiLength, cursor)));
        }
      }
      if (textTokens.length > 0) {
        multis.push(new _multi.TEXT(textTokens));
      }
      return multis;
    };
    exports.State = _state.TokenState;
    exports.TOKENS = MULTI_TOKENS;
    exports.run = run;
    exports.start = S_START;
  }
});

// node_modules/linkifyjs/lib/linkify.js
var require_linkify = __commonJS({
  "node_modules/linkifyjs/lib/linkify.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.tokenize = exports.test = exports.scanner = exports.parser = exports.options = exports.inherits = exports.find = void 0;
    var _class = require_class();
    var _options = require_options();
    var options = _interopRequireWildcard(_options);
    var _scanner = require_scanner();
    var scanner = _interopRequireWildcard(_scanner);
    var _parser = require_parser();
    var parser = _interopRequireWildcard(_parser);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
    }
    var tokenize = function tokenize2(str) {
      return parser.run(scanner.run(str));
    };
    var find = function find2(str) {
      var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var tokens = tokenize(str);
      var filtered = [];
      for (var i2 = 0; i2 < tokens.length; i2++) {
        var token = tokens[i2];
        if (token.isLink && (!type || token.type === type)) {
          filtered.push(token.toObject());
        }
      }
      return filtered;
    };
    var test = function test2(str) {
      var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var tokens = tokenize(str);
      return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].type === type);
    };
    exports.find = find;
    exports.inherits = _class.inherits;
    exports.options = options;
    exports.parser = parser;
    exports.scanner = scanner;
    exports.test = test;
    exports.tokenize = tokenize;
  }
});

// node_modules/linkifyjs/index.js
var require_linkifyjs = __commonJS({
  "node_modules/linkifyjs/index.js"(exports, module) {
    module.exports = require_linkify();
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/bail/index.js
var require_bail = __commonJS({
  "node_modules/bail/index.js"(exports, module) {
    "use strict";
    module.exports = bail;
    function bail(err) {
      if (err) {
        throw err;
      }
    }
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function isBuffer(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i2 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports, module) {
    "use strict";
    module.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/trough/wrap.js
var require_wrap = __commonJS({
  "node_modules/trough/wrap.js"(exports, module) {
    "use strict";
    var slice = [].slice;
    module.exports = wrap;
    function wrap(fn, callback) {
      var invoked;
      return wrapped;
      function wrapped() {
        var params = slice.call(arguments, 0);
        var callback2 = fn.length > params.length;
        var result;
        if (callback2) {
          params.push(done);
        }
        try {
          result = fn.apply(null, params);
        } catch (error) {
          if (callback2 && invoked) {
            throw error;
          }
          return done(error);
        }
        if (!callback2) {
          if (result && typeof result.then === "function") {
            result.then(then, done);
          } else if (result instanceof Error) {
            done(result);
          } else {
            then(result);
          }
        }
      }
      function done() {
        if (!invoked) {
          invoked = true;
          callback.apply(null, arguments);
        }
      }
      function then(value) {
        done(null, value);
      }
    }
  }
});

// node_modules/trough/index.js
var require_trough = __commonJS({
  "node_modules/trough/index.js"(exports, module) {
    "use strict";
    var wrap = require_wrap();
    module.exports = trough;
    trough.wrap = wrap;
    var slice = [].slice;
    function trough() {
      var fns = [];
      var middleware = {};
      middleware.run = run;
      middleware.use = use;
      return middleware;
      function run() {
        var index = -1;
        var input = slice.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") {
          throw new Error("Expected function as last argument, not " + done);
        }
        next.apply(null, [null].concat(input));
        function next(err) {
          var fn = fns[++index];
          var params = slice.call(arguments, 0);
          var values = params.slice(1);
          var length = input.length;
          var pos = -1;
          if (err) {
            done(err);
            return;
          }
          while (++pos < length) {
            if (values[pos] === null || values[pos] === void 0) {
              values[pos] = input[pos];
            }
          }
          input = values;
          if (fn) {
            wrap(fn, next).apply(null, input);
          } else {
            done.apply(null, [null].concat(input));
          }
        }
      }
      function use(fn) {
        if (typeof fn !== "function") {
          throw new Error("Expected `fn` to be a function, not " + fn);
        }
        fns.push(fn);
        return middleware;
      }
    }
  }
});

// node_modules/unist-util-stringify-position/index.js
var require_unist_util_stringify_position = __commonJS({
  "node_modules/unist-util-stringify-position/index.js"(exports, module) {
    "use strict";
    var own = {}.hasOwnProperty;
    module.exports = stringify;
    function stringify(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own.call(value, "position") || own.call(value, "type")) {
        return position(value.position);
      }
      if (own.call(value, "start") || own.call(value, "end")) {
        return position(value);
      }
      if (own.call(value, "line") || own.call(value, "column")) {
        return point(value);
      }
      return "";
    }
    function point(point2) {
      if (!point2 || typeof point2 !== "object") {
        point2 = {};
      }
      return index(point2.line) + ":" + index(point2.column);
    }
    function position(pos) {
      if (!pos || typeof pos !== "object") {
        pos = {};
      }
      return point(pos.start) + "-" + point(pos.end);
    }
    function index(value) {
      return value && typeof value === "number" ? value : 1;
    }
  }
});

// node_modules/vfile-message/index.js
var require_vfile_message = __commonJS({
  "node_modules/vfile-message/index.js"(exports, module) {
    "use strict";
    var stringify = require_unist_util_stringify_position();
    module.exports = VMessage;
    function VMessagePrototype() {
    }
    VMessagePrototype.prototype = Error.prototype;
    VMessage.prototype = new VMessagePrototype();
    var proto = VMessage.prototype;
    proto.file = "";
    proto.name = "";
    proto.reason = "";
    proto.message = "";
    proto.stack = "";
    proto.fatal = null;
    proto.column = null;
    proto.line = null;
    function VMessage(reason, position, origin) {
      var parts;
      var range;
      var location;
      if (typeof position === "string") {
        origin = position;
        position = null;
      }
      parts = parseOrigin(origin);
      range = stringify(position) || "1:1";
      location = {
        start: { line: null, column: null },
        end: { line: null, column: null }
      };
      if (position && position.position) {
        position = position.position;
      }
      if (position) {
        if (position.start) {
          location = position;
          position = position.start;
        } else {
          location.start = position;
        }
      }
      if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
      }
      this.message = reason;
      this.name = range;
      this.reason = reason;
      this.line = position ? position.line : null;
      this.column = position ? position.column : null;
      this.location = location;
      this.source = parts[0];
      this.ruleId = parts[1];
    }
    function parseOrigin(origin) {
      var result = [null, null];
      var index;
      if (typeof origin === "string") {
        index = origin.indexOf(":");
        if (index === -1) {
          result[1] = origin;
        } else {
          result[0] = origin.slice(0, index);
          result[1] = origin.slice(index + 1);
        }
      }
      return result;
    }
  }
});

// node_modules/vfile/lib/minpath.browser.js
var require_minpath_browser = __commonJS({
  "node_modules/vfile/lib/minpath.browser.js"(exports) {
    "use strict";
    exports.basename = basename;
    exports.dirname = dirname;
    exports.extname = extname;
    exports.join = join;
    exports.sep = "/";
    function basename(path, ext) {
      var start = 0;
      var end = -1;
      var index;
      var firstNonSlashEnd;
      var seenNonSlash;
      var extIndex;
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath(path);
      index = path.length;
      if (ext === void 0 || !ext.length || ext.length > path.length) {
        while (index--) {
          if (path.charCodeAt(index) === 47) {
            if (seenNonSlash) {
              start = index + 1;
              break;
            }
          } else if (end < 0) {
            seenNonSlash = true;
            end = index + 1;
          }
        }
        return end < 0 ? "" : path.slice(start, end);
      }
      if (ext === path) {
        return "";
      }
      firstNonSlashEnd = -1;
      extIndex = ext.length - 1;
      while (index--) {
        if (path.charCodeAt(index) === 47) {
          if (seenNonSlash) {
            start = index + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd < 0) {
            seenNonSlash = true;
            firstNonSlashEnd = index + 1;
          }
          if (extIndex > -1) {
            if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {
              if (extIndex < 0) {
                end = index;
              }
            } else {
              extIndex = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end < 0) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    function dirname(path) {
      var end;
      var unmatchedSlash;
      var index;
      assertPath(path);
      if (!path.length) {
        return ".";
      }
      end = -1;
      index = path.length;
      while (--index) {
        if (path.charCodeAt(index) === 47) {
          if (unmatchedSlash) {
            end = index;
            break;
          }
        } else if (!unmatchedSlash) {
          unmatchedSlash = true;
        }
      }
      return end < 0 ? path.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path.charCodeAt(0) === 47 ? "//" : path.slice(0, end);
    }
    function extname(path) {
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var preDotState = 0;
      var unmatchedSlash;
      var code;
      var index;
      assertPath(path);
      index = path.length;
      while (index--) {
        code = path.charCodeAt(index);
        if (code === 47) {
          if (unmatchedSlash) {
            startPart = index + 1;
            break;
          }
          continue;
        }
        if (end < 0) {
          unmatchedSlash = true;
          end = index + 1;
        }
        if (code === 46) {
          if (startDot < 0) {
            startDot = index;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot > -1) {
          preDotState = -1;
        }
      }
      if (startDot < 0 || end < 0 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    }
    function join() {
      var index = -1;
      var joined;
      while (++index < arguments.length) {
        assertPath(arguments[index]);
        if (arguments[index]) {
          joined = joined === void 0 ? arguments[index] : joined + "/" + arguments[index];
        }
      }
      return joined === void 0 ? "." : normalize(joined);
    }
    function normalize(path) {
      var absolute;
      var value;
      assertPath(path);
      absolute = path.charCodeAt(0) === 47;
      value = normalizeString(path, !absolute);
      if (!value.length && !absolute) {
        value = ".";
      }
      if (value.length && path.charCodeAt(path.length - 1) === 47) {
        value += "/";
      }
      return absolute ? "/" + value : value;
    }
    function normalizeString(path, allowAboveRoot) {
      var result = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var index = -1;
      var code;
      var lastSlashIndex;
      while (++index <= path.length) {
        if (index < path.length) {
          code = path.charCodeAt(index);
        } else if (code === 47) {
          break;
        } else {
          code = 47;
        }
        if (code === 47) {
          if (lastSlash === index - 1 || dots === 1) {
          } else if (lastSlash !== index - 1 && dots === 2) {
            if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
              if (result.length > 2) {
                lastSlashIndex = result.lastIndexOf("/");
                if (lastSlashIndex !== result.length - 1) {
                  if (lastSlashIndex < 0) {
                    result = "";
                    lastSegmentLength = 0;
                  } else {
                    result = result.slice(0, lastSlashIndex);
                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                  }
                  lastSlash = index;
                  dots = 0;
                  continue;
                }
              } else if (result.length) {
                result = "";
                lastSegmentLength = 0;
                lastSlash = index;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              result = result.length ? result + "/.." : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (result.length) {
              result += "/" + path.slice(lastSlash + 1, index);
            } else {
              result = path.slice(lastSlash + 1, index);
            }
            lastSegmentLength = index - lastSlash - 1;
          }
          lastSlash = index;
          dots = 0;
        } else if (code === 46 && dots > -1) {
          dots++;
        } else {
          dots = -1;
        }
      }
      return result;
    }
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError(
          "Path must be a string. Received " + JSON.stringify(path)
        );
      }
    }
  }
});

// node_modules/vfile/lib/minproc.browser.js
var require_minproc_browser = __commonJS({
  "node_modules/vfile/lib/minproc.browser.js"(exports) {
    "use strict";
    exports.cwd = cwd;
    function cwd() {
      return "/";
    }
  }
});

// node_modules/vfile/lib/core.js
var require_core = __commonJS({
  "node_modules/vfile/lib/core.js"(exports, module) {
    "use strict";
    var p2 = require_minpath_browser();
    var proc = require_minproc_browser();
    var buffer = require_is_buffer();
    module.exports = VFile;
    var own = {}.hasOwnProperty;
    var order = ["history", "path", "basename", "stem", "extname", "dirname"];
    VFile.prototype.toString = toString;
    Object.defineProperty(VFile.prototype, "path", { get: getPath, set: setPath });
    Object.defineProperty(VFile.prototype, "dirname", {
      get: getDirname,
      set: setDirname
    });
    Object.defineProperty(VFile.prototype, "basename", {
      get: getBasename,
      set: setBasename
    });
    Object.defineProperty(VFile.prototype, "extname", {
      get: getExtname,
      set: setExtname
    });
    Object.defineProperty(VFile.prototype, "stem", { get: getStem, set: setStem });
    function VFile(options) {
      var prop;
      var index;
      if (!options) {
        options = {};
      } else if (typeof options === "string" || buffer(options)) {
        options = { contents: options };
      } else if ("message" in options && "messages" in options) {
        return options;
      }
      if (!(this instanceof VFile)) {
        return new VFile(options);
      }
      this.data = {};
      this.messages = [];
      this.history = [];
      this.cwd = proc.cwd();
      index = -1;
      while (++index < order.length) {
        prop = order[index];
        if (own.call(options, prop)) {
          this[prop] = options[prop];
        }
      }
      for (prop in options) {
        if (order.indexOf(prop) < 0) {
          this[prop] = options[prop];
        }
      }
    }
    function getPath() {
      return this.history[this.history.length - 1];
    }
    function setPath(path) {
      assertNonEmpty(path, "path");
      if (this.path !== path) {
        this.history.push(path);
      }
    }
    function getDirname() {
      return typeof this.path === "string" ? p2.dirname(this.path) : void 0;
    }
    function setDirname(dirname) {
      assertPath(this.path, "dirname");
      this.path = p2.join(dirname || "", this.basename);
    }
    function getBasename() {
      return typeof this.path === "string" ? p2.basename(this.path) : void 0;
    }
    function setBasename(basename) {
      assertNonEmpty(basename, "basename");
      assertPart(basename, "basename");
      this.path = p2.join(this.dirname || "", basename);
    }
    function getExtname() {
      return typeof this.path === "string" ? p2.extname(this.path) : void 0;
    }
    function setExtname(extname) {
      assertPart(extname, "extname");
      assertPath(this.path, "extname");
      if (extname) {
        if (extname.charCodeAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname.indexOf(".", 1) > -1) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = p2.join(this.dirname, this.stem + (extname || ""));
    }
    function getStem() {
      return typeof this.path === "string" ? p2.basename(this.path, this.extname) : void 0;
    }
    function setStem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = p2.join(this.dirname || "", stem + (this.extname || ""));
    }
    function toString(encoding) {
      return (this.contents || "").toString(encoding);
    }
    function assertPart(part, name) {
      if (part && part.indexOf(p2.sep) > -1) {
        throw new Error(
          "`" + name + "` cannot be a path: did not expect `" + p2.sep + "`"
        );
      }
    }
    function assertNonEmpty(part, name) {
      if (!part) {
        throw new Error("`" + name + "` cannot be empty");
      }
    }
    function assertPath(path, name) {
      if (!path) {
        throw new Error("Setting `" + name + "` requires `path` to be set too");
      }
    }
  }
});

// node_modules/vfile/lib/index.js
var require_lib = __commonJS({
  "node_modules/vfile/lib/index.js"(exports, module) {
    "use strict";
    var VMessage = require_vfile_message();
    var VFile = require_core();
    module.exports = VFile;
    VFile.prototype.message = message;
    VFile.prototype.info = info;
    VFile.prototype.fail = fail;
    function message(reason, position, origin) {
      var message2 = new VMessage(reason, position, origin);
      if (this.path) {
        message2.name = this.path + ":" + message2.name;
        message2.file = this.path;
      }
      message2.fatal = false;
      this.messages.push(message2);
      return message2;
    }
    function fail() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = true;
      throw message2;
    }
    function info() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = null;
      return message2;
    }
  }
});

// node_modules/vfile/index.js
var require_vfile = __commonJS({
  "node_modules/vfile/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});

// node_modules/unified/index.js
var require_unified = __commonJS({
  "node_modules/unified/index.js"(exports, module) {
    "use strict";
    var bail = require_bail();
    var buffer = require_is_buffer();
    var extend = require_extend();
    var plain = require_is_plain_obj();
    var trough = require_trough();
    var vfile = require_vfile();
    module.exports = unified().freeze();
    var slice = [].slice;
    var own = {}.hasOwnProperty;
    var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
    function pipelineParse(p2, ctx) {
      ctx.tree = p2.parse(ctx.file);
    }
    function pipelineRun(p2, ctx, next) {
      p2.run(ctx.tree, ctx.file, done);
      function done(error, tree, file) {
        if (error) {
          next(error);
        } else {
          ctx.tree = tree;
          ctx.file = file;
          next();
        }
      }
    }
    function pipelineStringify(p2, ctx) {
      var result = p2.stringify(ctx.tree, ctx.file);
      if (result === void 0 || result === null) {
      } else if (typeof result === "string" || buffer(result)) {
        if ("value" in ctx.file) {
          ctx.file.value = result;
        }
        ctx.file.contents = result;
      } else {
        ctx.file.result = result;
      }
    }
    function unified() {
      var attachers = [];
      var transformers = trough();
      var namespace = {};
      var freezeIndex = -1;
      var frozen;
      processor.data = data;
      processor.freeze = freeze;
      processor.attachers = attachers;
      processor.use = use;
      processor.parse = parse;
      processor.stringify = stringify;
      processor.run = run;
      processor.runSync = runSync;
      processor.process = process;
      processor.processSync = processSync;
      return processor;
      function processor() {
        var destination = unified();
        var index = -1;
        while (++index < attachers.length) {
          destination.use.apply(null, attachers[index]);
        }
        destination.data(extend(true, {}, namespace));
        return destination;
      }
      function freeze() {
        var values;
        var transformer;
        if (frozen) {
          return processor;
        }
        while (++freezeIndex < attachers.length) {
          values = attachers[freezeIndex];
          if (values[1] === false) {
            continue;
          }
          if (values[1] === true) {
            values[1] = void 0;
          }
          transformer = values[0].apply(processor, values.slice(1));
          if (typeof transformer === "function") {
            transformers.use(transformer);
          }
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
      }
      function data(key, value) {
        if (typeof key === "string") {
          if (arguments.length === 2) {
            assertUnfrozen("data", frozen);
            namespace[key] = value;
            return processor;
          }
          return own.call(namespace, key) && namespace[key] || null;
        }
        if (key) {
          assertUnfrozen("data", frozen);
          namespace = key;
          return processor;
        }
        return namespace;
      }
      function use(value) {
        var settings;
        assertUnfrozen("use", frozen);
        if (value === null || value === void 0) {
        } else if (typeof value === "function") {
          addPlugin.apply(null, arguments);
        } else if (typeof value === "object") {
          if ("length" in value) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new Error("Expected usable value, not `" + value + "`");
        }
        if (settings) {
          namespace.settings = extend(namespace.settings || {}, settings);
        }
        return processor;
        function addPreset(result) {
          addList(result.plugins);
          if (result.settings) {
            settings = extend(settings || {}, result.settings);
          }
        }
        function add(value2) {
          if (typeof value2 === "function") {
            addPlugin(value2);
          } else if (typeof value2 === "object") {
            if ("length" in value2) {
              addPlugin.apply(null, value2);
            } else {
              addPreset(value2);
            }
          } else {
            throw new Error("Expected usable value, not `" + value2 + "`");
          }
        }
        function addList(plugins) {
          var index = -1;
          if (plugins === null || plugins === void 0) {
          } else if (typeof plugins === "object" && "length" in plugins) {
            while (++index < plugins.length) {
              add(plugins[index]);
            }
          } else {
            throw new Error("Expected a list of plugins, not `" + plugins + "`");
          }
        }
        function addPlugin(plugin, value2) {
          var entry = find(plugin);
          if (entry) {
            if (plain(entry[1]) && plain(value2)) {
              value2 = extend(true, entry[1], value2);
            }
            entry[1] = value2;
          } else {
            attachers.push(slice.call(arguments));
          }
        }
      }
      function find(plugin) {
        var index = -1;
        while (++index < attachers.length) {
          if (attachers[index][0] === plugin) {
            return attachers[index];
          }
        }
      }
      function parse(doc) {
        var file = vfile(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        assertParser("parse", Parser);
        if (newable(Parser, "parse")) {
          return new Parser(String(file), file).parse();
        }
        return Parser(String(file), file);
      }
      function run(node, file, cb) {
        assertNode(node);
        freeze();
        if (!cb && typeof file === "function") {
          cb = file;
          file = null;
        }
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve, reject) {
          transformers.run(node, vfile(file), done);
          function done(error, tree, file2) {
            tree = tree || node;
            if (error) {
              reject(error);
            } else if (resolve) {
              resolve(tree);
            } else {
              cb(null, tree, file2);
            }
          }
        }
      }
      function runSync(node, file) {
        var result;
        var complete;
        run(node, file, done);
        assertDone("runSync", "run", complete);
        return result;
        function done(error, tree) {
          complete = true;
          result = tree;
          bail(error);
        }
      }
      function stringify(node, doc) {
        var file = vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        assertCompiler("stringify", Compiler);
        assertNode(node);
        if (newable(Compiler, "compile")) {
          return new Compiler(node, file).compile();
        }
        return Compiler(node, file);
      }
      function process(doc, cb) {
        freeze();
        assertParser("process", processor.Parser);
        assertCompiler("process", processor.Compiler);
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve, reject) {
          var file = vfile(doc);
          pipeline.run(processor, { file }, done);
          function done(error) {
            if (error) {
              reject(error);
            } else if (resolve) {
              resolve(file);
            } else {
              cb(null, file);
            }
          }
        }
      }
      function processSync(doc) {
        var file;
        var complete;
        freeze();
        assertParser("processSync", processor.Parser);
        assertCompiler("processSync", processor.Compiler);
        file = vfile(doc);
        process(file, done);
        assertDone("processSync", "process", complete);
        return file;
        function done(error) {
          complete = true;
          bail(error);
        }
      }
    }
    function newable(value, name) {
      return typeof value === "function" && value.prototype && (keys(value.prototype) || name in value.prototype);
    }
    function keys(value) {
      var key;
      for (key in value) {
        return true;
      }
      return false;
    }
    function assertParser(name, Parser) {
      if (typeof Parser !== "function") {
        throw new Error("Cannot `" + name + "` without `Parser`");
      }
    }
    function assertCompiler(name, Compiler) {
      if (typeof Compiler !== "function") {
        throw new Error("Cannot `" + name + "` without `Compiler`");
      }
    }
    function assertUnfrozen(name, frozen) {
      if (frozen) {
        throw new Error(
          "Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
        );
      }
    }
    function assertNode(node) {
      if (!node || typeof node.type !== "string") {
        throw new Error("Expected node, got `" + node + "`");
      }
    }
    function assertDone(name, asyncName, complete) {
      if (!complete) {
        throw new Error(
          "`" + name + "` finished async. Use `" + asyncName + "` instead"
        );
      }
    }
  }
});

// node_modules/mdast-util-to-string/index.js
var require_mdast_util_to_string = __commonJS({
  "node_modules/mdast-util-to-string/index.js"(exports, module) {
    "use strict";
    module.exports = toString;
    function toString(node) {
      return node && (node.value || node.alt || node.title || "children" in node && all(node.children) || "length" in node && all(node)) || "";
    }
    function all(values) {
      var result = [];
      var index = -1;
      while (++index < values.length) {
        result[index] = toString(values[index]);
      }
      return result.join("");
    }
  }
});

// node_modules/micromark/dist/constant/assign.js
var require_assign = __commonJS({
  "node_modules/micromark/dist/constant/assign.js"(exports, module) {
    "use strict";
    var assign = Object.assign;
    module.exports = assign;
  }
});

// node_modules/micromark/dist/constant/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/micromark/dist/constant/has-own-property.js"(exports, module) {
    "use strict";
    var own = {}.hasOwnProperty;
    module.exports = own;
  }
});

// node_modules/micromark/dist/util/normalize-identifier.js
var require_normalize_identifier = __commonJS({
  "node_modules/micromark/dist/util/normalize-identifier.js"(exports, module) {
    "use strict";
    function normalizeIdentifier(value) {
      return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
    }
    module.exports = normalizeIdentifier;
  }
});

// node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code = __commonJS({
  "node_modules/micromark/dist/constant/from-char-code.js"(exports, module) {
    "use strict";
    var fromCharCode = String.fromCharCode;
    module.exports = fromCharCode;
  }
});

// node_modules/micromark/dist/util/safe-from-int.js
var require_safe_from_int = __commonJS({
  "node_modules/micromark/dist/util/safe-from-int.js"(exports, module) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function safeFromInt(value, base) {
      var code = parseInt(value, base);
      if (code < 9 || code === 11 || code > 13 && code < 32 || code > 126 && code < 160 || code > 55295 && code < 57344 || code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || code > 1114111) {
        return "\uFFFD";
      }
      return fromCharCode(code);
    }
    module.exports = safeFromInt;
  }
});

// node_modules/micromark/dist/character/markdown-line-ending.js
var require_markdown_line_ending = __commonJS({
  "node_modules/micromark/dist/character/markdown-line-ending.js"(exports, module) {
    "use strict";
    function markdownLineEnding(code) {
      return code < -2;
    }
    module.exports = markdownLineEnding;
  }
});

// node_modules/micromark/dist/character/markdown-space.js
var require_markdown_space = __commonJS({
  "node_modules/micromark/dist/character/markdown-space.js"(exports, module) {
    "use strict";
    function markdownSpace(code) {
      return code === -2 || code === -1 || code === 32;
    }
    module.exports = markdownSpace;
  }
});

// node_modules/micromark/dist/tokenize/factory-space.js
var require_factory_space = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-space.js"(exports, module) {
    "use strict";
    var markdownSpace = require_markdown_space();
    function spaceFactory(effects, ok, type, max) {
      var limit = max ? max - 1 : Infinity;
      var size = 0;
      return start;
      function start(code) {
        if (markdownSpace(code)) {
          effects.enter(type);
          return prefix(code);
        }
        return ok(code);
      }
      function prefix(code) {
        if (markdownSpace(code) && size++ < limit) {
          effects.consume(code);
          return prefix;
        }
        effects.exit(type);
        return ok(code);
      }
    }
    module.exports = spaceFactory;
  }
});

// node_modules/micromark/dist/initialize/content.js
var require_content = __commonJS({
  "node_modules/micromark/dist/initialize/content.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var tokenize = initializeContent;
    function initializeContent(effects) {
      var contentStart = effects.attempt(
        this.parser.constructs.contentInitial,
        afterContentStartConstruct,
        paragraphInitial
      );
      var previous;
      return contentStart;
      function afterContentStartConstruct(code) {
        if (code === null) {
          effects.consume(code);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, contentStart, "linePrefix");
      }
      function paragraphInitial(code) {
        effects.enter("paragraph");
        return lineStart(code);
      }
      function lineStart(code) {
        var token = effects.enter("chunkText", {
          contentType: "text",
          previous
        });
        if (previous) {
          previous.next = token;
        }
        previous = token;
        return data(code);
      }
      function data(code) {
        if (code === null) {
          effects.exit("chunkText");
          effects.exit("paragraph");
          effects.consume(code);
          return;
        }
        if (markdownLineEnding(code)) {
          effects.consume(code);
          effects.exit("chunkText");
          return lineStart;
        }
        effects.consume(code);
        return data;
      }
    }
    exports.tokenize = tokenize;
  }
});

// node_modules/micromark/dist/tokenize/partial-blank-line.js
var require_partial_blank_line = __commonJS({
  "node_modules/micromark/dist/tokenize/partial-blank-line.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var partialBlankLine = {
      tokenize: tokenizePartialBlankLine,
      partial: true
    };
    function tokenizePartialBlankLine(effects, ok, nok) {
      return factorySpace(effects, afterWhitespace, "linePrefix");
      function afterWhitespace(code) {
        return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
      }
    }
    module.exports = partialBlankLine;
  }
});

// node_modules/micromark/dist/initialize/document.js
var require_document = __commonJS({
  "node_modules/micromark/dist/initialize/document.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var tokenize = initializeDocument;
    var containerConstruct = {
      tokenize: tokenizeContainer
    };
    var lazyFlowConstruct = {
      tokenize: tokenizeLazyFlow
    };
    function initializeDocument(effects) {
      var self2 = this;
      var stack = [];
      var continued = 0;
      var inspectConstruct = {
        tokenize: tokenizeInspect,
        partial: true
      };
      var inspectResult;
      var childFlow;
      var childToken;
      return start;
      function start(code) {
        if (continued < stack.length) {
          self2.containerState = stack[continued][1];
          return effects.attempt(
            stack[continued][0].continuation,
            documentContinue,
            documentContinued
          )(code);
        }
        return documentContinued(code);
      }
      function documentContinue(code) {
        continued++;
        return start(code);
      }
      function documentContinued(code) {
        if (inspectResult && inspectResult.flowContinue) {
          return flowStart(code);
        }
        self2.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
        self2.containerState = {};
        return effects.attempt(
          containerConstruct,
          containerContinue,
          flowStart
        )(code);
      }
      function containerContinue(code) {
        stack.push([self2.currentConstruct, self2.containerState]);
        self2.containerState = void 0;
        return documentContinued(code);
      }
      function flowStart(code) {
        if (code === null) {
          exitContainers(0, true);
          effects.consume(code);
          return;
        }
        childFlow = childFlow || self2.parser.flow(self2.now());
        effects.enter("chunkFlow", {
          contentType: "flow",
          previous: childToken,
          _tokenizer: childFlow
        });
        return flowContinue(code);
      }
      function flowContinue(code) {
        if (code === null) {
          continueFlow(effects.exit("chunkFlow"));
          return flowStart(code);
        }
        if (markdownLineEnding(code)) {
          effects.consume(code);
          continueFlow(effects.exit("chunkFlow"));
          return effects.check(inspectConstruct, documentAfterPeek);
        }
        effects.consume(code);
        return flowContinue;
      }
      function documentAfterPeek(code) {
        exitContainers(
          inspectResult.continued,
          inspectResult && inspectResult.flowEnd
        );
        continued = 0;
        return start(code);
      }
      function continueFlow(token) {
        if (childToken)
          childToken.next = token;
        childToken = token;
        childFlow.lazy = inspectResult && inspectResult.lazy;
        childFlow.defineSkip(token.start);
        childFlow.write(self2.sliceStream(token));
      }
      function exitContainers(size, end) {
        var index = stack.length;
        if (childFlow && end) {
          childFlow.write([null]);
          childToken = childFlow = void 0;
        }
        while (index-- > size) {
          self2.containerState = stack[index][1];
          stack[index][0].exit.call(self2, effects);
        }
        stack.length = size;
      }
      function tokenizeInspect(effects2, ok) {
        var subcontinued = 0;
        inspectResult = {};
        return inspectStart;
        function inspectStart(code) {
          if (subcontinued < stack.length) {
            self2.containerState = stack[subcontinued][1];
            return effects2.attempt(
              stack[subcontinued][0].continuation,
              inspectContinue,
              inspectLess
            )(code);
          }
          if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
            inspectResult.flowContinue = true;
            return inspectDone(code);
          }
          self2.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
          self2.containerState = {};
          return effects2.attempt(
            containerConstruct,
            inspectFlowEnd,
            inspectDone
          )(code);
        }
        function inspectContinue(code) {
          subcontinued++;
          return self2.containerState._closeFlow ? inspectFlowEnd(code) : inspectStart(code);
        }
        function inspectLess(code) {
          if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
            self2.containerState = {};
            return effects2.attempt(
              containerConstruct,
              inspectFlowEnd,
              effects2.attempt(
                lazyFlowConstruct,
                inspectFlowEnd,
                effects2.check(partialBlankLine, inspectFlowEnd, inspectLazy)
              )
            )(code);
          }
          return inspectFlowEnd(code);
        }
        function inspectLazy(code) {
          subcontinued = stack.length;
          inspectResult.lazy = true;
          inspectResult.flowContinue = true;
          return inspectDone(code);
        }
        function inspectFlowEnd(code) {
          inspectResult.flowEnd = true;
          return inspectDone(code);
        }
        function inspectDone(code) {
          inspectResult.continued = subcontinued;
          self2.interrupt = self2.containerState = void 0;
          return ok(code);
        }
      }
    }
    function tokenizeContainer(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(this.parser.constructs.document, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function tokenizeLazyFlow(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.lazy(this.parser.constructs.flow, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    exports.tokenize = tokenize;
  }
});

// node_modules/micromark/dist/util/size-chunks.js
var require_size_chunks = __commonJS({
  "node_modules/micromark/dist/util/size-chunks.js"(exports, module) {
    "use strict";
    function sizeChunks(chunks) {
      var index = -1;
      var size = 0;
      while (++index < chunks.length) {
        size += typeof chunks[index] === "string" ? chunks[index].length : 1;
      }
      return size;
    }
    module.exports = sizeChunks;
  }
});

// node_modules/micromark/dist/util/prefix-size.js
var require_prefix_size = __commonJS({
  "node_modules/micromark/dist/util/prefix-size.js"(exports, module) {
    "use strict";
    var sizeChunks = require_size_chunks();
    function prefixSize(events, type) {
      var tail = events[events.length - 1];
      if (!tail || tail[1].type !== type)
        return 0;
      return sizeChunks(tail[2].sliceStream(tail[1]));
    }
    module.exports = prefixSize;
  }
});

// node_modules/micromark/dist/constant/splice.js
var require_splice = __commonJS({
  "node_modules/micromark/dist/constant/splice.js"(exports, module) {
    "use strict";
    var splice = [].splice;
    module.exports = splice;
  }
});

// node_modules/micromark/dist/util/chunked-splice.js
var require_chunked_splice = __commonJS({
  "node_modules/micromark/dist/util/chunked-splice.js"(exports, module) {
    "use strict";
    var splice = require_splice();
    function chunkedSplice(list, start, remove, items) {
      var end = list.length;
      var chunkStart = 0;
      var parameters;
      if (start < 0) {
        start = -start > end ? 0 : end + start;
      } else {
        start = start > end ? end : start;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start, remove);
        splice.apply(list, parameters);
      } else {
        if (remove)
          splice.apply(list, [start, remove]);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start, 0);
          splice.apply(list, parameters);
          chunkStart += 1e4;
          start += 1e4;
        }
      }
    }
    module.exports = chunkedSplice;
  }
});

// node_modules/micromark/dist/util/shallow.js
var require_shallow = __commonJS({
  "node_modules/micromark/dist/util/shallow.js"(exports, module) {
    "use strict";
    var assign = require_assign();
    function shallow(object) {
      return assign({}, object);
    }
    module.exports = shallow;
  }
});

// node_modules/micromark/dist/util/subtokenize.js
var require_subtokenize = __commonJS({
  "node_modules/micromark/dist/util/subtokenize.js"(exports, module) {
    "use strict";
    var assign = require_assign();
    var chunkedSplice = require_chunked_splice();
    var shallow = require_shallow();
    function subtokenize(events) {
      var jumps = {};
      var index = -1;
      var event;
      var lineIndex;
      var otherIndex;
      var otherEvent;
      var parameters;
      var subevents;
      var more;
      while (++index < events.length) {
        while (index in jumps) {
          index = jumps[index];
        }
        event = events[index];
        if (index && event[1].type === "chunkFlow" && events[index - 1][1].type === "listItemPrefix") {
          subevents = event[1]._tokenizer.events;
          otherIndex = 0;
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
            otherIndex += 2;
          }
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
            while (++otherIndex < subevents.length) {
              if (subevents[otherIndex][1].type === "content") {
                break;
              }
              if (subevents[otherIndex][1].type === "chunkText") {
                subevents[otherIndex][1].isInFirstContentOfListItem = true;
                otherIndex++;
              }
            }
          }
        }
        if (event[0] === "enter") {
          if (event[1].contentType) {
            assign(jumps, subcontent(events, index));
            index = jumps[index];
            more = true;
          }
        } else if (event[1]._container || event[1]._movePreviousLineEndings) {
          otherIndex = index;
          lineIndex = void 0;
          while (otherIndex--) {
            otherEvent = events[otherIndex];
            if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
              if (otherEvent[0] === "enter") {
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                }
                otherEvent[1].type = "lineEnding";
                lineIndex = otherIndex;
              }
            } else {
              break;
            }
          }
          if (lineIndex) {
            event[1].end = shallow(events[lineIndex][1].start);
            parameters = events.slice(lineIndex, index);
            parameters.unshift(event);
            chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters);
          }
        }
      }
      return !more;
    }
    function subcontent(events, eventIndex) {
      var token = events[eventIndex][1];
      var context = events[eventIndex][2];
      var startPosition = eventIndex - 1;
      var startPositions = [];
      var tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
      var childEvents = tokenizer.events;
      var jumps = [];
      var gaps = {};
      var stream2;
      var previous;
      var index;
      var entered;
      var end;
      var adjust;
      while (token) {
        while (events[++startPosition][1] !== token) {
        }
        startPositions.push(startPosition);
        if (!token._tokenizer) {
          stream2 = context.sliceStream(token);
          if (!token.next) {
            stream2.push(null);
          }
          if (previous) {
            tokenizer.defineSkip(token.start);
          }
          if (token.isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = true;
          }
          tokenizer.write(stream2);
          if (token.isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = void 0;
          }
        }
        previous = token;
        token = token.next;
      }
      token = previous;
      index = childEvents.length;
      while (index--) {
        if (childEvents[index][0] === "enter") {
          entered = true;
        } else if (entered && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {
          add(childEvents.slice(index + 1, end));
          token._tokenizer = token.next = void 0;
          token = token.previous;
          end = index + 1;
        }
      }
      tokenizer.events = token._tokenizer = token.next = void 0;
      add(childEvents.slice(0, end));
      index = -1;
      adjust = 0;
      while (++index < jumps.length) {
        gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];
        adjust += jumps[index][1] - jumps[index][0] - 1;
      }
      return gaps;
      function add(slice) {
        var start = startPositions.pop();
        jumps.unshift([start, start + slice.length - 1]);
        chunkedSplice(events, start, 2, slice);
      }
    }
    module.exports = subtokenize;
  }
});

// node_modules/micromark/dist/tokenize/content.js
var require_content2 = __commonJS({
  "node_modules/micromark/dist/tokenize/content.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var prefixSize = require_prefix_size();
    var subtokenize = require_subtokenize();
    var factorySpace = require_factory_space();
    var content = {
      tokenize: tokenizeContent,
      resolve: resolveContent,
      interruptible: true,
      lazy: true
    };
    var continuationConstruct = {
      tokenize: tokenizeContinuation,
      partial: true
    };
    function resolveContent(events) {
      subtokenize(events);
      return events;
    }
    function tokenizeContent(effects, ok) {
      var previous;
      return start;
      function start(code) {
        effects.enter("content");
        previous = effects.enter("chunkContent", {
          contentType: "content"
        });
        return data(code);
      }
      function data(code) {
        if (code === null) {
          return contentEnd(code);
        }
        if (markdownLineEnding(code)) {
          return effects.check(
            continuationConstruct,
            contentContinue,
            contentEnd
          )(code);
        }
        effects.consume(code);
        return data;
      }
      function contentEnd(code) {
        effects.exit("chunkContent");
        effects.exit("content");
        return ok(code);
      }
      function contentContinue(code) {
        effects.consume(code);
        effects.exit("chunkContent");
        previous = previous.next = effects.enter("chunkContent", {
          contentType: "content",
          previous
        });
        return data;
      }
    }
    function tokenizeContinuation(effects, ok, nok) {
      var self2 = this;
      return startLookahead;
      function startLookahead(code) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, prefixed, "linePrefix");
      }
      function prefixed(code) {
        if (code === null || markdownLineEnding(code)) {
          return nok(code);
        }
        if (self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 || prefixSize(self2.events, "linePrefix") < 4) {
          return effects.interrupt(self2.parser.constructs.flow, nok, ok)(code);
        }
        return ok(code);
      }
    }
    module.exports = content;
  }
});

// node_modules/micromark/dist/initialize/flow.js
var require_flow = __commonJS({
  "node_modules/micromark/dist/initialize/flow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var content = require_content2();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var tokenize = initializeFlow;
    function initializeFlow(effects) {
      var self2 = this;
      var initial = effects.attempt(
        partialBlankLine,
        atBlankEnding,
        effects.attempt(
          this.parser.constructs.flowInitial,
          afterConstruct,
          factorySpace(
            effects,
            effects.attempt(
              this.parser.constructs.flow,
              afterConstruct,
              effects.attempt(content, afterConstruct)
            ),
            "linePrefix"
          )
        )
      );
      return initial;
      function atBlankEnding(code) {
        if (code === null) {
          effects.consume(code);
          return;
        }
        effects.enter("lineEndingBlank");
        effects.consume(code);
        effects.exit("lineEndingBlank");
        self2.currentConstruct = void 0;
        return initial;
      }
      function afterConstruct(code) {
        if (code === null) {
          effects.consume(code);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        self2.currentConstruct = void 0;
        return initial;
      }
    }
    exports.tokenize = tokenize;
  }
});

// node_modules/micromark/dist/initialize/text.js
var require_text2 = __commonJS({
  "node_modules/micromark/dist/initialize/text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assign = require_assign();
    var shallow = require_shallow();
    var text = initializeFactory("text");
    var string = initializeFactory("string");
    var resolver = {
      resolveAll: createResolver()
    };
    function initializeFactory(field) {
      return {
        tokenize: initializeText,
        resolveAll: createResolver(
          field === "text" ? resolveAllLineSuffixes : void 0
        )
      };
      function initializeText(effects) {
        var self2 = this;
        var constructs = this.parser.constructs[field];
        var text2 = effects.attempt(constructs, start, notText);
        return start;
        function start(code) {
          return atBreak(code) ? text2(code) : notText(code);
        }
        function notText(code) {
          if (code === null) {
            effects.consume(code);
            return;
          }
          effects.enter("data");
          effects.consume(code);
          return data;
        }
        function data(code) {
          if (atBreak(code)) {
            effects.exit("data");
            return text2(code);
          }
          effects.consume(code);
          return data;
        }
        function atBreak(code) {
          var list = constructs[code];
          var index = -1;
          if (code === null) {
            return true;
          }
          if (list) {
            while (++index < list.length) {
              if (!list[index].previous || list[index].previous.call(self2, self2.previous)) {
                return true;
              }
            }
          }
        }
      }
    }
    function createResolver(extraResolver) {
      return resolveAllText;
      function resolveAllText(events, context) {
        var index = -1;
        var enter;
        while (++index <= events.length) {
          if (enter === void 0) {
            if (events[index] && events[index][1].type === "data") {
              enter = index;
              index++;
            }
          } else if (!events[index] || events[index][1].type !== "data") {
            if (index !== enter + 2) {
              events[enter][1].end = events[index - 1][1].end;
              events.splice(enter + 2, index - enter - 2);
              index = enter + 2;
            }
            enter = void 0;
          }
        }
        return extraResolver ? extraResolver(events, context) : events;
      }
    }
    function resolveAllLineSuffixes(events, context) {
      var eventIndex = -1;
      var chunks;
      var data;
      var chunk;
      var index;
      var bufferIndex;
      var size;
      var tabs;
      var token;
      while (++eventIndex <= events.length) {
        if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
          data = events[eventIndex - 1][1];
          chunks = context.sliceStream(data);
          index = chunks.length;
          bufferIndex = -1;
          size = 0;
          tabs = void 0;
          while (index--) {
            chunk = chunks[index];
            if (typeof chunk === "string") {
              bufferIndex = chunk.length;
              while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                size++;
                bufferIndex--;
              }
              if (bufferIndex)
                break;
              bufferIndex = -1;
            } else if (chunk === -2) {
              tabs = true;
              size++;
            } else if (chunk === -1)
              ;
            else {
              index++;
              break;
            }
          }
          if (size) {
            token = {
              type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
              start: {
                line: data.end.line,
                column: data.end.column - size,
                offset: data.end.offset - size,
                _index: data.start._index + index,
                _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex
              },
              end: shallow(data.end)
            };
            data.end = shallow(token.start);
            if (data.start.offset === data.end.offset) {
              assign(data, token);
            } else {
              events.splice(
                eventIndex,
                0,
                ["enter", token, context],
                ["exit", token, context]
              );
              eventIndex += 2;
            }
          }
          eventIndex++;
        }
      }
      return events;
    }
    exports.resolver = resolver;
    exports.string = string;
    exports.text = text;
  }
});

// node_modules/micromark/dist/util/miniflat.js
var require_miniflat = __commonJS({
  "node_modules/micromark/dist/util/miniflat.js"(exports, module) {
    "use strict";
    function miniflat(value) {
      return value === null || value === void 0 ? [] : "length" in value ? value : [value];
    }
    module.exports = miniflat;
  }
});

// node_modules/micromark/dist/util/combine-extensions.js
var require_combine_extensions = __commonJS({
  "node_modules/micromark/dist/util/combine-extensions.js"(exports, module) {
    "use strict";
    var hasOwnProperty = require_has_own_property();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    function combineExtensions(extensions) {
      var all = {};
      var index = -1;
      while (++index < extensions.length) {
        extension(all, extensions[index]);
      }
      return all;
    }
    function extension(all, extension2) {
      var hook;
      var left;
      var right;
      var code;
      for (hook in extension2) {
        left = hasOwnProperty.call(all, hook) ? all[hook] : all[hook] = {};
        right = extension2[hook];
        for (code in right) {
          left[code] = constructs(
            miniflat(right[code]),
            hasOwnProperty.call(left, code) ? left[code] : []
          );
        }
      }
    }
    function constructs(list, existing) {
      var index = -1;
      var before = [];
      while (++index < list.length) {
        ;
        (list[index].add === "after" ? existing : before).push(list[index]);
      }
      chunkedSplice(existing, 0, 0, before);
      return existing;
    }
    module.exports = combineExtensions;
  }
});

// node_modules/micromark/dist/util/chunked-push.js
var require_chunked_push = __commonJS({
  "node_modules/micromark/dist/util/chunked-push.js"(exports, module) {
    "use strict";
    var chunkedSplice = require_chunked_splice();
    function chunkedPush(list, items) {
      if (list.length) {
        chunkedSplice(list, list.length, 0, items);
        return list;
      }
      return items;
    }
    module.exports = chunkedPush;
  }
});

// node_modules/micromark/dist/util/resolve-all.js
var require_resolve_all = __commonJS({
  "node_modules/micromark/dist/util/resolve-all.js"(exports, module) {
    "use strict";
    function resolveAll(constructs, events, context) {
      var called = [];
      var index = -1;
      var resolve;
      while (++index < constructs.length) {
        resolve = constructs[index].resolveAll;
        if (resolve && called.indexOf(resolve) < 0) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }
      return events;
    }
    module.exports = resolveAll;
  }
});

// node_modules/micromark/dist/util/serialize-chunks.js
var require_serialize_chunks = __commonJS({
  "node_modules/micromark/dist/util/serialize-chunks.js"(exports, module) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function serializeChunks(chunks) {
      var index = -1;
      var result = [];
      var chunk;
      var value;
      var atTab;
      while (++index < chunks.length) {
        chunk = chunks[index];
        if (typeof chunk === "string") {
          value = chunk;
        } else if (chunk === -5) {
          value = "\r";
        } else if (chunk === -4) {
          value = "\n";
        } else if (chunk === -3) {
          value = "\r\n";
        } else if (chunk === -2) {
          value = "	";
        } else if (chunk === -1) {
          if (atTab)
            continue;
          value = " ";
        } else {
          value = fromCharCode(chunk);
        }
        atTab = chunk === -2;
        result.push(value);
      }
      return result.join("");
    }
    module.exports = serializeChunks;
  }
});

// node_modules/micromark/dist/util/slice-chunks.js
var require_slice_chunks = __commonJS({
  "node_modules/micromark/dist/util/slice-chunks.js"(exports, module) {
    "use strict";
    function sliceChunks(chunks, token) {
      var startIndex = token.start._index;
      var startBufferIndex = token.start._bufferIndex;
      var endIndex = token.end._index;
      var endBufferIndex = token.end._bufferIndex;
      var view;
      if (startIndex === endIndex) {
        view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
      } else {
        view = chunks.slice(startIndex, endIndex);
        if (startBufferIndex > -1) {
          view[0] = view[0].slice(startBufferIndex);
        }
        if (endBufferIndex > 0) {
          view.push(chunks[endIndex].slice(0, endBufferIndex));
        }
      }
      return view;
    }
    module.exports = sliceChunks;
  }
});

// node_modules/micromark/dist/util/create-tokenizer.js
var require_create_tokenizer = __commonJS({
  "node_modules/micromark/dist/util/create-tokenizer.js"(exports, module) {
    "use strict";
    var assign = require_assign();
    var markdownLineEnding = require_markdown_line_ending();
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    var resolveAll = require_resolve_all();
    var serializeChunks = require_serialize_chunks();
    var shallow = require_shallow();
    var sliceChunks = require_slice_chunks();
    function createTokenizer(parser, initialize, from) {
      var point = from ? shallow(from) : {
        line: 1,
        column: 1,
        offset: 0
      };
      var columnStart = {};
      var resolveAllConstructs = [];
      var chunks = [];
      var stack = [];
      var effects = {
        consume,
        enter,
        exit,
        attempt: constructFactory(onsuccessfulconstruct),
        check: constructFactory(onsuccessfulcheck),
        interrupt: constructFactory(onsuccessfulcheck, {
          interrupt: true
        }),
        lazy: constructFactory(onsuccessfulcheck, {
          lazy: true
        })
      };
      var context = {
        previous: null,
        events: [],
        parser,
        sliceStream,
        sliceSerialize,
        now,
        defineSkip: skip2,
        write
      };
      var state = initialize.tokenize.call(context, effects);
      if (initialize.resolveAll) {
        resolveAllConstructs.push(initialize);
      }
      point._index = 0;
      point._bufferIndex = -1;
      return context;
      function write(slice) {
        chunks = chunkedPush(chunks, slice);
        main();
        if (chunks[chunks.length - 1] !== null) {
          return [];
        }
        addResult(initialize, 0);
        context.events = resolveAll(resolveAllConstructs, context.events, context);
        return context.events;
      }
      function sliceSerialize(token) {
        return serializeChunks(sliceStream(token));
      }
      function sliceStream(token) {
        return sliceChunks(chunks, token);
      }
      function now() {
        return shallow(point);
      }
      function skip2(value) {
        columnStart[value.line] = value.column;
        accountForPotentialSkip();
      }
      function main() {
        var chunkIndex;
        var chunk;
        while (point._index < chunks.length) {
          chunk = chunks[point._index];
          if (typeof chunk === "string") {
            chunkIndex = point._index;
            if (point._bufferIndex < 0) {
              point._bufferIndex = 0;
            }
            while (point._index === chunkIndex && point._bufferIndex < chunk.length) {
              go(chunk.charCodeAt(point._bufferIndex));
            }
          } else {
            go(chunk);
          }
        }
      }
      function go(code) {
        state = state(code);
      }
      function consume(code) {
        if (markdownLineEnding(code)) {
          point.line++;
          point.column = 1;
          point.offset += code === -3 ? 2 : 1;
          accountForPotentialSkip();
        } else if (code !== -1) {
          point.column++;
          point.offset++;
        }
        if (point._bufferIndex < 0) {
          point._index++;
        } else {
          point._bufferIndex++;
          if (point._bufferIndex === chunks[point._index].length) {
            point._bufferIndex = -1;
            point._index++;
          }
        }
        context.previous = code;
      }
      function enter(type, fields) {
        var token = fields || {};
        token.type = type;
        token.start = now();
        context.events.push(["enter", token, context]);
        stack.push(token);
        return token;
      }
      function exit(type) {
        var token = stack.pop();
        token.end = now();
        context.events.push(["exit", token, context]);
        return token;
      }
      function onsuccessfulconstruct(construct, info) {
        addResult(construct, info.from);
      }
      function onsuccessfulcheck(construct, info) {
        info.restore();
      }
      function constructFactory(onreturn, fields) {
        return hook;
        function hook(constructs, returnState, bogusState) {
          var listOfConstructs;
          var constructIndex;
          var currentConstruct;
          var info;
          return constructs.tokenize || "length" in constructs ? handleListOfConstructs(miniflat(constructs)) : handleMapOfConstructs;
          function handleMapOfConstructs(code) {
            if (code in constructs || null in constructs) {
              return handleListOfConstructs(
                constructs.null ? miniflat(constructs[code]).concat(miniflat(constructs.null)) : constructs[code]
              )(code);
            }
            return bogusState(code);
          }
          function handleListOfConstructs(list) {
            listOfConstructs = list;
            constructIndex = 0;
            return handleConstruct(list[constructIndex]);
          }
          function handleConstruct(construct) {
            return start;
            function start(code) {
              info = store();
              currentConstruct = construct;
              if (!construct.partial) {
                context.currentConstruct = construct;
              }
              if (construct.name && context.parser.constructs.disable.null.indexOf(construct.name) > -1) {
                return nok();
              }
              return construct.tokenize.call(
                fields ? assign({}, context, fields) : context,
                effects,
                ok,
                nok
              )(code);
            }
          }
          function ok(code) {
            onreturn(currentConstruct, info);
            return returnState;
          }
          function nok(code) {
            info.restore();
            if (++constructIndex < listOfConstructs.length) {
              return handleConstruct(listOfConstructs[constructIndex]);
            }
            return bogusState;
          }
        }
      }
      function addResult(construct, from2) {
        if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
          resolveAllConstructs.push(construct);
        }
        if (construct.resolve) {
          chunkedSplice(
            context.events,
            from2,
            context.events.length - from2,
            construct.resolve(context.events.slice(from2), context)
          );
        }
        if (construct.resolveTo) {
          context.events = construct.resolveTo(context.events, context);
        }
      }
      function store() {
        var startPoint = now();
        var startPrevious = context.previous;
        var startCurrentConstruct = context.currentConstruct;
        var startEventsIndex = context.events.length;
        var startStack = Array.from(stack);
        return {
          restore,
          from: startEventsIndex
        };
        function restore() {
          point = startPoint;
          context.previous = startPrevious;
          context.currentConstruct = startCurrentConstruct;
          context.events.length = startEventsIndex;
          stack = startStack;
          accountForPotentialSkip();
        }
      }
      function accountForPotentialSkip() {
        if (point.line in columnStart && point.column < 2) {
          point.column = columnStart[point.line];
          point.offset += columnStart[point.line] - 1;
        }
      }
    }
    module.exports = createTokenizer;
  }
});

// node_modules/micromark/dist/character/markdown-line-ending-or-space.js
var require_markdown_line_ending_or_space = __commonJS({
  "node_modules/micromark/dist/character/markdown-line-ending-or-space.js"(exports, module) {
    "use strict";
    function markdownLineEndingOrSpace(code) {
      return code < 0 || code === 32;
    }
    module.exports = markdownLineEndingOrSpace;
  }
});

// node_modules/micromark/dist/constant/unicode-punctuation-regex.js
var require_unicode_punctuation_regex = __commonJS({
  "node_modules/micromark/dist/constant/unicode-punctuation-regex.js"(exports, module) {
    "use strict";
    var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    module.exports = unicodePunctuation;
  }
});

// node_modules/micromark/dist/util/regex-check.js
var require_regex_check = __commonJS({
  "node_modules/micromark/dist/util/regex-check.js"(exports, module) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function regexCheck(regex) {
      return check;
      function check(code) {
        return regex.test(fromCharCode(code));
      }
    }
    module.exports = regexCheck;
  }
});

// node_modules/micromark/dist/character/unicode-punctuation.js
var require_unicode_punctuation = __commonJS({
  "node_modules/micromark/dist/character/unicode-punctuation.js"(exports, module) {
    "use strict";
    var unicodePunctuationRegex = require_unicode_punctuation_regex();
    var regexCheck = require_regex_check();
    var unicodePunctuation = regexCheck(unicodePunctuationRegex);
    module.exports = unicodePunctuation;
  }
});

// node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace = __commonJS({
  "node_modules/micromark/dist/character/unicode-whitespace.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var unicodeWhitespace = regexCheck(/\s/);
    module.exports = unicodeWhitespace;
  }
});

// node_modules/micromark/dist/util/classify-character.js
var require_classify_character = __commonJS({
  "node_modules/micromark/dist/util/classify-character.js"(exports, module) {
    "use strict";
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var unicodePunctuation = require_unicode_punctuation();
    var unicodeWhitespace = require_unicode_whitespace();
    function classifyCharacter(code) {
      if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
        return 1;
      }
      if (unicodePunctuation(code)) {
        return 2;
      }
    }
    module.exports = classifyCharacter;
  }
});

// node_modules/micromark/dist/util/move-point.js
var require_move_point = __commonJS({
  "node_modules/micromark/dist/util/move-point.js"(exports, module) {
    "use strict";
    function movePoint(point, offset) {
      point.column += offset;
      point.offset += offset;
      point._bufferIndex += offset;
      return point;
    }
    module.exports = movePoint;
  }
});

// node_modules/micromark/dist/tokenize/attention.js
var require_attention = __commonJS({
  "node_modules/micromark/dist/tokenize/attention.js"(exports, module) {
    "use strict";
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var classifyCharacter = require_classify_character();
    var movePoint = require_move_point();
    var resolveAll = require_resolve_all();
    var shallow = require_shallow();
    var attention = {
      name: "attention",
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
    function resolveAllAttention(events, context) {
      var index = -1;
      var open;
      var group;
      var text;
      var openingSequence;
      var closingSequence;
      var use;
      var nextEvents;
      var offset;
      while (++index < events.length) {
        if (events[index][0] === "enter" && events[index][1].type === "attentionSequence" && events[index][1]._close) {
          open = index;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {
              if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {
                continue;
              }
              use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;
              openingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: movePoint(shallow(events[open][1].end), -use),
                end: shallow(events[open][1].end)
              };
              closingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: shallow(events[index][1].start),
                end: movePoint(shallow(events[index][1].start), use)
              };
              text = {
                type: use > 1 ? "strongText" : "emphasisText",
                start: shallow(events[open][1].end),
                end: shallow(events[index][1].start)
              };
              group = {
                type: use > 1 ? "strong" : "emphasis",
                start: shallow(openingSequence.start),
                end: shallow(closingSequence.end)
              };
              events[open][1].end = shallow(openingSequence.start);
              events[index][1].start = shallow(closingSequence.end);
              nextEvents = [];
              if (events[open][1].end.offset - events[open][1].start.offset) {
                nextEvents = chunkedPush(nextEvents, [
                  ["enter", events[open][1], context],
                  ["exit", events[open][1], context]
                ]);
              }
              nextEvents = chunkedPush(nextEvents, [
                ["enter", group, context],
                ["enter", openingSequence, context],
                ["exit", openingSequence, context],
                ["enter", text, context]
              ]);
              nextEvents = chunkedPush(
                nextEvents,
                resolveAll(
                  context.parser.constructs.insideSpan.null,
                  events.slice(open + 1, index),
                  context
                )
              );
              nextEvents = chunkedPush(nextEvents, [
                ["exit", text, context],
                ["enter", closingSequence, context],
                ["exit", closingSequence, context],
                ["exit", group, context]
              ]);
              if (events[index][1].end.offset - events[index][1].start.offset) {
                offset = 2;
                nextEvents = chunkedPush(nextEvents, [
                  ["enter", events[index][1], context],
                  ["exit", events[index][1], context]
                ]);
              } else {
                offset = 0;
              }
              chunkedSplice(events, open - 1, index - open + 3, nextEvents);
              index = open + nextEvents.length - offset - 2;
              break;
            }
          }
        }
      }
      index = -1;
      while (++index < events.length) {
        if (events[index][1].type === "attentionSequence") {
          events[index][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeAttention(effects, ok) {
      var before = classifyCharacter(this.previous);
      var marker;
      return start;
      function start(code) {
        effects.enter("attentionSequence");
        marker = code;
        return sequence(code);
      }
      function sequence(code) {
        var token;
        var after;
        var open;
        var close;
        if (code === marker) {
          effects.consume(code);
          return sequence;
        }
        token = effects.exit("attentionSequence");
        after = classifyCharacter(code);
        open = !after || after === 2 && before;
        close = !before || before === 2 && after;
        token._open = marker === 42 ? open : open && (before || !close);
        token._close = marker === 42 ? close : close && (after || !open);
        return ok(code);
      }
    }
    module.exports = attention;
  }
});

// node_modules/micromark/dist/character/ascii-alpha.js
var require_ascii_alpha = __commonJS({
  "node_modules/micromark/dist/character/ascii-alpha.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAlpha = regexCheck(/[A-Za-z]/);
    module.exports = asciiAlpha;
  }
});

// node_modules/micromark/dist/character/ascii-alphanumeric.js
var require_ascii_alphanumeric = __commonJS({
  "node_modules/micromark/dist/character/ascii-alphanumeric.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
    module.exports = asciiAlphanumeric;
  }
});

// node_modules/micromark/dist/character/ascii-atext.js
var require_ascii_atext = __commonJS({
  "node_modules/micromark/dist/character/ascii-atext.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
    module.exports = asciiAtext;
  }
});

// node_modules/micromark/dist/character/ascii-control.js
var require_ascii_control = __commonJS({
  "node_modules/micromark/dist/character/ascii-control.js"(exports, module) {
    "use strict";
    function asciiControl(code) {
      return code < 32 || code === 127;
    }
    module.exports = asciiControl;
  }
});

// node_modules/micromark/dist/tokenize/autolink.js
var require_autolink = __commonJS({
  "node_modules/micromark/dist/tokenize/autolink.js"(exports, module) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var asciiAtext = require_ascii_atext();
    var asciiControl = require_ascii_control();
    var autolink = {
      name: "autolink",
      tokenize: tokenizeAutolink
    };
    function tokenizeAutolink(effects, ok, nok) {
      var size = 1;
      return start;
      function start(code) {
        effects.enter("autolink");
        effects.enter("autolinkMarker");
        effects.consume(code);
        effects.exit("autolinkMarker");
        effects.enter("autolinkProtocol");
        return open;
      }
      function open(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          return schemeOrEmailAtext;
        }
        return asciiAtext(code) ? emailAtext(code) : nok(code);
      }
      function schemeOrEmailAtext(code) {
        return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);
      }
      function schemeInsideOrEmailAtext(code) {
        if (code === 58) {
          effects.consume(code);
          return urlInside;
        }
        if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) && size++ < 32) {
          effects.consume(code);
          return schemeInsideOrEmailAtext;
        }
        return emailAtext(code);
      }
      function urlInside(code) {
        if (code === 62) {
          effects.exit("autolinkProtocol");
          return end(code);
        }
        if (code === 32 || code === 60 || asciiControl(code)) {
          return nok(code);
        }
        effects.consume(code);
        return urlInside;
      }
      function emailAtext(code) {
        if (code === 64) {
          effects.consume(code);
          size = 0;
          return emailAtSignOrDot;
        }
        if (asciiAtext(code)) {
          effects.consume(code);
          return emailAtext;
        }
        return nok(code);
      }
      function emailAtSignOrDot(code) {
        return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);
      }
      function emailLabel(code) {
        if (code === 46) {
          effects.consume(code);
          size = 0;
          return emailAtSignOrDot;
        }
        if (code === 62) {
          effects.exit("autolinkProtocol").type = "autolinkEmail";
          return end(code);
        }
        return emailValue(code);
      }
      function emailValue(code) {
        if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
          effects.consume(code);
          return code === 45 ? emailValue : emailLabel;
        }
        return nok(code);
      }
      function end(code) {
        effects.enter("autolinkMarker");
        effects.consume(code);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok;
      }
    }
    module.exports = autolink;
  }
});

// node_modules/micromark/dist/tokenize/block-quote.js
var require_block_quote = __commonJS({
  "node_modules/micromark/dist/tokenize/block-quote.js"(exports, module) {
    "use strict";
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var blockQuote = {
      name: "blockQuote",
      tokenize: tokenizeBlockQuoteStart,
      continuation: {
        tokenize: tokenizeBlockQuoteContinuation
      },
      exit
    };
    function tokenizeBlockQuoteStart(effects, ok, nok) {
      var self2 = this;
      return start;
      function start(code) {
        if (code === 62) {
          if (!self2.containerState.open) {
            effects.enter("blockQuote", {
              _container: true
            });
            self2.containerState.open = true;
          }
          effects.enter("blockQuotePrefix");
          effects.enter("blockQuoteMarker");
          effects.consume(code);
          effects.exit("blockQuoteMarker");
          return after;
        }
        return nok(code);
      }
      function after(code) {
        if (markdownSpace(code)) {
          effects.enter("blockQuotePrefixWhitespace");
          effects.consume(code);
          effects.exit("blockQuotePrefixWhitespace");
          effects.exit("blockQuotePrefix");
          return ok;
        }
        effects.exit("blockQuotePrefix");
        return ok(code);
      }
    }
    function tokenizeBlockQuoteContinuation(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(blockQuote, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function exit(effects) {
      effects.exit("blockQuote");
    }
    module.exports = blockQuote;
  }
});

// node_modules/micromark/dist/character/ascii-punctuation.js
var require_ascii_punctuation = __commonJS({
  "node_modules/micromark/dist/character/ascii-punctuation.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
    module.exports = asciiPunctuation;
  }
});

// node_modules/micromark/dist/tokenize/character-escape.js
var require_character_escape = __commonJS({
  "node_modules/micromark/dist/tokenize/character-escape.js"(exports, module) {
    "use strict";
    var asciiPunctuation = require_ascii_punctuation();
    var characterEscape = {
      name: "characterEscape",
      tokenize: tokenizeCharacterEscape
    };
    function tokenizeCharacterEscape(effects, ok, nok) {
      return start;
      function start(code) {
        effects.enter("characterEscape");
        effects.enter("escapeMarker");
        effects.consume(code);
        effects.exit("escapeMarker");
        return open;
      }
      function open(code) {
        if (asciiPunctuation(code)) {
          effects.enter("characterEscapeValue");
          effects.consume(code);
          effects.exit("characterEscapeValue");
          effects.exit("characterEscape");
          return ok;
        }
        return nok(code);
      }
    }
    module.exports = characterEscape;
  }
});

// node_modules/parse-entities/decode-entity.browser.js
var require_decode_entity_browser = __commonJS({
  "node_modules/parse-entities/decode-entity.browser.js"(exports, module) {
    "use strict";
    var el;
    var semicolon = 59;
    module.exports = decodeEntity;
    function decodeEntity(characters) {
      var entity = "&" + characters + ";";
      var char;
      el = el || document.createElement("i");
      el.innerHTML = entity;
      char = el.textContent;
      if (char.charCodeAt(char.length - 1) === semicolon && characters !== "semi") {
        return false;
      }
      return char === entity ? false : char;
    }
  }
});

// node_modules/micromark/dist/character/ascii-digit.js
var require_ascii_digit = __commonJS({
  "node_modules/micromark/dist/character/ascii-digit.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiDigit = regexCheck(/\d/);
    module.exports = asciiDigit;
  }
});

// node_modules/micromark/dist/character/ascii-hex-digit.js
var require_ascii_hex_digit = __commonJS({
  "node_modules/micromark/dist/character/ascii-hex-digit.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
    module.exports = asciiHexDigit;
  }
});

// node_modules/micromark/dist/tokenize/character-reference.js
var require_character_reference = __commonJS({
  "node_modules/micromark/dist/tokenize/character-reference.js"(exports, module) {
    "use strict";
    var decodeEntity = require_decode_entity_browser();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var asciiDigit = require_ascii_digit();
    var asciiHexDigit = require_ascii_hex_digit();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { default: e };
    }
    var decodeEntity__default = _interopDefaultLegacy(decodeEntity);
    var characterReference = {
      name: "characterReference",
      tokenize: tokenizeCharacterReference
    };
    function tokenizeCharacterReference(effects, ok, nok) {
      var self2 = this;
      var size = 0;
      var max;
      var test;
      return start;
      function start(code) {
        effects.enter("characterReference");
        effects.enter("characterReferenceMarker");
        effects.consume(code);
        effects.exit("characterReferenceMarker");
        return open;
      }
      function open(code) {
        if (code === 35) {
          effects.enter("characterReferenceMarkerNumeric");
          effects.consume(code);
          effects.exit("characterReferenceMarkerNumeric");
          return numeric;
        }
        effects.enter("characterReferenceValue");
        max = 31;
        test = asciiAlphanumeric;
        return value(code);
      }
      function numeric(code) {
        if (code === 88 || code === 120) {
          effects.enter("characterReferenceMarkerHexadecimal");
          effects.consume(code);
          effects.exit("characterReferenceMarkerHexadecimal");
          effects.enter("characterReferenceValue");
          max = 6;
          test = asciiHexDigit;
          return value;
        }
        effects.enter("characterReferenceValue");
        max = 7;
        test = asciiDigit;
        return value(code);
      }
      function value(code) {
        var token;
        if (code === 59 && size) {
          token = effects.exit("characterReferenceValue");
          if (test === asciiAlphanumeric && !decodeEntity__default["default"](self2.sliceSerialize(token))) {
            return nok(code);
          }
          effects.enter("characterReferenceMarker");
          effects.consume(code);
          effects.exit("characterReferenceMarker");
          effects.exit("characterReference");
          return ok;
        }
        if (test(code) && size++ < max) {
          effects.consume(code);
          return value;
        }
        return nok(code);
      }
    }
    module.exports = characterReference;
  }
});

// node_modules/micromark/dist/tokenize/code-fenced.js
var require_code_fenced = __commonJS({
  "node_modules/micromark/dist/tokenize/code-fenced.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var prefixSize = require_prefix_size();
    var factorySpace = require_factory_space();
    var codeFenced = {
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
    function tokenizeCodeFenced(effects, ok, nok) {
      var self2 = this;
      var closingFenceConstruct = {
        tokenize: tokenizeClosingFence,
        partial: true
      };
      var initialPrefix = prefixSize(this.events, "linePrefix");
      var sizeOpen = 0;
      var marker;
      return start;
      function start(code) {
        effects.enter("codeFenced");
        effects.enter("codeFencedFence");
        effects.enter("codeFencedFenceSequence");
        marker = code;
        return sequenceOpen(code);
      }
      function sequenceOpen(code) {
        if (code === marker) {
          effects.consume(code);
          sizeOpen++;
          return sequenceOpen;
        }
        effects.exit("codeFencedFenceSequence");
        return sizeOpen < 3 ? nok(code) : factorySpace(effects, infoOpen, "whitespace")(code);
      }
      function infoOpen(code) {
        if (code === null || markdownLineEnding(code)) {
          return openAfter(code);
        }
        effects.enter("codeFencedFenceInfo");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return info(code);
      }
      function info(code) {
        if (code === null || markdownLineEndingOrSpace(code)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceInfo");
          return factorySpace(effects, infoAfter, "whitespace")(code);
        }
        if (code === 96 && code === marker)
          return nok(code);
        effects.consume(code);
        return info;
      }
      function infoAfter(code) {
        if (code === null || markdownLineEnding(code)) {
          return openAfter(code);
        }
        effects.enter("codeFencedFenceMeta");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return meta(code);
      }
      function meta(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceMeta");
          return openAfter(code);
        }
        if (code === 96 && code === marker)
          return nok(code);
        effects.consume(code);
        return meta;
      }
      function openAfter(code) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok(code) : content(code);
      }
      function content(code) {
        if (code === null) {
          return after(code);
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return effects.attempt(
            closingFenceConstruct,
            after,
            initialPrefix ? factorySpace(effects, content, "linePrefix", initialPrefix + 1) : content
          );
        }
        effects.enter("codeFlowValue");
        return contentContinue(code);
      }
      function contentContinue(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("codeFlowValue");
          return content(code);
        }
        effects.consume(code);
        return contentContinue;
      }
      function after(code) {
        effects.exit("codeFenced");
        return ok(code);
      }
      function tokenizeClosingFence(effects2, ok2, nok2) {
        var size = 0;
        return factorySpace(
          effects2,
          closingSequenceStart,
          "linePrefix",
          this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
        function closingSequenceStart(code) {
          effects2.enter("codeFencedFence");
          effects2.enter("codeFencedFenceSequence");
          return closingSequence(code);
        }
        function closingSequence(code) {
          if (code === marker) {
            effects2.consume(code);
            size++;
            return closingSequence;
          }
          if (size < sizeOpen)
            return nok2(code);
          effects2.exit("codeFencedFenceSequence");
          return factorySpace(effects2, closingSequenceEnd, "whitespace")(code);
        }
        function closingSequenceEnd(code) {
          if (code === null || markdownLineEnding(code)) {
            effects2.exit("codeFencedFence");
            return ok2(code);
          }
          return nok2(code);
        }
      }
    }
    module.exports = codeFenced;
  }
});

// node_modules/micromark/dist/tokenize/code-indented.js
var require_code_indented = __commonJS({
  "node_modules/micromark/dist/tokenize/code-indented.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var chunkedSplice = require_chunked_splice();
    var prefixSize = require_prefix_size();
    var factorySpace = require_factory_space();
    var codeIndented = {
      name: "codeIndented",
      tokenize: tokenizeCodeIndented,
      resolve: resolveCodeIndented
    };
    var indentedContentConstruct = {
      tokenize: tokenizeIndentedContent,
      partial: true
    };
    function resolveCodeIndented(events, context) {
      var code = {
        type: "codeIndented",
        start: events[0][1].start,
        end: events[events.length - 1][1].end
      };
      chunkedSplice(events, 0, 0, [["enter", code, context]]);
      chunkedSplice(events, events.length, 0, [["exit", code, context]]);
      return events;
    }
    function tokenizeCodeIndented(effects, ok, nok) {
      return effects.attempt(indentedContentConstruct, afterPrefix, nok);
      function afterPrefix(code) {
        if (code === null) {
          return ok(code);
        }
        if (markdownLineEnding(code)) {
          return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code);
        }
        effects.enter("codeFlowValue");
        return content(code);
      }
      function content(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("codeFlowValue");
          return afterPrefix(code);
        }
        effects.consume(code);
        return content;
      }
    }
    function tokenizeIndentedContent(effects, ok, nok) {
      var self2 = this;
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
      function afterPrefix(code) {
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
        }
        return prefixSize(self2.events, "linePrefix") < 4 ? nok(code) : ok(code);
      }
    }
    module.exports = codeIndented;
  }
});

// node_modules/micromark/dist/tokenize/code-text.js
var require_code_text = __commonJS({
  "node_modules/micromark/dist/tokenize/code-text.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var codeText = {
      name: "codeText",
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous
    };
    function resolveCodeText(events) {
      var tailExitIndex = events.length - 4;
      var headEnterIndex = 3;
      var index;
      var enter;
      if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
        index = headEnterIndex;
        while (++index < tailExitIndex) {
          if (events[index][1].type === "codeTextData") {
            events[tailExitIndex][1].type = events[headEnterIndex][1].type = "codeTextPadding";
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break;
          }
        }
      }
      index = headEnterIndex - 1;
      tailExitIndex++;
      while (++index <= tailExitIndex) {
        if (enter === void 0) {
          if (index !== tailExitIndex && events[index][1].type !== "lineEnding") {
            enter = index;
          }
        } else if (index === tailExitIndex || events[index][1].type === "lineEnding") {
          events[enter][1].type = "codeTextData";
          if (index !== enter + 2) {
            events[enter][1].end = events[index - 1][1].end;
            events.splice(enter + 2, index - enter - 2);
            tailExitIndex -= index - enter - 2;
            index = enter + 2;
          }
          enter = void 0;
        }
      }
      return events;
    }
    function previous(code) {
      return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
    }
    function tokenizeCodeText(effects, ok, nok) {
      var sizeOpen = 0;
      var size;
      var token;
      return start;
      function start(code) {
        effects.enter("codeText");
        effects.enter("codeTextSequence");
        return openingSequence(code);
      }
      function openingSequence(code) {
        if (code === 96) {
          effects.consume(code);
          sizeOpen++;
          return openingSequence;
        }
        effects.exit("codeTextSequence");
        return gap(code);
      }
      function gap(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 96) {
          token = effects.enter("codeTextSequence");
          size = 0;
          return closingSequence(code);
        }
        if (code === 32) {
          effects.enter("space");
          effects.consume(code);
          effects.exit("space");
          return gap;
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return gap;
        }
        effects.enter("codeTextData");
        return data(code);
      }
      function data(code) {
        if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {
          effects.exit("codeTextData");
          return gap(code);
        }
        effects.consume(code);
        return data;
      }
      function closingSequence(code) {
        if (code === 96) {
          effects.consume(code);
          size++;
          return closingSequence;
        }
        if (size === sizeOpen) {
          effects.exit("codeTextSequence");
          effects.exit("codeText");
          return ok(code);
        }
        token.type = "codeTextData";
        return data(code);
      }
    }
    module.exports = codeText;
  }
});

// node_modules/micromark/dist/tokenize/factory-destination.js
var require_factory_destination = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-destination.js"(exports, module) {
    "use strict";
    var asciiControl = require_ascii_control();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownLineEnding = require_markdown_line_ending();
    function destinationFactory(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
      var limit = max || Infinity;
      var balance = 0;
      return start;
      function start(code) {
        if (code === 60) {
          effects.enter(type);
          effects.enter(literalType);
          effects.enter(literalMarkerType);
          effects.consume(code);
          effects.exit(literalMarkerType);
          return destinationEnclosedBefore;
        }
        if (asciiControl(code) || code === 41) {
          return nok(code);
        }
        effects.enter(type);
        effects.enter(rawType);
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationRaw(code);
      }
      function destinationEnclosedBefore(code) {
        if (code === 62) {
          effects.enter(literalMarkerType);
          effects.consume(code);
          effects.exit(literalMarkerType);
          effects.exit(literalType);
          effects.exit(type);
          return ok;
        }
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationEnclosed(code);
      }
      function destinationEnclosed(code) {
        if (code === 62) {
          effects.exit("chunkString");
          effects.exit(stringType);
          return destinationEnclosedBefore(code);
        }
        if (code === null || code === 60 || markdownLineEnding(code)) {
          return nok(code);
        }
        effects.consume(code);
        return code === 92 ? destinationEnclosedEscape : destinationEnclosed;
      }
      function destinationEnclosedEscape(code) {
        if (code === 60 || code === 62 || code === 92) {
          effects.consume(code);
          return destinationEnclosed;
        }
        return destinationEnclosed(code);
      }
      function destinationRaw(code) {
        if (code === 40) {
          if (++balance > limit)
            return nok(code);
          effects.consume(code);
          return destinationRaw;
        }
        if (code === 41) {
          if (!balance--) {
            effects.exit("chunkString");
            effects.exit(stringType);
            effects.exit(rawType);
            effects.exit(type);
            return ok(code);
          }
          effects.consume(code);
          return destinationRaw;
        }
        if (code === null || markdownLineEndingOrSpace(code)) {
          if (balance)
            return nok(code);
          effects.exit("chunkString");
          effects.exit(stringType);
          effects.exit(rawType);
          effects.exit(type);
          return ok(code);
        }
        if (asciiControl(code))
          return nok(code);
        effects.consume(code);
        return code === 92 ? destinationRawEscape : destinationRaw;
      }
      function destinationRawEscape(code) {
        if (code === 40 || code === 41 || code === 92) {
          effects.consume(code);
          return destinationRaw;
        }
        return destinationRaw(code);
      }
    }
    module.exports = destinationFactory;
  }
});

// node_modules/micromark/dist/tokenize/factory-label.js
var require_factory_label = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-label.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    function labelFactory(effects, ok, nok, type, markerType, stringType) {
      var self2 = this;
      var size = 0;
      var data;
      return start;
      function start(code) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        effects.enter(stringType);
        return atBreak;
      }
      function atBreak(code) {
        if (code === null || code === 91 || code === 93 && !data || code === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
          return nok(code);
        }
        if (code === 93) {
          effects.exit(stringType);
          effects.enter(markerType);
          effects.consume(code);
          effects.exit(markerType);
          effects.exit(type);
          return ok;
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return atBreak;
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return label(code);
      }
      function label(code) {
        if (code === null || code === 91 || code === 93 || markdownLineEnding(code) || size++ > 999) {
          effects.exit("chunkString");
          return atBreak(code);
        }
        effects.consume(code);
        data = data || !markdownSpace(code);
        return code === 92 ? labelEscape : label;
      }
      function labelEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
          effects.consume(code);
          size++;
          return label;
        }
        return label(code);
      }
    }
    module.exports = labelFactory;
  }
});

// node_modules/micromark/dist/tokenize/factory-whitespace.js
var require_factory_whitespace = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-whitespace.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    function whitespaceFactory(effects, ok) {
      var seen;
      return start;
      function start(code) {
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          seen = true;
          return start;
        }
        if (markdownSpace(code)) {
          return factorySpace(
            effects,
            start,
            seen ? "linePrefix" : "lineSuffix"
          )(code);
        }
        return ok(code);
      }
    }
    module.exports = whitespaceFactory;
  }
});

// node_modules/micromark/dist/tokenize/factory-title.js
var require_factory_title = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-title.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    function titleFactory(effects, ok, nok, type, markerType, stringType) {
      var marker;
      return start;
      function start(code) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        marker = code === 40 ? 41 : code;
        return atFirstTitleBreak;
      }
      function atFirstTitleBreak(code) {
        if (code === marker) {
          effects.enter(markerType);
          effects.consume(code);
          effects.exit(markerType);
          effects.exit(type);
          return ok;
        }
        effects.enter(stringType);
        return atTitleBreak(code);
      }
      function atTitleBreak(code) {
        if (code === marker) {
          effects.exit(stringType);
          return atFirstTitleBreak(marker);
        }
        if (code === null) {
          return nok(code);
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return factorySpace(effects, atTitleBreak, "linePrefix");
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return title(code);
      }
      function title(code) {
        if (code === marker || code === null || markdownLineEnding(code)) {
          effects.exit("chunkString");
          return atTitleBreak(code);
        }
        effects.consume(code);
        return code === 92 ? titleEscape : title;
      }
      function titleEscape(code) {
        if (code === marker || code === 92) {
          effects.consume(code);
          return title;
        }
        return title(code);
      }
    }
    module.exports = titleFactory;
  }
});

// node_modules/micromark/dist/tokenize/definition.js
var require_definition = __commonJS({
  "node_modules/micromark/dist/tokenize/definition.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var normalizeIdentifier = require_normalize_identifier();
    var factoryDestination = require_factory_destination();
    var factoryLabel = require_factory_label();
    var factorySpace = require_factory_space();
    var factoryWhitespace = require_factory_whitespace();
    var factoryTitle = require_factory_title();
    var definition = {
      name: "definition",
      tokenize: tokenizeDefinition
    };
    var titleConstruct = {
      tokenize: tokenizeTitle,
      partial: true
    };
    function tokenizeDefinition(effects, ok, nok) {
      var self2 = this;
      var identifier;
      return start;
      function start(code) {
        effects.enter("definition");
        return factoryLabel.call(
          self2,
          effects,
          labelAfter,
          nok,
          "definitionLabel",
          "definitionLabelMarker",
          "definitionLabelString"
        )(code);
      }
      function labelAfter(code) {
        identifier = normalizeIdentifier(
          self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
        );
        if (code === 58) {
          effects.enter("definitionMarker");
          effects.consume(code);
          effects.exit("definitionMarker");
          return factoryWhitespace(
            effects,
            factoryDestination(
              effects,
              effects.attempt(
                titleConstruct,
                factorySpace(effects, after, "whitespace"),
                factorySpace(effects, after, "whitespace")
              ),
              nok,
              "definitionDestination",
              "definitionDestinationLiteral",
              "definitionDestinationLiteralMarker",
              "definitionDestinationRaw",
              "definitionDestinationString"
            )
          );
        }
        return nok(code);
      }
      function after(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("definition");
          if (self2.parser.defined.indexOf(identifier) < 0) {
            self2.parser.defined.push(identifier);
          }
          return ok(code);
        }
        return nok(code);
      }
    }
    function tokenizeTitle(effects, ok, nok) {
      return start;
      function start(code) {
        return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);
      }
      function before(code) {
        if (code === 34 || code === 39 || code === 40) {
          return factoryTitle(
            effects,
            factorySpace(effects, after, "whitespace"),
            nok,
            "definitionTitle",
            "definitionTitleMarker",
            "definitionTitleString"
          )(code);
        }
        return nok(code);
      }
      function after(code) {
        return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
      }
    }
    module.exports = definition;
  }
});

// node_modules/micromark/dist/tokenize/hard-break-escape.js
var require_hard_break_escape = __commonJS({
  "node_modules/micromark/dist/tokenize/hard-break-escape.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var hardBreakEscape = {
      name: "hardBreakEscape",
      tokenize: tokenizeHardBreakEscape
    };
    function tokenizeHardBreakEscape(effects, ok, nok) {
      return start;
      function start(code) {
        effects.enter("hardBreakEscape");
        effects.enter("escapeMarker");
        effects.consume(code);
        return open;
      }
      function open(code) {
        if (markdownLineEnding(code)) {
          effects.exit("escapeMarker");
          effects.exit("hardBreakEscape");
          return ok(code);
        }
        return nok(code);
      }
    }
    module.exports = hardBreakEscape;
  }
});

// node_modules/micromark/dist/tokenize/heading-atx.js
var require_heading_atx = __commonJS({
  "node_modules/micromark/dist/tokenize/heading-atx.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var chunkedSplice = require_chunked_splice();
    var factorySpace = require_factory_space();
    var headingAtx = {
      name: "headingAtx",
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
    function resolveHeadingAtx(events, context) {
      var contentEnd = events.length - 2;
      var contentStart = 3;
      var content;
      var text;
      if (events[contentStart][1].type === "whitespace") {
        contentStart += 2;
      }
      if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
        contentEnd -= 2;
      }
      if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
        contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
      }
      if (contentEnd > contentStart) {
        content = {
          type: "atxHeadingText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        text = {
          type: "chunkText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end,
          contentType: "text"
        };
        chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [
          ["enter", content, context],
          ["enter", text, context],
          ["exit", text, context],
          ["exit", content, context]
        ]);
      }
      return events;
    }
    function tokenizeHeadingAtx(effects, ok, nok) {
      var self2 = this;
      var size = 0;
      return start;
      function start(code) {
        effects.enter("atxHeading");
        effects.enter("atxHeadingSequence");
        return fenceOpenInside(code);
      }
      function fenceOpenInside(code) {
        if (code === 35 && size++ < 6) {
          effects.consume(code);
          return fenceOpenInside;
        }
        if (code === null || markdownLineEndingOrSpace(code)) {
          effects.exit("atxHeadingSequence");
          return self2.interrupt ? ok(code) : headingBreak(code);
        }
        return nok(code);
      }
      function headingBreak(code) {
        if (code === 35) {
          effects.enter("atxHeadingSequence");
          return sequence(code);
        }
        if (code === null || markdownLineEnding(code)) {
          effects.exit("atxHeading");
          return ok(code);
        }
        if (markdownSpace(code)) {
          return factorySpace(effects, headingBreak, "whitespace")(code);
        }
        effects.enter("atxHeadingText");
        return data(code);
      }
      function sequence(code) {
        if (code === 35) {
          effects.consume(code);
          return sequence;
        }
        effects.exit("atxHeadingSequence");
        return headingBreak(code);
      }
      function data(code) {
        if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
          effects.exit("atxHeadingText");
          return headingBreak(code);
        }
        effects.consume(code);
        return data;
      }
    }
    module.exports = headingAtx;
  }
});

// node_modules/micromark/dist/constant/html-block-names.js
var require_html_block_names = __commonJS({
  "node_modules/micromark/dist/constant/html-block-names.js"(exports, module) {
    "use strict";
    var basics = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    module.exports = basics;
  }
});

// node_modules/micromark/dist/constant/html-raw-names.js
var require_html_raw_names = __commonJS({
  "node_modules/micromark/dist/constant/html-raw-names.js"(exports, module) {
    "use strict";
    var raws = ["pre", "script", "style", "textarea"];
    module.exports = raws;
  }
});

// node_modules/micromark/dist/tokenize/html-flow.js
var require_html_flow = __commonJS({
  "node_modules/micromark/dist/tokenize/html-flow.js"(exports, module) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var fromCharCode = require_from_char_code();
    var htmlBlockNames = require_html_block_names();
    var htmlRawNames = require_html_raw_names();
    var partialBlankLine = require_partial_blank_line();
    var htmlFlow = {
      name: "htmlFlow",
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    var nextBlankConstruct = {
      tokenize: tokenizeNextBlank,
      partial: true
    };
    function resolveToHtmlFlow(events) {
      var index = events.length;
      while (index--) {
        if (events[index][0] === "enter" && events[index][1].type === "htmlFlow") {
          break;
        }
      }
      if (index > 1 && events[index - 2][1].type === "linePrefix") {
        events[index][1].start = events[index - 2][1].start;
        events[index + 1][1].start = events[index - 2][1].start;
        events.splice(index - 2, 2);
      }
      return events;
    }
    function tokenizeHtmlFlow(effects, ok, nok) {
      var self2 = this;
      var kind;
      var startTag;
      var buffer;
      var index;
      var marker;
      return start;
      function start(code) {
        effects.enter("htmlFlow");
        effects.enter("htmlFlowData");
        effects.consume(code);
        return open;
      }
      function open(code) {
        if (code === 33) {
          effects.consume(code);
          return declarationStart;
        }
        if (code === 47) {
          effects.consume(code);
          return tagCloseStart;
        }
        if (code === 63) {
          effects.consume(code);
          kind = 3;
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          buffer = fromCharCode(code);
          startTag = true;
          return tagName;
        }
        return nok(code);
      }
      function declarationStart(code) {
        if (code === 45) {
          effects.consume(code);
          kind = 2;
          return commentOpenInside;
        }
        if (code === 91) {
          effects.consume(code);
          kind = 5;
          buffer = "CDATA[";
          index = 0;
          return cdataOpenInside;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          kind = 4;
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        return nok(code);
      }
      function commentOpenInside(code) {
        if (code === 45) {
          effects.consume(code);
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        return nok(code);
      }
      function cdataOpenInside(code) {
        if (code === buffer.charCodeAt(index++)) {
          effects.consume(code);
          return index === buffer.length ? self2.interrupt ? ok : continuation : cdataOpenInside;
        }
        return nok(code);
      }
      function tagCloseStart(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          buffer = fromCharCode(code);
          return tagName;
        }
        return nok(code);
      }
      function tagName(code) {
        if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
          if (code !== 47 && startTag && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
            kind = 1;
            return self2.interrupt ? ok(code) : continuation(code);
          }
          if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {
            kind = 6;
            if (code === 47) {
              effects.consume(code);
              return basicSelfClosing;
            }
            return self2.interrupt ? ok(code) : continuation(code);
          }
          kind = 7;
          return self2.interrupt ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);
        }
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          buffer += fromCharCode(code);
          return tagName;
        }
        return nok(code);
      }
      function basicSelfClosing(code) {
        if (code === 62) {
          effects.consume(code);
          return self2.interrupt ? ok : continuation;
        }
        return nok(code);
      }
      function completeClosingTagAfter(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeClosingTagAfter;
        }
        return completeEnd(code);
      }
      function completeAttributeNameBefore(code) {
        if (code === 47) {
          effects.consume(code);
          return completeEnd;
        }
        if (code === 58 || code === 95 || asciiAlpha(code)) {
          effects.consume(code);
          return completeAttributeName;
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeNameBefore;
        }
        return completeEnd(code);
      }
      function completeAttributeName(code) {
        if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return completeAttributeName;
        }
        return completeAttributeNameAfter(code);
      }
      function completeAttributeNameAfter(code) {
        if (code === 61) {
          effects.consume(code);
          return completeAttributeValueBefore;
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeNameAfter;
        }
        return completeAttributeNameBefore(code);
      }
      function completeAttributeValueBefore(code) {
        if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
          return nok(code);
        }
        if (code === 34 || code === 39) {
          effects.consume(code);
          marker = code;
          return completeAttributeValueQuoted;
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeValueBefore;
        }
        marker = void 0;
        return completeAttributeValueUnquoted(code);
      }
      function completeAttributeValueQuoted(code) {
        if (code === marker) {
          effects.consume(code);
          return completeAttributeValueQuotedAfter;
        }
        if (code === null || markdownLineEnding(code)) {
          return nok(code);
        }
        effects.consume(code);
        return completeAttributeValueQuoted;
      }
      function completeAttributeValueUnquoted(code) {
        if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace(code)) {
          return completeAttributeNameAfter(code);
        }
        effects.consume(code);
        return completeAttributeValueUnquoted;
      }
      function completeAttributeValueQuotedAfter(code) {
        if (code === 47 || code === 62 || markdownSpace(code)) {
          return completeAttributeNameBefore(code);
        }
        return nok(code);
      }
      function completeEnd(code) {
        if (code === 62) {
          effects.consume(code);
          return completeAfter;
        }
        return nok(code);
      }
      function completeAfter(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAfter;
        }
        return code === null || markdownLineEnding(code) ? continuation(code) : nok(code);
      }
      function continuation(code) {
        if (code === 45 && kind === 2) {
          effects.consume(code);
          return continuationCommentInside;
        }
        if (code === 60 && kind === 1) {
          effects.consume(code);
          return continuationRawTagOpen;
        }
        if (code === 62 && kind === 4) {
          effects.consume(code);
          return continuationClose;
        }
        if (code === 63 && kind === 3) {
          effects.consume(code);
          return continuationDeclarationInside;
        }
        if (code === 93 && kind === 5) {
          effects.consume(code);
          return continuationCharacterDataInside;
        }
        if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
          return effects.check(
            nextBlankConstruct,
            continuationClose,
            continuationAtLineEnding
          )(code);
        }
        if (code === null || markdownLineEnding(code)) {
          return continuationAtLineEnding(code);
        }
        effects.consume(code);
        return continuation;
      }
      function continuationAtLineEnding(code) {
        effects.exit("htmlFlowData");
        return htmlContinueStart(code);
      }
      function htmlContinueStart(code) {
        if (code === null) {
          return done(code);
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return htmlContinueStart;
        }
        effects.enter("htmlFlowData");
        return continuation(code);
      }
      function continuationCommentInside(code) {
        if (code === 45) {
          effects.consume(code);
          return continuationDeclarationInside;
        }
        return continuation(code);
      }
      function continuationRawTagOpen(code) {
        if (code === 47) {
          effects.consume(code);
          buffer = "";
          return continuationRawEndTag;
        }
        return continuation(code);
      }
      function continuationRawEndTag(code) {
        if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
          effects.consume(code);
          return continuationClose;
        }
        if (asciiAlpha(code) && buffer.length < 8) {
          effects.consume(code);
          buffer += fromCharCode(code);
          return continuationRawEndTag;
        }
        return continuation(code);
      }
      function continuationCharacterDataInside(code) {
        if (code === 93) {
          effects.consume(code);
          return continuationDeclarationInside;
        }
        return continuation(code);
      }
      function continuationDeclarationInside(code) {
        if (code === 62) {
          effects.consume(code);
          return continuationClose;
        }
        return continuation(code);
      }
      function continuationClose(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("htmlFlowData");
          return done(code);
        }
        effects.consume(code);
        return continuationClose;
      }
      function done(code) {
        effects.exit("htmlFlow");
        return ok(code);
      }
    }
    function tokenizeNextBlank(effects, ok, nok) {
      return start;
      function start(code) {
        effects.exit("htmlFlowData");
        effects.enter("lineEndingBlank");
        effects.consume(code);
        effects.exit("lineEndingBlank");
        return effects.attempt(partialBlankLine, ok, nok);
      }
    }
    module.exports = htmlFlow;
  }
});

// node_modules/micromark/dist/tokenize/html-text.js
var require_html_text = __commonJS({
  "node_modules/micromark/dist/tokenize/html-text.js"(exports, module) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var htmlText = {
      name: "htmlText",
      tokenize: tokenizeHtmlText
    };
    function tokenizeHtmlText(effects, ok, nok) {
      var self2 = this;
      var marker;
      var buffer;
      var index;
      var returnState;
      return start;
      function start(code) {
        effects.enter("htmlText");
        effects.enter("htmlTextData");
        effects.consume(code);
        return open;
      }
      function open(code) {
        if (code === 33) {
          effects.consume(code);
          return declarationOpen;
        }
        if (code === 47) {
          effects.consume(code);
          return tagCloseStart;
        }
        if (code === 63) {
          effects.consume(code);
          return instruction;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          return tagOpen;
        }
        return nok(code);
      }
      function declarationOpen(code) {
        if (code === 45) {
          effects.consume(code);
          return commentOpen;
        }
        if (code === 91) {
          effects.consume(code);
          buffer = "CDATA[";
          index = 0;
          return cdataOpen;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          return declaration;
        }
        return nok(code);
      }
      function commentOpen(code) {
        if (code === 45) {
          effects.consume(code);
          return commentStart;
        }
        return nok(code);
      }
      function commentStart(code) {
        if (code === null || code === 62) {
          return nok(code);
        }
        if (code === 45) {
          effects.consume(code);
          return commentStartDash;
        }
        return comment(code);
      }
      function commentStartDash(code) {
        if (code === null || code === 62) {
          return nok(code);
        }
        return comment(code);
      }
      function comment(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 45) {
          effects.consume(code);
          return commentClose;
        }
        if (markdownLineEnding(code)) {
          returnState = comment;
          return atLineEnding(code);
        }
        effects.consume(code);
        return comment;
      }
      function commentClose(code) {
        if (code === 45) {
          effects.consume(code);
          return end;
        }
        return comment(code);
      }
      function cdataOpen(code) {
        if (code === buffer.charCodeAt(index++)) {
          effects.consume(code);
          return index === buffer.length ? cdata : cdataOpen;
        }
        return nok(code);
      }
      function cdata(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 93) {
          effects.consume(code);
          return cdataClose;
        }
        if (markdownLineEnding(code)) {
          returnState = cdata;
          return atLineEnding(code);
        }
        effects.consume(code);
        return cdata;
      }
      function cdataClose(code) {
        if (code === 93) {
          effects.consume(code);
          return cdataEnd;
        }
        return cdata(code);
      }
      function cdataEnd(code) {
        if (code === 62) {
          return end(code);
        }
        if (code === 93) {
          effects.consume(code);
          return cdataEnd;
        }
        return cdata(code);
      }
      function declaration(code) {
        if (code === null || code === 62) {
          return end(code);
        }
        if (markdownLineEnding(code)) {
          returnState = declaration;
          return atLineEnding(code);
        }
        effects.consume(code);
        return declaration;
      }
      function instruction(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 63) {
          effects.consume(code);
          return instructionClose;
        }
        if (markdownLineEnding(code)) {
          returnState = instruction;
          return atLineEnding(code);
        }
        effects.consume(code);
        return instruction;
      }
      function instructionClose(code) {
        return code === 62 ? end(code) : instruction(code);
      }
      function tagCloseStart(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          return tagClose;
        }
        return nok(code);
      }
      function tagClose(code) {
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagClose;
        }
        return tagCloseBetween(code);
      }
      function tagCloseBetween(code) {
        if (markdownLineEnding(code)) {
          returnState = tagCloseBetween;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagCloseBetween;
        }
        return end(code);
      }
      function tagOpen(code) {
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagOpen;
        }
        if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code);
        }
        return nok(code);
      }
      function tagOpenBetween(code) {
        if (code === 47) {
          effects.consume(code);
          return end;
        }
        if (code === 58 || code === 95 || asciiAlpha(code)) {
          effects.consume(code);
          return tagOpenAttributeName;
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenBetween;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenBetween;
        }
        return end(code);
      }
      function tagOpenAttributeName(code) {
        if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagOpenAttributeName;
        }
        return tagOpenAttributeNameAfter(code);
      }
      function tagOpenAttributeNameAfter(code) {
        if (code === 61) {
          effects.consume(code);
          return tagOpenAttributeValueBefore;
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeNameAfter;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenAttributeNameAfter;
        }
        return tagOpenBetween(code);
      }
      function tagOpenAttributeValueBefore(code) {
        if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
          return nok(code);
        }
        if (code === 34 || code === 39) {
          effects.consume(code);
          marker = code;
          return tagOpenAttributeValueQuoted;
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeValueBefore;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenAttributeValueBefore;
        }
        effects.consume(code);
        marker = void 0;
        return tagOpenAttributeValueUnquoted;
      }
      function tagOpenAttributeValueQuoted(code) {
        if (code === marker) {
          effects.consume(code);
          return tagOpenAttributeValueQuotedAfter;
        }
        if (code === null) {
          return nok(code);
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeValueQuoted;
          return atLineEnding(code);
        }
        effects.consume(code);
        return tagOpenAttributeValueQuoted;
      }
      function tagOpenAttributeValueQuotedAfter(code) {
        if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code);
        }
        return nok(code);
      }
      function tagOpenAttributeValueUnquoted(code) {
        if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {
          return nok(code);
        }
        if (code === 62 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code);
        }
        effects.consume(code);
        return tagOpenAttributeValueUnquoted;
      }
      function atLineEnding(code) {
        effects.exit("htmlTextData");
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(
          effects,
          afterPrefix,
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
      }
      function afterPrefix(code) {
        effects.enter("htmlTextData");
        return returnState(code);
      }
      function end(code) {
        if (code === 62) {
          effects.consume(code);
          effects.exit("htmlTextData");
          effects.exit("htmlText");
          return ok;
        }
        return nok(code);
      }
    }
    module.exports = htmlText;
  }
});

// node_modules/micromark/dist/tokenize/label-end.js
var require_label_end = __commonJS({
  "node_modules/micromark/dist/tokenize/label-end.js"(exports, module) {
    "use strict";
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var normalizeIdentifier = require_normalize_identifier();
    var resolveAll = require_resolve_all();
    var shallow = require_shallow();
    var factoryDestination = require_factory_destination();
    var factoryLabel = require_factory_label();
    var factoryTitle = require_factory_title();
    var factoryWhitespace = require_factory_whitespace();
    var labelEnd = {
      name: "labelEnd",
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    var resourceConstruct = {
      tokenize: tokenizeResource
    };
    var fullReferenceConstruct = {
      tokenize: tokenizeFullReference
    };
    var collapsedReferenceConstruct = {
      tokenize: tokenizeCollapsedReference
    };
    function resolveAllLabelEnd(events) {
      var index = -1;
      var token;
      while (++index < events.length) {
        token = events[index][1];
        if (!token._used && (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd")) {
          events.splice(index + 1, token.type === "labelImage" ? 4 : 2);
          token.type = "data";
          index++;
        }
      }
      return events;
    }
    function resolveToLabelEnd(events, context) {
      var index = events.length;
      var offset = 0;
      var group;
      var label;
      var text;
      var token;
      var open;
      var close;
      var media;
      while (index--) {
        token = events[index][1];
        if (open) {
          if (token.type === "link" || token.type === "labelLink" && token._inactive) {
            break;
          }
          if (events[index][0] === "enter" && token.type === "labelLink") {
            token._inactive = true;
          }
        } else if (close) {
          if (events[index][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
            open = index;
            if (token.type !== "labelLink") {
              offset = 2;
              break;
            }
          }
        } else if (token.type === "labelEnd") {
          close = index;
        }
      }
      group = {
        type: events[open][1].type === "labelLink" ? "link" : "image",
        start: shallow(events[open][1].start),
        end: shallow(events[events.length - 1][1].end)
      };
      label = {
        type: "label",
        start: shallow(events[open][1].start),
        end: shallow(events[close][1].end)
      };
      text = {
        type: "labelText",
        start: shallow(events[open + offset + 2][1].end),
        end: shallow(events[close - 2][1].start)
      };
      media = [
        ["enter", group, context],
        ["enter", label, context]
      ];
      media = chunkedPush(media, events.slice(open + 1, open + offset + 3));
      media = chunkedPush(media, [["enter", text, context]]);
      media = chunkedPush(
        media,
        resolveAll(
          context.parser.constructs.insideSpan.null,
          events.slice(open + offset + 4, close - 3),
          context
        )
      );
      media = chunkedPush(media, [
        ["exit", text, context],
        events[close - 2],
        events[close - 1],
        ["exit", label, context]
      ]);
      media = chunkedPush(media, events.slice(close + 1));
      media = chunkedPush(media, [["exit", group, context]]);
      chunkedSplice(events, open, events.length, media);
      return events;
    }
    function tokenizeLabelEnd(effects, ok, nok) {
      var self2 = this;
      var index = self2.events.length;
      var labelStart;
      var defined;
      while (index--) {
        if ((self2.events[index][1].type === "labelImage" || self2.events[index][1].type === "labelLink") && !self2.events[index][1]._balanced) {
          labelStart = self2.events[index][1];
          break;
        }
      }
      return start;
      function start(code) {
        if (!labelStart) {
          return nok(code);
        }
        if (labelStart._inactive)
          return balanced(code);
        defined = self2.parser.defined.indexOf(
          normalizeIdentifier(
            self2.sliceSerialize({
              start: labelStart.end,
              end: self2.now()
            })
          )
        ) > -1;
        effects.enter("labelEnd");
        effects.enter("labelMarker");
        effects.consume(code);
        effects.exit("labelMarker");
        effects.exit("labelEnd");
        return afterLabelEnd;
      }
      function afterLabelEnd(code) {
        if (code === 40) {
          return effects.attempt(
            resourceConstruct,
            ok,
            defined ? ok : balanced
          )(code);
        }
        if (code === 91) {
          return effects.attempt(
            fullReferenceConstruct,
            ok,
            defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced
          )(code);
        }
        return defined ? ok(code) : balanced(code);
      }
      function balanced(code) {
        labelStart._balanced = true;
        return nok(code);
      }
    }
    function tokenizeResource(effects, ok, nok) {
      return start;
      function start(code) {
        effects.enter("resource");
        effects.enter("resourceMarker");
        effects.consume(code);
        effects.exit("resourceMarker");
        return factoryWhitespace(effects, open);
      }
      function open(code) {
        if (code === 41) {
          return end(code);
        }
        return factoryDestination(
          effects,
          destinationAfter,
          nok,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          3
        )(code);
      }
      function destinationAfter(code) {
        return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end(code);
      }
      function between(code) {
        if (code === 34 || code === 39 || code === 40) {
          return factoryTitle(
            effects,
            factoryWhitespace(effects, end),
            nok,
            "resourceTitle",
            "resourceTitleMarker",
            "resourceTitleString"
          )(code);
        }
        return end(code);
      }
      function end(code) {
        if (code === 41) {
          effects.enter("resourceMarker");
          effects.consume(code);
          effects.exit("resourceMarker");
          effects.exit("resource");
          return ok;
        }
        return nok(code);
      }
    }
    function tokenizeFullReference(effects, ok, nok) {
      var self2 = this;
      return start;
      function start(code) {
        return factoryLabel.call(
          self2,
          effects,
          afterLabel,
          nok,
          "reference",
          "referenceMarker",
          "referenceString"
        )(code);
      }
      function afterLabel(code) {
        return self2.parser.defined.indexOf(
          normalizeIdentifier(
            self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
          )
        ) < 0 ? nok(code) : ok(code);
      }
    }
    function tokenizeCollapsedReference(effects, ok, nok) {
      return start;
      function start(code) {
        effects.enter("reference");
        effects.enter("referenceMarker");
        effects.consume(code);
        effects.exit("referenceMarker");
        return open;
      }
      function open(code) {
        if (code === 93) {
          effects.enter("referenceMarker");
          effects.consume(code);
          effects.exit("referenceMarker");
          effects.exit("reference");
          return ok;
        }
        return nok(code);
      }
    }
    module.exports = labelEnd;
  }
});

// node_modules/micromark/dist/tokenize/label-start-image.js
var require_label_start_image = __commonJS({
  "node_modules/micromark/dist/tokenize/label-start-image.js"(exports, module) {
    "use strict";
    var labelEnd = require_label_end();
    var labelStartImage = {
      name: "labelStartImage",
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartImage(effects, ok, nok) {
      var self2 = this;
      return start;
      function start(code) {
        effects.enter("labelImage");
        effects.enter("labelImageMarker");
        effects.consume(code);
        effects.exit("labelImageMarker");
        return open;
      }
      function open(code) {
        if (code === 91) {
          effects.enter("labelMarker");
          effects.consume(code);
          effects.exit("labelMarker");
          effects.exit("labelImage");
          return after;
        }
        return nok(code);
      }
      function after(code) {
        return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);
      }
    }
    module.exports = labelStartImage;
  }
});

// node_modules/micromark/dist/tokenize/label-start-link.js
var require_label_start_link = __commonJS({
  "node_modules/micromark/dist/tokenize/label-start-link.js"(exports, module) {
    "use strict";
    var labelEnd = require_label_end();
    var labelStartLink = {
      name: "labelStartLink",
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartLink(effects, ok, nok) {
      var self2 = this;
      return start;
      function start(code) {
        effects.enter("labelLink");
        effects.enter("labelMarker");
        effects.consume(code);
        effects.exit("labelMarker");
        effects.exit("labelLink");
        return after;
      }
      function after(code) {
        return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);
      }
    }
    module.exports = labelStartLink;
  }
});

// node_modules/micromark/dist/tokenize/line-ending.js
var require_line_ending = __commonJS({
  "node_modules/micromark/dist/tokenize/line-ending.js"(exports, module) {
    "use strict";
    var factorySpace = require_factory_space();
    var lineEnding = {
      name: "lineEnding",
      tokenize: tokenizeLineEnding
    };
    function tokenizeLineEnding(effects, ok) {
      return start;
      function start(code) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, ok, "linePrefix");
      }
    }
    module.exports = lineEnding;
  }
});

// node_modules/micromark/dist/tokenize/thematic-break.js
var require_thematic_break = __commonJS({
  "node_modules/micromark/dist/tokenize/thematic-break.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var thematicBreak = {
      name: "thematicBreak",
      tokenize: tokenizeThematicBreak
    };
    function tokenizeThematicBreak(effects, ok, nok) {
      var size = 0;
      var marker;
      return start;
      function start(code) {
        effects.enter("thematicBreak");
        marker = code;
        return atBreak(code);
      }
      function atBreak(code) {
        if (code === marker) {
          effects.enter("thematicBreakSequence");
          return sequence(code);
        }
        if (markdownSpace(code)) {
          return factorySpace(effects, atBreak, "whitespace")(code);
        }
        if (size < 3 || code !== null && !markdownLineEnding(code)) {
          return nok(code);
        }
        effects.exit("thematicBreak");
        return ok(code);
      }
      function sequence(code) {
        if (code === marker) {
          effects.consume(code);
          size++;
          return sequence;
        }
        effects.exit("thematicBreakSequence");
        return atBreak(code);
      }
    }
    module.exports = thematicBreak;
  }
});

// node_modules/micromark/dist/tokenize/list.js
var require_list = __commonJS({
  "node_modules/micromark/dist/tokenize/list.js"(exports, module) {
    "use strict";
    var asciiDigit = require_ascii_digit();
    var markdownSpace = require_markdown_space();
    var prefixSize = require_prefix_size();
    var sizeChunks = require_size_chunks();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var thematicBreak = require_thematic_break();
    var list = {
      name: "list",
      tokenize: tokenizeListStart,
      continuation: {
        tokenize: tokenizeListContinuation
      },
      exit: tokenizeListEnd
    };
    var listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    var indentConstruct = {
      tokenize: tokenizeIndent,
      partial: true
    };
    function tokenizeListStart(effects, ok, nok) {
      var self2 = this;
      var initialSize = prefixSize(self2.events, "linePrefix");
      var size = 0;
      return start;
      function start(code) {
        var kind = self2.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");
        if (kind === "listUnordered" ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {
          if (!self2.containerState.type) {
            self2.containerState.type = kind;
            effects.enter(kind, {
              _container: true
            });
          }
          if (kind === "listUnordered") {
            effects.enter("listItemPrefix");
            return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);
          }
          if (!self2.interrupt || code === 49) {
            effects.enter("listItemPrefix");
            effects.enter("listItemValue");
            return inside(code);
          }
        }
        return nok(code);
      }
      function inside(code) {
        if (asciiDigit(code) && ++size < 10) {
          effects.consume(code);
          return inside;
        }
        if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === 41 || code === 46)) {
          effects.exit("listItemValue");
          return atMarker(code);
        }
        return nok(code);
      }
      function atMarker(code) {
        effects.enter("listItemMarker");
        effects.consume(code);
        effects.exit("listItemMarker");
        self2.containerState.marker = self2.containerState.marker || code;
        return effects.check(
          partialBlankLine,
          self2.interrupt ? nok : onBlank,
          effects.attempt(
            listItemPrefixWhitespaceConstruct,
            endOfPrefix,
            otherPrefix
          )
        );
      }
      function onBlank(code) {
        self2.containerState.initialBlankLine = true;
        initialSize++;
        return endOfPrefix(code);
      }
      function otherPrefix(code) {
        if (markdownSpace(code)) {
          effects.enter("listItemPrefixWhitespace");
          effects.consume(code);
          effects.exit("listItemPrefixWhitespace");
          return endOfPrefix;
        }
        return nok(code);
      }
      function endOfPrefix(code) {
        self2.containerState.size = initialSize + sizeChunks(self2.sliceStream(effects.exit("listItemPrefix")));
        return ok(code);
      }
    }
    function tokenizeListContinuation(effects, ok, nok) {
      var self2 = this;
      self2.containerState._closeFlow = void 0;
      return effects.check(partialBlankLine, onBlank, notBlank);
      function onBlank(code) {
        self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
        return factorySpace(
          effects,
          ok,
          "listItemIndent",
          self2.containerState.size + 1
        )(code);
      }
      function notBlank(code) {
        if (self2.containerState.furtherBlankLines || !markdownSpace(code)) {
          self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
          return notInCurrentItem(code);
        }
        self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
        return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);
      }
      function notInCurrentItem(code) {
        self2.containerState._closeFlow = true;
        self2.interrupt = void 0;
        return factorySpace(
          effects,
          effects.attempt(list, ok, nok),
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        )(code);
      }
    }
    function tokenizeIndent(effects, ok, nok) {
      var self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemIndent",
        self2.containerState.size + 1
      );
      function afterPrefix(code) {
        return prefixSize(self2.events, "listItemIndent") === self2.containerState.size ? ok(code) : nok(code);
      }
    }
    function tokenizeListEnd(effects) {
      effects.exit(this.containerState.type);
    }
    function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
      var self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemPrefixWhitespace",
        self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4 + 1
      );
      function afterPrefix(code) {
        return markdownSpace(code) || !prefixSize(self2.events, "listItemPrefixWhitespace") ? nok(code) : ok(code);
      }
    }
    module.exports = list;
  }
});

// node_modules/micromark/dist/tokenize/setext-underline.js
var require_setext_underline = __commonJS({
  "node_modules/micromark/dist/tokenize/setext-underline.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var shallow = require_shallow();
    var factorySpace = require_factory_space();
    var setextUnderline = {
      name: "setextUnderline",
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
    function resolveToSetextUnderline(events, context) {
      var index = events.length;
      var content;
      var text;
      var definition;
      var heading;
      while (index--) {
        if (events[index][0] === "enter") {
          if (events[index][1].type === "content") {
            content = index;
            break;
          }
          if (events[index][1].type === "paragraph") {
            text = index;
          }
        } else {
          if (events[index][1].type === "content") {
            events.splice(index, 1);
          }
          if (!definition && events[index][1].type === "definition") {
            definition = index;
          }
        }
      }
      heading = {
        type: "setextHeading",
        start: shallow(events[text][1].start),
        end: shallow(events[events.length - 1][1].end)
      };
      events[text][1].type = "setextHeadingText";
      if (definition) {
        events.splice(text, 0, ["enter", heading, context]);
        events.splice(definition + 1, 0, ["exit", events[content][1], context]);
        events[content][1].end = shallow(events[definition][1].end);
      } else {
        events[content][1] = heading;
      }
      events.push(["exit", heading, context]);
      return events;
    }
    function tokenizeSetextUnderline(effects, ok, nok) {
      var self2 = this;
      var index = self2.events.length;
      var marker;
      var paragraph;
      while (index--) {
        if (self2.events[index][1].type !== "lineEnding" && self2.events[index][1].type !== "linePrefix" && self2.events[index][1].type !== "content") {
          paragraph = self2.events[index][1].type === "paragraph";
          break;
        }
      }
      return start;
      function start(code) {
        if (!self2.lazy && (self2.interrupt || paragraph)) {
          effects.enter("setextHeadingLine");
          effects.enter("setextHeadingLineSequence");
          marker = code;
          return closingSequence(code);
        }
        return nok(code);
      }
      function closingSequence(code) {
        if (code === marker) {
          effects.consume(code);
          return closingSequence;
        }
        effects.exit("setextHeadingLineSequence");
        return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code);
      }
      function closingSequenceEnd(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("setextHeadingLine");
          return ok(code);
        }
        return nok(code);
      }
    }
    module.exports = setextUnderline;
  }
});

// node_modules/micromark/dist/constructs.js
var require_constructs = __commonJS({
  "node_modules/micromark/dist/constructs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var text$1 = require_text2();
    var attention = require_attention();
    var autolink = require_autolink();
    var blockQuote = require_block_quote();
    var characterEscape = require_character_escape();
    var characterReference = require_character_reference();
    var codeFenced = require_code_fenced();
    var codeIndented = require_code_indented();
    var codeText = require_code_text();
    var definition = require_definition();
    var hardBreakEscape = require_hard_break_escape();
    var headingAtx = require_heading_atx();
    var htmlFlow = require_html_flow();
    var htmlText = require_html_text();
    var labelEnd = require_label_end();
    var labelStartImage = require_label_start_image();
    var labelStartLink = require_label_start_link();
    var lineEnding = require_line_ending();
    var list = require_list();
    var setextUnderline = require_setext_underline();
    var thematicBreak = require_thematic_break();
    var document2 = {
      42: list,
      43: list,
      45: list,
      48: list,
      49: list,
      50: list,
      51: list,
      52: list,
      53: list,
      54: list,
      55: list,
      56: list,
      57: list,
      62: blockQuote
    };
    var contentInitial = {
      91: definition
    };
    var flowInitial = {
      "-2": codeIndented,
      "-1": codeIndented,
      32: codeIndented
    };
    var flow = {
      35: headingAtx,
      42: thematicBreak,
      45: [setextUnderline, thematicBreak],
      60: htmlFlow,
      61: setextUnderline,
      95: thematicBreak,
      96: codeFenced,
      126: codeFenced
    };
    var string = {
      38: characterReference,
      92: characterEscape
    };
    var text = {
      "-5": lineEnding,
      "-4": lineEnding,
      "-3": lineEnding,
      33: labelStartImage,
      38: characterReference,
      42: attention,
      60: [autolink, htmlText],
      91: labelStartLink,
      92: [hardBreakEscape, characterEscape],
      93: labelEnd,
      95: attention,
      96: codeText
    };
    var insideSpan = {
      null: [attention, text$1.resolver]
    };
    var disable = {
      null: []
    };
    exports.contentInitial = contentInitial;
    exports.disable = disable;
    exports.document = document2;
    exports.flow = flow;
    exports.flowInitial = flowInitial;
    exports.insideSpan = insideSpan;
    exports.string = string;
    exports.text = text;
  }
});

// node_modules/micromark/dist/parse.js
var require_parse = __commonJS({
  "node_modules/micromark/dist/parse.js"(exports, module) {
    "use strict";
    var content = require_content();
    var document2 = require_document();
    var flow = require_flow();
    var text = require_text2();
    var combineExtensions = require_combine_extensions();
    var createTokenizer = require_create_tokenizer();
    var miniflat = require_miniflat();
    var constructs = require_constructs();
    function parse(options) {
      var settings = options || {};
      var parser = {
        defined: [],
        constructs: combineExtensions(
          [constructs].concat(miniflat(settings.extensions))
        ),
        content: create(content),
        document: create(document2),
        flow: create(flow),
        string: create(text.string),
        text: create(text.text)
      };
      return parser;
      function create(initializer) {
        return creator;
        function creator(from) {
          return createTokenizer(parser, initializer, from);
        }
      }
    }
    module.exports = parse;
  }
});

// node_modules/micromark/dist/preprocess.js
var require_preprocess = __commonJS({
  "node_modules/micromark/dist/preprocess.js"(exports, module) {
    "use strict";
    var search = /[\0\t\n\r]/g;
    function preprocess() {
      var start = true;
      var column = 1;
      var buffer = "";
      var atCarriageReturn;
      return preprocessor;
      function preprocessor(value, encoding, end) {
        var chunks = [];
        var match;
        var next;
        var startPosition;
        var endPosition;
        var code;
        value = buffer + value.toString(encoding);
        startPosition = 0;
        buffer = "";
        if (start) {
          if (value.charCodeAt(0) === 65279) {
            startPosition++;
          }
          start = void 0;
        }
        while (startPosition < value.length) {
          search.lastIndex = startPosition;
          match = search.exec(value);
          endPosition = match ? match.index : value.length;
          code = value.charCodeAt(endPosition);
          if (!match) {
            buffer = value.slice(startPosition);
            break;
          }
          if (code === 10 && startPosition === endPosition && atCarriageReturn) {
            chunks.push(-3);
            atCarriageReturn = void 0;
          } else {
            if (atCarriageReturn) {
              chunks.push(-5);
              atCarriageReturn = void 0;
            }
            if (startPosition < endPosition) {
              chunks.push(value.slice(startPosition, endPosition));
              column += endPosition - startPosition;
            }
            if (code === 0) {
              chunks.push(65533);
              column++;
            } else if (code === 9) {
              next = Math.ceil(column / 4) * 4;
              chunks.push(-2);
              while (column++ < next)
                chunks.push(-1);
            } else if (code === 10) {
              chunks.push(-4);
              column = 1;
            } else {
              atCarriageReturn = true;
              column = 1;
            }
          }
          startPosition = endPosition + 1;
        }
        if (end) {
          if (atCarriageReturn)
            chunks.push(-5);
          if (buffer)
            chunks.push(buffer);
          chunks.push(null);
        }
        return chunks;
      }
    }
    module.exports = preprocess;
  }
});

// node_modules/micromark/dist/postprocess.js
var require_postprocess = __commonJS({
  "node_modules/micromark/dist/postprocess.js"(exports, module) {
    "use strict";
    var subtokenize = require_subtokenize();
    function postprocess(events) {
      while (!subtokenize(events)) {
      }
      return events;
    }
    module.exports = postprocess;
  }
});

// node_modules/mdast-util-from-markdown/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/mdast-util-from-markdown/dist/index.js"(exports, module) {
    "use strict";
    module.exports = fromMarkdown;
    var toString = require_mdast_util_to_string();
    var assign = require_assign();
    var own = require_has_own_property();
    var normalizeIdentifier = require_normalize_identifier();
    var safeFromInt = require_safe_from_int();
    var parser = require_parse();
    var preprocessor = require_preprocess();
    var postprocess = require_postprocess();
    var decode = require_decode_entity_browser();
    var stringifyPosition = require_unist_util_stringify_position();
    function fromMarkdown(value, encoding, options) {
      if (typeof encoding !== "string") {
        options = encoding;
        encoding = void 0;
      }
      return compiler(options)(
        postprocess(
          parser(options).document().write(preprocessor()(value, encoding, true))
        )
      );
    }
    function compiler(options) {
      var settings = options || {};
      var config = configure(
        {
          transforms: [],
          canContainEols: [
            "emphasis",
            "fragment",
            "heading",
            "paragraph",
            "strong"
          ],
          enter: {
            autolink: opener(link),
            autolinkProtocol: onenterdata,
            autolinkEmail: onenterdata,
            atxHeading: opener(heading),
            blockQuote: opener(blockQuote),
            characterEscape: onenterdata,
            characterReference: onenterdata,
            codeFenced: opener(codeFlow),
            codeFencedFenceInfo: buffer,
            codeFencedFenceMeta: buffer,
            codeIndented: opener(codeFlow, buffer),
            codeText: opener(codeText, buffer),
            codeTextData: onenterdata,
            data: onenterdata,
            codeFlowValue: onenterdata,
            definition: opener(definition),
            definitionDestinationString: buffer,
            definitionLabelString: buffer,
            definitionTitleString: buffer,
            emphasis: opener(emphasis),
            hardBreakEscape: opener(hardBreak),
            hardBreakTrailing: opener(hardBreak),
            htmlFlow: opener(html, buffer),
            htmlFlowData: onenterdata,
            htmlText: opener(html, buffer),
            htmlTextData: onenterdata,
            image: opener(image),
            label: buffer,
            link: opener(link),
            listItem: opener(listItem),
            listItemValue: onenterlistitemvalue,
            listOrdered: opener(list, onenterlistordered),
            listUnordered: opener(list),
            paragraph: opener(paragraph),
            reference: onenterreference,
            referenceString: buffer,
            resourceDestinationString: buffer,
            resourceTitleString: buffer,
            setextHeading: opener(heading),
            strong: opener(strong),
            thematicBreak: opener(thematicBreak)
          },
          exit: {
            atxHeading: closer(),
            atxHeadingSequence: onexitatxheadingsequence,
            autolink: closer(),
            autolinkEmail: onexitautolinkemail,
            autolinkProtocol: onexitautolinkprotocol,
            blockQuote: closer(),
            characterEscapeValue: onexitdata,
            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
            characterReferenceValue: onexitcharacterreferencevalue,
            codeFenced: closer(onexitcodefenced),
            codeFencedFence: onexitcodefencedfence,
            codeFencedFenceInfo: onexitcodefencedfenceinfo,
            codeFencedFenceMeta: onexitcodefencedfencemeta,
            codeFlowValue: onexitdata,
            codeIndented: closer(onexitcodeindented),
            codeText: closer(onexitcodetext),
            codeTextData: onexitdata,
            data: onexitdata,
            definition: closer(),
            definitionDestinationString: onexitdefinitiondestinationstring,
            definitionLabelString: onexitdefinitionlabelstring,
            definitionTitleString: onexitdefinitiontitlestring,
            emphasis: closer(),
            hardBreakEscape: closer(onexithardbreak),
            hardBreakTrailing: closer(onexithardbreak),
            htmlFlow: closer(onexithtmlflow),
            htmlFlowData: onexitdata,
            htmlText: closer(onexithtmltext),
            htmlTextData: onexitdata,
            image: closer(onexitimage),
            label: onexitlabel,
            labelText: onexitlabeltext,
            lineEnding: onexitlineending,
            link: closer(onexitlink),
            listItem: closer(),
            listOrdered: closer(),
            listUnordered: closer(),
            paragraph: closer(),
            referenceString: onexitreferencestring,
            resourceDestinationString: onexitresourcedestinationstring,
            resourceTitleString: onexitresourcetitlestring,
            resource: onexitresource,
            setextHeading: closer(onexitsetextheading),
            setextHeadingLineSequence: onexitsetextheadinglinesequence,
            setextHeadingText: onexitsetextheadingtext,
            strong: closer(),
            thematicBreak: closer()
          }
        },
        settings.mdastExtensions || []
      );
      var data = {};
      return compile;
      function compile(events) {
        var tree = { type: "root", children: [] };
        var stack = [tree];
        var tokenStack = [];
        var listStack = [];
        var index = -1;
        var handler;
        var listStart;
        var context = {
          stack,
          tokenStack,
          config,
          enter,
          exit,
          buffer,
          resume,
          setData,
          getData
        };
        while (++index < events.length) {
          if (events[index][1].type === "listOrdered" || events[index][1].type === "listUnordered") {
            if (events[index][0] === "enter") {
              listStack.push(index);
            } else {
              listStart = listStack.pop(index);
              index = prepareList(events, listStart, index);
            }
          }
        }
        index = -1;
        while (++index < events.length) {
          handler = config[events[index][0]];
          if (own.call(handler, events[index][1].type)) {
            handler[events[index][1].type].call(
              assign({ sliceSerialize: events[index][2].sliceSerialize }, context),
              events[index][1]
            );
          }
        }
        if (tokenStack.length) {
          throw new Error(
            "Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
              start: tokenStack[tokenStack.length - 1].start,
              end: tokenStack[tokenStack.length - 1].end
            }) + ") is still open"
          );
        }
        tree.position = {
          start: point(
            events.length ? events[0][1].start : { line: 1, column: 1, offset: 0 }
          ),
          end: point(
            events.length ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
          )
        };
        index = -1;
        while (++index < config.transforms.length) {
          tree = config.transforms[index](tree) || tree;
        }
        return tree;
      }
      function prepareList(events, start, length) {
        var index = start - 1;
        var containerBalance = -1;
        var listSpread = false;
        var listItem2;
        var tailIndex;
        var lineIndex;
        var tailEvent;
        var event;
        var firstBlankLineIndex;
        var atMarker;
        while (++index <= length) {
          event = events[index];
          if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
          } else if (event[1].type === "lineEndingBlank") {
            if (event[0] === "enter") {
              if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index;
              }
              atMarker = void 0;
            }
          } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
          } else {
            atMarker = void 0;
          }
          if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
            if (listItem2) {
              tailIndex = index;
              lineIndex = void 0;
              while (tailIndex--) {
                tailEvent = events[tailIndex];
                if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                  if (tailEvent[0] === "exit")
                    continue;
                  if (lineIndex) {
                    events[lineIndex][1].type = "lineEndingBlank";
                    listSpread = true;
                  }
                  tailEvent[1].type = "lineEnding";
                  lineIndex = tailIndex;
                } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
                } else {
                  break;
                }
              }
              if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
                listItem2._spread = true;
              }
              listItem2.end = point(
                lineIndex ? events[lineIndex][1].start : event[1].end
              );
              events.splice(lineIndex || index, 0, ["exit", listItem2, event[2]]);
              index++;
              length++;
            }
            if (event[1].type === "listItemPrefix") {
              listItem2 = {
                type: "listItem",
                _spread: false,
                start: point(event[1].start)
              };
              events.splice(index, 0, ["enter", listItem2, event[2]]);
              index++;
              length++;
              firstBlankLineIndex = void 0;
              atMarker = true;
            }
          }
        }
        events[start][1]._spread = listSpread;
        return length;
      }
      function setData(key, value) {
        data[key] = value;
      }
      function getData(key) {
        return data[key];
      }
      function point(d2) {
        return { line: d2.line, column: d2.column, offset: d2.offset };
      }
      function opener(create, and) {
        return open;
        function open(token) {
          enter.call(this, create(token), token);
          if (and)
            and.call(this, token);
        }
      }
      function buffer() {
        this.stack.push({ type: "fragment", children: [] });
      }
      function enter(node, token) {
        this.stack[this.stack.length - 1].children.push(node);
        this.stack.push(node);
        this.tokenStack.push(token);
        node.position = { start: point(token.start) };
        return node;
      }
      function closer(and) {
        return close;
        function close(token) {
          if (and)
            and.call(this, token);
          exit.call(this, token);
        }
      }
      function exit(token) {
        var node = this.stack.pop();
        var open = this.tokenStack.pop();
        if (!open) {
          throw new Error(
            "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): it\u2019s not open"
          );
        } else if (open.type !== token.type) {
          throw new Error(
            "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): a different token (`" + open.type + "`, " + stringifyPosition({ start: open.start, end: open.end }) + ") is open"
          );
        }
        node.position.end = point(token.end);
        return node;
      }
      function resume() {
        return toString(this.stack.pop());
      }
      function onenterlistordered() {
        setData("expectingFirstListItemValue", true);
      }
      function onenterlistitemvalue(token) {
        if (getData("expectingFirstListItemValue")) {
          this.stack[this.stack.length - 2].start = parseInt(
            this.sliceSerialize(token),
            10
          );
          setData("expectingFirstListItemValue");
        }
      }
      function onexitcodefencedfenceinfo() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].lang = data2;
      }
      function onexitcodefencedfencemeta() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].meta = data2;
      }
      function onexitcodefencedfence() {
        if (getData("flowCodeInside"))
          return;
        this.buffer();
        setData("flowCodeInside", true);
      }
      function onexitcodefenced() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2.replace(
          /^(\r?\n|\r)|(\r?\n|\r)$/g,
          ""
        );
        setData("flowCodeInside");
      }
      function onexitcodeindented() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitdefinitionlabelstring(token) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token)
        ).toLowerCase();
      }
      function onexitdefinitiontitlestring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].title = data2;
      }
      function onexitdefinitiondestinationstring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].url = data2;
      }
      function onexitatxheadingsequence(token) {
        if (!this.stack[this.stack.length - 1].depth) {
          this.stack[this.stack.length - 1].depth = this.sliceSerialize(
            token
          ).length;
        }
      }
      function onexitsetextheadingtext() {
        setData("setextHeadingSlurpLineEnding", true);
      }
      function onexitsetextheadinglinesequence(token) {
        this.stack[this.stack.length - 1].depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
      }
      function onexitsetextheading() {
        setData("setextHeadingSlurpLineEnding");
      }
      function onenterdata(token) {
        var siblings = this.stack[this.stack.length - 1].children;
        var tail = siblings[siblings.length - 1];
        if (!tail || tail.type !== "text") {
          tail = text();
          tail.position = { start: point(token.start) };
          this.stack[this.stack.length - 1].children.push(tail);
        }
        this.stack.push(tail);
      }
      function onexitdata(token) {
        var tail = this.stack.pop();
        tail.value += this.sliceSerialize(token);
        tail.position.end = point(token.end);
      }
      function onexitlineending(token) {
        var context = this.stack[this.stack.length - 1];
        if (getData("atHardBreak")) {
          context.children[context.children.length - 1].position.end = point(
            token.end
          );
          setData("atHardBreak");
          return;
        }
        if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.indexOf(context.type) > -1) {
          onenterdata.call(this, token);
          onexitdata.call(this, token);
        }
      }
      function onexithardbreak() {
        setData("atHardBreak", true);
      }
      function onexithtmlflow() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexithtmltext() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitcodetext() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitlink() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitimage() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitlabeltext(token) {
        this.stack[this.stack.length - 2].identifier = normalizeIdentifier(
          this.sliceSerialize(token)
        ).toLowerCase();
      }
      function onexitlabel() {
        var fragment = this.stack[this.stack.length - 1];
        var value = this.resume();
        this.stack[this.stack.length - 1].label = value;
        setData("inReference", true);
        if (this.stack[this.stack.length - 1].type === "link") {
          this.stack[this.stack.length - 1].children = fragment.children;
        } else {
          this.stack[this.stack.length - 1].alt = value;
        }
      }
      function onexitresourcedestinationstring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].url = data2;
      }
      function onexitresourcetitlestring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].title = data2;
      }
      function onexitresource() {
        setData("inReference");
      }
      function onenterreference() {
        setData("referenceType", "collapsed");
      }
      function onexitreferencestring(token) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token)
        ).toLowerCase();
        setData("referenceType", "full");
      }
      function onexitcharacterreferencemarker(token) {
        setData("characterReferenceType", token.type);
      }
      function onexitcharacterreferencevalue(token) {
        var data2 = this.sliceSerialize(token);
        var type = getData("characterReferenceType");
        var value;
        var tail;
        if (type) {
          value = safeFromInt(
            data2,
            type === "characterReferenceMarkerNumeric" ? 10 : 16
          );
          setData("characterReferenceType");
        } else {
          value = decode(data2);
        }
        tail = this.stack.pop();
        tail.value += value;
        tail.position.end = point(token.end);
      }
      function onexitautolinkprotocol(token) {
        onexitdata.call(this, token);
        this.stack[this.stack.length - 1].url = this.sliceSerialize(token);
      }
      function onexitautolinkemail(token) {
        onexitdata.call(this, token);
        this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(token);
      }
      function blockQuote() {
        return { type: "blockquote", children: [] };
      }
      function codeFlow() {
        return { type: "code", lang: null, meta: null, value: "" };
      }
      function codeText() {
        return { type: "inlineCode", value: "" };
      }
      function definition() {
        return {
          type: "definition",
          identifier: "",
          label: null,
          title: null,
          url: ""
        };
      }
      function emphasis() {
        return { type: "emphasis", children: [] };
      }
      function heading() {
        return { type: "heading", depth: void 0, children: [] };
      }
      function hardBreak() {
        return { type: "break" };
      }
      function html() {
        return { type: "html", value: "" };
      }
      function image() {
        return { type: "image", title: null, url: "", alt: null };
      }
      function link() {
        return { type: "link", title: null, url: "", children: [] };
      }
      function list(token) {
        return {
          type: "list",
          ordered: token.type === "listOrdered",
          start: null,
          spread: token._spread,
          children: []
        };
      }
      function listItem(token) {
        return {
          type: "listItem",
          spread: token._spread,
          checked: null,
          children: []
        };
      }
      function paragraph() {
        return { type: "paragraph", children: [] };
      }
      function strong() {
        return { type: "strong", children: [] };
      }
      function text() {
        return { type: "text", value: "" };
      }
      function thematicBreak() {
        return { type: "thematicBreak" };
      }
    }
    function configure(config, extensions) {
      var index = -1;
      while (++index < extensions.length) {
        extension(config, extensions[index]);
      }
      return config;
    }
    function extension(config, extension2) {
      var key;
      var left;
      for (key in extension2) {
        left = own.call(config, key) ? config[key] : config[key] = {};
        if (key === "canContainEols" || key === "transforms") {
          config[key] = [].concat(left, extension2[key]);
        } else {
          Object.assign(left, extension2[key]);
        }
      }
    }
  }
});

// node_modules/mdast-util-from-markdown/index.js
var require_mdast_util_from_markdown = __commonJS({
  "node_modules/mdast-util-from-markdown/index.js"(exports, module) {
    "use strict";
    module.exports = require_dist2();
  }
});

// node_modules/remark-parse/index.js
var require_remark_parse = __commonJS({
  "node_modules/remark-parse/index.js"(exports, module) {
    "use strict";
    module.exports = parse;
    var fromMarkdown = require_mdast_util_from_markdown();
    function parse(options) {
      var self2 = this;
      this.Parser = parse2;
      function parse2(doc) {
        return fromMarkdown(
          doc,
          Object.assign({}, self2.data("settings"), options, {
            extensions: self2.data("micromarkExtensions") || [],
            mdastExtensions: self2.data("fromMarkdownExtensions") || []
          })
        );
      }
    }
  }
});

// node_modules/mdast-add-list-metadata/node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents = __commonJS({
  "node_modules/mdast-add-list-metadata/node_modules/unist-util-visit-parents/index.js"(exports, module) {
    "use strict";
    module.exports = visitParents;
    function visitParents(tree, type, visitor) {
      var stack = [];
      if (typeof type === "function") {
        visitor = type;
        type = null;
      }
      one(tree);
      function one(node) {
        var result;
        if (!type || node.type === type) {
          result = visitor(node, stack.concat());
        }
        if (node.children && result !== false) {
          return all(node.children, node);
        }
        return result;
      }
      function all(children, parent) {
        var length = children.length;
        var index = -1;
        var child;
        stack.push(parent);
        while (++index < length) {
          child = children[index];
          if (child && one(child) === false) {
            return false;
          }
        }
        stack.pop();
        return true;
      }
    }
  }
});

// node_modules/mdast-add-list-metadata/index.js
var require_mdast_add_list_metadata = __commonJS({
  "node_modules/mdast-add-list-metadata/index.js"(exports, module) {
    var visitWithParents = require_unist_util_visit_parents();
    function addListMetadata() {
      return function(ast) {
        visitWithParents(ast, "list", function(listNode, parents) {
          var depth = 0, i2, n2;
          for (i2 = 0, n2 = parents.length; i2 < n2; i2++) {
            if (parents[i2].type === "list")
              depth += 1;
          }
          for (i2 = 0, n2 = listNode.children.length; i2 < n2; i2++) {
            var child = listNode.children[i2];
            child.index = i2;
            child.ordered = listNode.ordered;
          }
          listNode.depth = depth;
        });
        return ast;
      };
    }
    module.exports = addListMetadata;
  }
});

// node_modules/unist-util-is/convert.js
var require_convert = __commonJS({
  "node_modules/unist-util-is/convert.js"(exports, module) {
    "use strict";
    module.exports = convert;
    function convert(test) {
      if (test == null) {
        return ok;
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      if (typeof test === "object") {
        return "length" in test ? anyFactory(test) : allFactory(test);
      }
      if (typeof test === "function") {
        return test;
      }
      throw new Error("Expected function, string, or object as test");
    }
    function allFactory(test) {
      return all;
      function all(node) {
        var key;
        for (key in test) {
          if (node[key] !== test[key])
            return false;
        }
        return true;
      }
    }
    function anyFactory(tests) {
      var checks = [];
      var index = -1;
      while (++index < tests.length) {
        checks[index] = convert(tests[index]);
      }
      return any;
      function any() {
        var index2 = -1;
        while (++index2 < checks.length) {
          if (checks[index2].apply(this, arguments)) {
            return true;
          }
        }
        return false;
      }
    }
    function typeFactory(test) {
      return type;
      function type(node) {
        return Boolean(node && node.type === test);
      }
    }
    function ok() {
      return true;
    }
  }
});

// node_modules/unist-util-visit/node_modules/unist-util-visit-parents/color.browser.js
var require_color_browser = __commonJS({
  "node_modules/unist-util-visit/node_modules/unist-util-visit-parents/color.browser.js"(exports, module) {
    module.exports = identity;
    function identity(d2) {
      return d2;
    }
  }
});

// node_modules/unist-util-visit/node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents2 = __commonJS({
  "node_modules/unist-util-visit/node_modules/unist-util-visit-parents/index.js"(exports, module) {
    "use strict";
    module.exports = visitParents;
    var convert = require_convert();
    var color = require_color_browser();
    var CONTINUE = true;
    var SKIP = "skip";
    var EXIT = false;
    visitParents.CONTINUE = CONTINUE;
    visitParents.SKIP = SKIP;
    visitParents.EXIT = EXIT;
    function visitParents(tree, test, visitor, reverse) {
      var step;
      var is;
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      is = convert(test);
      step = reverse ? -1 : 1;
      factory(tree, null, [])();
      function factory(node, index, parents) {
        var value = typeof node === "object" && node !== null ? node : {};
        var name;
        if (typeof value.type === "string") {
          name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
          visit.displayName = "node (" + color(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit;
        function visit() {
          var grandparents = parents.concat(node);
          var result = [];
          var subresult;
          var offset;
          if (!test || is(node, index, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node, parents));
            if (result[0] === EXIT) {
              return result;
            }
          }
          if (node.children && result[0] !== SKIP) {
            offset = (reverse ? node.children.length : -1) + step;
            while (offset > -1 && offset < node.children.length) {
              subresult = factory(node.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    }
    function toResult(value) {
      if (value !== null && typeof value === "object" && "length" in value) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE, value];
      }
      return [value];
    }
  }
});

// node_modules/unist-util-visit/index.js
var require_unist_util_visit = __commonJS({
  "node_modules/unist-util-visit/index.js"(exports, module) {
    "use strict";
    module.exports = visit;
    var visitParents = require_unist_util_visit_parents2();
    var CONTINUE = visitParents.CONTINUE;
    var SKIP = visitParents.SKIP;
    var EXIT = visitParents.EXIT;
    visit.CONTINUE = CONTINUE;
    visit.SKIP = SKIP;
    visit.EXIT = EXIT;
    function visit(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      visitParents(tree, test, overload, reverse);
      function overload(node, parents) {
        var parent = parents[parents.length - 1];
        var index = parent ? parent.children.indexOf(node) : null;
        return visitor(node, index, parent);
      }
    }
  }
});

// node_modules/react-markdown/lib/plugins/naive-html.js
var require_naive_html = __commonJS({
  "node_modules/react-markdown/lib/plugins/naive-html.js"(exports, module) {
    "use strict";
    var visit = require_unist_util_visit();
    var type = "virtualHtml";
    var selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\s*\/?>$/i;
    var simpleTagRe = /^<(\/?)([a-z]+)\s*>$/;
    module.exports = function(tree) {
      var open;
      var currentParent;
      visit(
        tree,
        "html",
        function(node, index, parent) {
          if (currentParent !== parent) {
            open = [];
            currentParent = parent;
          }
          var selfClosing = getSelfClosing(node);
          if (selfClosing) {
            parent.children.splice(index, 1, {
              type,
              tag: selfClosing,
              position: node.position
            });
            return true;
          }
          var current = getSimpleTag(node, parent);
          if (!current) {
            return true;
          }
          var matching = findAndPull(open, current.tag);
          if (matching) {
            parent.children.splice(index, 0, virtual(current, matching, parent));
          } else if (!current.opening) {
            open.push(current);
          }
          return true;
        },
        true
      );
      return tree;
    };
    function findAndPull(open, matchingTag) {
      var i2 = open.length;
      while (i2--) {
        if (open[i2].tag === matchingTag) {
          return open.splice(i2, 1)[0];
        }
      }
      return false;
    }
    function getSimpleTag(node, parent) {
      var match = node.value.match(simpleTagRe);
      return match ? {
        tag: match[2],
        opening: !match[1],
        node
      } : false;
    }
    function getSelfClosing(node) {
      var match = node.value.match(selfClosingRe);
      return match ? match[1] : false;
    }
    function virtual(fromNode, toNode, parent) {
      var fromIndex = parent.children.indexOf(fromNode.node);
      var toIndex = parent.children.indexOf(toNode.node);
      var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);
      var children = extracted.slice(1, -1);
      return {
        type,
        children,
        tag: fromNode.tag,
        position: {
          start: fromNode.node.position.start,
          end: toNode.node.position.end,
          indent: []
        }
      };
    }
  }
});

// node_modules/react-markdown/lib/plugins/disallow-node.js
var require_disallow_node = __commonJS({
  "node_modules/react-markdown/lib/plugins/disallow-node.js"(exports) {
    "use strict";
    var visit = require_unist_util_visit();
    var splice = [].splice;
    exports.ofType = function(types, mode) {
      return ifNotMatch(allow, mode);
      function allow(node, index, parent) {
        return !types.includes(node.type);
      }
    };
    exports.ifNotMatch = ifNotMatch;
    function ifNotMatch(allow, mode) {
      return transform;
      function transform(tree) {
        visit(tree, filter2);
        return tree;
      }
      function filter2(node, index, parent) {
        if (parent && !allow(node, index, parent)) {
          var parameters = [index, 1];
          if (mode === "unwrap" && node.children) {
            parameters = parameters.concat(node.children);
          }
          splice.apply(parent.children, parameters);
          return index;
        }
      }
    }
  }
});

// node_modules/react-markdown/lib/ast-to-react.js
var require_ast_to_react = __commonJS({
  "node_modules/react-markdown/lib/ast-to-react.js"(exports, module) {
    "use strict";
    var React = require_react();
    var xtend = require_immutable();
    var ReactIs = require_react_is();
    function astToReact(node, options) {
      var parent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var renderer = options.renderers[node.type];
      if (!node.position) {
        node.position = {
          start: {
            line: null,
            column: null,
            offset: null
          },
          end: {
            line: null,
            column: null,
            offset: null
          }
        };
      }
      var pos = node.position.start;
      var key = [node.type, pos.line, pos.column, index].join("-");
      if (!ReactIs.isValidElementType(renderer)) {
        throw new Error("Renderer for type `".concat(node.type, "` not defined or is not renderable"));
      }
      var nodeProps = getNodeProps(node, key, options, renderer, parent, index);
      return React.createElement(renderer, nodeProps, nodeProps.children || resolveChildren() || void 0);
      function resolveChildren() {
        return node.children && node.children.map(function(childNode, i2) {
          return astToReact(childNode, options, {
            node,
            props: nodeProps
          }, i2);
        });
      }
    }
    function getNodeProps(node, key, opts, renderer, parent, index) {
      var props = {
        key
      };
      var isSimpleRenderer = typeof renderer === "string" || renderer === React.Fragment;
      if (opts.sourcePos && node.position) {
        props["data-sourcepos"] = flattenPosition(node.position);
      }
      if (opts.rawSourcePos && !isSimpleRenderer) {
        props.sourcePosition = node.position;
      }
      if (opts.includeNodeIndex && parent.node && parent.node.children && !isSimpleRenderer) {
        props.index = parent.node.children.indexOf(node);
        props.parentChildCount = parent.node.children.length;
      }
      var ref = node.identifier !== null && node.identifier !== void 0 ? opts.definitions[node.identifier.toUpperCase()] || {} : null;
      switch (node.type) {
        case "root":
          assignDefined(props, {
            className: opts.className
          });
          break;
        case "text":
          props.nodeKey = key;
          props.children = node.value;
          break;
        case "heading":
          props.level = node.depth;
          break;
        case "list":
          props.start = node.start;
          props.ordered = node.ordered;
          props.spread = node.spread;
          props.depth = node.depth;
          break;
        case "listItem":
          props.checked = node.checked;
          props.spread = node.spread;
          props.ordered = node.ordered;
          props.index = node.index;
          props.children = getListItemChildren(node, parent).map(function(childNode, i2) {
            return astToReact(childNode, opts, {
              node,
              props
            }, i2);
          });
          break;
        case "definition":
          assignDefined(props, {
            identifier: node.identifier,
            title: node.title,
            url: node.url
          });
          break;
        case "code":
          assignDefined(props, {
            language: node.lang && node.lang.split(/\s/, 1)[0]
          });
          break;
        case "inlineCode":
          props.children = node.value;
          props.inline = true;
          break;
        case "link":
          assignDefined(props, {
            title: node.title || void 0,
            target: typeof opts.linkTarget === "function" ? opts.linkTarget(node.url, node.children, node.title) : opts.linkTarget,
            href: opts.transformLinkUri ? opts.transformLinkUri(node.url, node.children, node.title) : node.url
          });
          break;
        case "image":
          assignDefined(props, {
            src: opts.transformImageUri ? opts.transformImageUri(node.url, node.children, node.title, node.alt) : node.url,
            alt: node.alt || "",
            title: node.title || void 0
          });
          break;
        case "linkReference":
          assignDefined(props, xtend(ref, {
            href: opts.transformLinkUri ? opts.transformLinkUri(ref.href) : ref.href
          }));
          break;
        case "imageReference":
          assignDefined(props, {
            src: opts.transformImageUri && ref.href ? opts.transformImageUri(ref.href, node.children, ref.title, node.alt) : ref.href,
            alt: node.alt || "",
            title: ref.title || void 0
          });
          break;
        case "table":
        case "tableHead":
        case "tableBody":
          props.columnAlignment = node.align;
          break;
        case "tableRow":
          props.isHeader = parent.node.type === "tableHead";
          props.columnAlignment = parent.props.columnAlignment;
          break;
        case "tableCell":
          assignDefined(props, {
            isHeader: parent.props.isHeader,
            align: parent.props.columnAlignment[index]
          });
          break;
        case "virtualHtml":
          props.tag = node.tag;
          break;
        case "html":
          props.isBlock = node.position.start.line !== node.position.end.line;
          props.allowDangerousHtml = opts.allowDangerousHtml;
          props.escapeHtml = opts.escapeHtml;
          props.skipHtml = opts.skipHtml;
          break;
        case "parsedHtml": {
          var parsedChildren;
          if (node.children) {
            parsedChildren = node.children.map(function(child, i2) {
              return astToReact(child, opts, {
                node,
                props
              }, i2);
            });
          }
          props.allowDangerousHtml = opts.allowDangerousHtml;
          props.escapeHtml = opts.escapeHtml;
          props.skipHtml = opts.skipHtml;
          props.element = node.element ? mergeNodeChildren(node, parsedChildren) : null;
          break;
        }
        default:
          assignDefined(props, xtend(node, {
            type: void 0,
            position: void 0,
            children: void 0
          }));
      }
      if (!isSimpleRenderer && node.value) {
        props.value = node.value;
      }
      if (!isSimpleRenderer) {
        props.node = node;
      }
      return props;
    }
    function assignDefined(target, attrs) {
      for (var key in attrs) {
        if (typeof attrs[key] !== "undefined") {
          target[key] = attrs[key];
        }
      }
    }
    function mergeNodeChildren(node, parsedChildren) {
      var el = node.element;
      if (Array.isArray(el)) {
        var Fragment = React.Fragment || "div";
        return React.createElement(Fragment, null, el);
      }
      if (el.props.children || parsedChildren) {
        var children = React.Children.toArray(el.props.children).concat(parsedChildren);
        return React.cloneElement(el, null, children);
      }
      return React.cloneElement(el, null);
    }
    function flattenPosition(pos) {
      return [pos.start.line, ":", pos.start.column, "-", pos.end.line, ":", pos.end.column].map(String).join("");
    }
    function getListItemChildren(node, parent) {
      var loose = parent && parent.node ? listLoose(parent.node) : listItemLoose(node);
      return loose ? node.children : unwrapParagraphs(node);
    }
    function unwrapParagraphs(node) {
      return node.children.reduce(function(array, child) {
        return array.concat(child.type === "paragraph" ? child.children : [child]);
      }, []);
    }
    function listLoose(node) {
      var children = node.children;
      var loose = node.spread;
      var index = -1;
      while (!loose && ++index < children.length) {
        loose = listItemLoose(children[index]);
      }
      return loose;
    }
    function listItemLoose(node) {
      var spread = node.spread;
      return spread === void 0 || spread === null ? node.children.length > 1 : spread;
    }
    module.exports = astToReact;
  }
});

// node_modules/react-markdown/lib/wrap-table-rows.js
var require_wrap_table_rows = __commonJS({
  "node_modules/react-markdown/lib/wrap-table-rows.js"(exports, module) {
    "use strict";
    var visit = require_unist_util_visit();
    module.exports = function(node) {
      visit(node, "table", wrap);
      return node;
    };
    function wrap(table) {
      var children = table.children;
      table.children = [{
        type: "tableHead",
        align: table.align,
        children: [children[0]],
        position: children[0].position
      }];
      if (children.length > 1) {
        table.children.push({
          type: "tableBody",
          align: table.align,
          children: children.slice(1),
          position: {
            start: children[1].position.start,
            end: children[children.length - 1].position.end
          }
        });
      }
    }
  }
});

// node_modules/react-markdown/lib/get-definitions.js
var require_get_definitions = __commonJS({
  "node_modules/react-markdown/lib/get-definitions.js"(exports, module) {
    "use strict";
    var visit = require_unist_util_visit();
    module.exports = function getDefinitions(tree) {
      var definitions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      visit(tree, "definition", function(node) {
        var identifier = node.identifier.toUpperCase();
        if (identifier in definitions)
          return;
        definitions[identifier] = {
          href: node.url,
          title: node.title
        };
      });
      return definitions;
    };
  }
});

// node_modules/react-markdown/lib/uri-transformer.js
var require_uri_transformer = __commonJS({
  "node_modules/react-markdown/lib/uri-transformer.js"(exports, module) {
    "use strict";
    var protocols = ["http", "https", "mailto", "tel"];
    module.exports = function uriTransformer(uri) {
      var url = (uri || "").trim();
      var first = url.charAt(0);
      if (first === "#" || first === "/") {
        return url;
      }
      var colon = url.indexOf(":");
      if (colon === -1) {
        return url;
      }
      var length = protocols.length;
      var index = -1;
      while (++index < length) {
        var protocol = protocols[index];
        if (colon === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) {
          return url;
        }
      }
      index = url.indexOf("?");
      if (index !== -1 && colon > index) {
        return url;
      }
      index = url.indexOf("#");
      if (index !== -1 && colon > index) {
        return url;
      }
      return "javascript:void(0)";
    };
  }
});

// node_modules/react-markdown/lib/renderers.js
var require_renderers = __commonJS({
  "node_modules/react-markdown/lib/renderers.js"(exports, module) {
    "use strict";
    var xtend = require_immutable();
    var React = require_react();
    var supportsStringRender = parseInt((React.version || "16").slice(0, 2), 10) >= 16;
    var createElement3 = React.createElement;
    module.exports = {
      break: "br",
      paragraph: "p",
      emphasis: "em",
      strong: "strong",
      thematicBreak: "hr",
      blockquote: "blockquote",
      delete: "del",
      link: "a",
      image: "img",
      linkReference: "a",
      imageReference: "img",
      table: SimpleRenderer.bind(null, "table"),
      tableHead: SimpleRenderer.bind(null, "thead"),
      tableBody: SimpleRenderer.bind(null, "tbody"),
      tableRow: SimpleRenderer.bind(null, "tr"),
      tableCell: TableCell,
      root: Root,
      text: TextRenderer,
      list: List,
      listItem: ListItem,
      definition: NullRenderer,
      heading: Heading,
      inlineCode: InlineCode,
      code: CodeBlock,
      html: Html,
      virtualHtml: VirtualHtml,
      parsedHtml: ParsedHtml
    };
    function TextRenderer(props) {
      var children = props.children || "";
      return supportsStringRender ? children : createElement3("span", null, children);
    }
    function Root(props) {
      var className = props.className;
      var root = !className && React.Fragment || "div";
      return createElement3(root, className ? {
        className
      } : null, props.children);
    }
    function SimpleRenderer(tag, props) {
      return createElement3(tag, getCoreProps(props), props.children);
    }
    function TableCell(props) {
      var style = props.align ? {
        textAlign: props.align
      } : void 0;
      var coreProps = getCoreProps(props);
      return createElement3(props.isHeader ? "th" : "td", style ? xtend({
        style
      }, coreProps) : coreProps, props.children);
    }
    function Heading(props) {
      return createElement3("h".concat(props.level), getCoreProps(props), props.children);
    }
    function List(props) {
      var attrs = getCoreProps(props);
      if (props.start !== null && props.start !== 1 && props.start !== void 0) {
        attrs.start = props.start.toString();
      }
      return createElement3(props.ordered ? "ol" : "ul", attrs, props.children);
    }
    function ListItem(props) {
      var checkbox = null;
      if (props.checked !== null && props.checked !== void 0) {
        var checked = props.checked;
        checkbox = createElement3("input", {
          type: "checkbox",
          checked,
          readOnly: true
        });
      }
      return createElement3("li", getCoreProps(props), checkbox, props.children);
    }
    function CodeBlock(props) {
      var className = props.language && "language-".concat(props.language);
      var code = createElement3("code", className ? {
        className
      } : null, props.value);
      return createElement3("pre", getCoreProps(props), code);
    }
    function InlineCode(props) {
      return createElement3("code", getCoreProps(props), props.children);
    }
    function Html(props) {
      if (props.skipHtml) {
        return null;
      }
      var dangerous = props.allowDangerousHtml || props.escapeHtml === false;
      var tag = props.isBlock ? "div" : "span";
      if (!dangerous) {
        return createElement3(React.Fragment || tag, null, props.value);
      }
      var nodeProps = {
        dangerouslySetInnerHTML: {
          __html: props.value
        }
      };
      return createElement3(tag, nodeProps);
    }
    function ParsedHtml(props) {
      return props["data-sourcepos"] ? React.cloneElement(props.element, {
        "data-sourcepos": props["data-sourcepos"]
      }) : props.element;
    }
    function VirtualHtml(props) {
      return createElement3(props.tag, getCoreProps(props), props.children);
    }
    function NullRenderer() {
      return null;
    }
    function getCoreProps(props) {
      var source = props["data-sourcepos"];
      return source ? {
        "data-sourcepos": source
      } : {};
    }
  }
});

// node_modules/react-markdown/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/react-markdown/lib/symbols.js"(exports) {
    "use strict";
    var HtmlParser = "__RMD_HTML_PARSER__";
    exports.HtmlParser = typeof Symbol === "undefined" ? HtmlParser : Symbol(HtmlParser);
  }
});

// node_modules/react-markdown/lib/react-markdown.js
var require_react_markdown = __commonJS({
  "node_modules/react-markdown/lib/react-markdown.js"(exports, module) {
    "use strict";
    var xtend = require_immutable();
    var unified = require_unified();
    var parse = require_remark_parse();
    var PropTypes = require_prop_types();
    var addListMetadata = require_mdast_add_list_metadata();
    var naiveHtml = require_naive_html();
    var disallowNode = require_disallow_node();
    var astToReact = require_ast_to_react();
    var wrapTableRows = require_wrap_table_rows();
    var getDefinitions = require_get_definitions();
    var uriTransformer = require_uri_transformer();
    var defaultRenderers = require_renderers();
    var symbols = require_symbols();
    var allTypes = Object.keys(defaultRenderers);
    var ReactMarkdown = function ReactMarkdown2(props) {
      var src = props.source || props.children || "";
      if (props.allowedTypes && props.disallowedTypes) {
        throw new Error("Only one of `allowedTypes` and `disallowedTypes` should be defined");
      }
      var renderers = xtend(defaultRenderers, props.renderers);
      var processor = unified().use(parse).use(props.plugins || []);
      var tree = processor.runSync(processor.parse(src));
      var renderProps = xtend(props, {
        renderers,
        definitions: getDefinitions(tree)
      });
      determineAstToReactTransforms(props).forEach(function(transform) {
        tree = transform(tree, renderProps);
      });
      return tree;
    };
    function determineAstToReactTransforms(props) {
      var transforms = [wrapTableRows, addListMetadata()];
      var disallowedTypes = props.disallowedTypes;
      if (props.allowedTypes) {
        disallowedTypes = allTypes.filter(function(type) {
          return type !== "root" && props.allowedTypes.indexOf(type) === -1;
        });
      }
      var removalMethod = props.unwrapDisallowed ? "unwrap" : "remove";
      if (disallowedTypes && disallowedTypes.length > 0) {
        transforms.push(disallowNode.ofType(disallowedTypes, removalMethod));
      }
      if (props.allowNode) {
        transforms.push(disallowNode.ifNotMatch(props.allowNode, removalMethod));
      }
      var renderHtml = (props.allowDangerousHtml || props.escapeHtml === false) && !props.skipHtml;
      var hasHtmlParser = (props.astPlugins || []).some(function(transform) {
        return transform.identity === symbols.HtmlParser;
      });
      if (renderHtml && !hasHtmlParser) {
        transforms.push(naiveHtml);
      }
      if (props.astPlugins) {
        transforms = transforms.concat(props.astPlugins);
      }
      transforms.push(astToReact);
      return transforms;
    }
    ReactMarkdown.defaultProps = {
      transformLinkUri: uriTransformer
    };
    ReactMarkdown.propTypes = {
      className: PropTypes.string,
      source: PropTypes.string,
      children: PropTypes.string,
      sourcePos: PropTypes.bool,
      rawSourcePos: PropTypes.bool,
      escapeHtml: PropTypes.bool,
      allowDangerousHtml: PropTypes.bool,
      skipHtml: PropTypes.bool,
      allowNode: PropTypes.func,
      allowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
      disallowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
      transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
      linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
      transformImageUri: PropTypes.func,
      astPlugins: PropTypes.arrayOf(PropTypes.func),
      unwrapDisallowed: PropTypes.bool,
      renderers: PropTypes.object,
      plugins: PropTypes.array
    };
    ReactMarkdown.types = allTypes;
    ReactMarkdown.renderers = defaultRenderers;
    ReactMarkdown.uriTransformer = uriTransformer;
    module.exports = ReactMarkdown;
  }
});

// node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js
var import_react = __toESM(require_react());

// node_modules/@virtuoso.dev/urx/dist/urx.esm.js
var PUBLISH = 0;
var SUBSCRIBE = 1;
var RESET = 2;
var VALUE = 4;
function compose(a2, b2) {
  return function(arg) {
    return a2(b2(arg));
  };
}
function thrush(arg, proc) {
  return proc(arg);
}
function curry2to1(proc, arg1) {
  return function(arg2) {
    return proc(arg1, arg2);
  };
}
function curry1to0(proc, arg) {
  return function() {
    return proc(arg);
  };
}
function tap(arg, proc) {
  proc(arg);
  return arg;
}
function tup() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
}
function call(proc) {
  proc();
}
function always(value) {
  return function() {
    return value;
  };
}
function joinProc() {
  for (var _len2 = arguments.length, procs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    procs[_key2] = arguments[_key2];
  }
  return function() {
    procs.map(call);
  };
}
function noop() {
}
function subscribe(emitter, subscription) {
  return emitter(SUBSCRIBE, subscription);
}
function publish(publisher, value) {
  publisher(PUBLISH, value);
}
function reset(emitter) {
  emitter(RESET);
}
function getValue(depot) {
  return depot(VALUE);
}
function connect(emitter, publisher) {
  return subscribe(emitter, curry2to1(publisher, PUBLISH));
}
function handleNext(emitter, subscription) {
  var unsub = emitter(SUBSCRIBE, function(value) {
    unsub();
    subscription(value);
  });
  return unsub;
}
function stream() {
  var subscriptions = [];
  return function(action, arg) {
    switch (action) {
      case RESET:
        subscriptions.splice(0, subscriptions.length);
        return;
      case SUBSCRIBE:
        subscriptions.push(arg);
        return function() {
          var indexOf = subscriptions.indexOf(arg);
          if (indexOf > -1) {
            subscriptions.splice(indexOf, 1);
          }
        };
      case PUBLISH:
        subscriptions.slice().forEach(function(subscription) {
          subscription(arg);
        });
        return;
      default:
        throw new Error("unrecognized action " + action);
    }
  };
}
function statefulStream(initial) {
  var value = initial;
  var innerSubject = stream();
  return function(action, arg) {
    switch (action) {
      case SUBSCRIBE:
        var subscription = arg;
        subscription(value);
        break;
      case PUBLISH:
        value = arg;
        break;
      case VALUE:
        return value;
    }
    return innerSubject(action, arg);
  };
}
function eventHandler(emitter) {
  var unsub;
  var currentSubscription;
  var cleanup = function cleanup2() {
    return unsub && unsub();
  };
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        if (subscription) {
          if (currentSubscription === subscription) {
            return;
          }
          cleanup();
          currentSubscription = subscription;
          unsub = subscribe(emitter, subscription);
          return unsub;
        } else {
          cleanup();
          return noop;
        }
      case RESET:
        cleanup();
        currentSubscription = null;
        return;
      default:
        throw new Error("unrecognized action " + action);
    }
  };
}
function streamFromEmitter(emitter) {
  return tap(stream(), function(stream2) {
    return connect(emitter, stream2);
  });
}
function statefulStreamFromEmitter(emitter, initial) {
  return tap(statefulStream(initial), function(stream2) {
    return connect(emitter, stream2);
  });
}
function combineOperators() {
  for (var _len = arguments.length, operators = new Array(_len), _key = 0; _key < _len; _key++) {
    operators[_key] = arguments[_key];
  }
  return function(subscriber) {
    return operators.reduceRight(thrush, subscriber);
  };
}
function pipe(source) {
  for (var _len2 = arguments.length, operators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    operators[_key2 - 1] = arguments[_key2];
  }
  var project = combineOperators.apply(void 0, operators);
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        return subscribe(source, project(subscription));
      case RESET:
        reset(source);
        return;
      default:
        throw new Error("unrecognized action " + action);
    }
  };
}
function defaultComparator(previous, next) {
  return previous === next;
}
function distinctUntilChanged(comparator) {
  if (comparator === void 0) {
    comparator = defaultComparator;
  }
  var current;
  return function(done) {
    return function(next) {
      if (!comparator(current, next)) {
        current = next;
        done(next);
      }
    };
  };
}
function filter(predicate) {
  return function(done) {
    return function(value) {
      predicate(value) && done(value);
    };
  };
}
function map(project) {
  return function(done) {
    return compose(done, project);
  };
}
function mapTo(value) {
  return function(done) {
    return function() {
      return done(value);
    };
  };
}
function scan(scanner, initial) {
  return function(done) {
    return function(value) {
      return done(initial = scanner(initial, value));
    };
  };
}
function skip(times) {
  return function(done) {
    return function(value) {
      times > 0 ? times-- : done(value);
    };
  };
}
function throttleTime(interval) {
  var currentValue;
  var timeout;
  return function(done) {
    return function(value) {
      currentValue = value;
      if (timeout) {
        return;
      }
      timeout = setTimeout(function() {
        timeout = void 0;
        done(currentValue);
      }, interval);
    };
  };
}
function debounceTime(interval) {
  var currentValue;
  var timeout;
  return function(done) {
    return function(value) {
      currentValue = value;
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(function() {
        done(currentValue);
      }, interval);
    };
  };
}
function withLatestFrom() {
  for (var _len3 = arguments.length, sources = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    sources[_key3] = arguments[_key3];
  }
  var values = new Array(sources.length);
  var called = 0;
  var pendingCall = null;
  var allCalled = Math.pow(2, sources.length) - 1;
  sources.forEach(function(source, index) {
    var bit = Math.pow(2, index);
    subscribe(source, function(value) {
      var prevCalled = called;
      called = called | bit;
      values[index] = value;
      if (prevCalled !== allCalled && called === allCalled && pendingCall) {
        pendingCall();
        pendingCall = null;
      }
    });
  });
  return function(done) {
    return function(value) {
      var call2 = function call3() {
        return done([value].concat(values));
      };
      if (called === allCalled) {
        call2();
      } else {
        pendingCall = call2;
      }
    };
  };
}
function merge() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        return joinProc.apply(void 0, sources.map(function(source) {
          return subscribe(source, subscription);
        }));
      case RESET:
        return;
      default:
        throw new Error("unrecognized action " + action);
    }
  };
}
function duc(source, comparator) {
  if (comparator === void 0) {
    comparator = defaultComparator;
  }
  return pipe(source, distinctUntilChanged(comparator));
}
function combineLatest() {
  var innerSubject = stream();
  for (var _len2 = arguments.length, emitters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    emitters[_key2] = arguments[_key2];
  }
  var values = new Array(emitters.length);
  var called = 0;
  var allCalled = Math.pow(2, emitters.length) - 1;
  emitters.forEach(function(source, index) {
    var bit = Math.pow(2, index);
    subscribe(source, function(value) {
      values[index] = value;
      called = called | bit;
      if (called === allCalled) {
        publish(innerSubject, values);
      }
    });
  });
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        if (called === allCalled) {
          subscription(values);
        }
        return subscribe(innerSubject, subscription);
      case RESET:
        return reset(innerSubject);
      default:
        throw new Error("unrecognized action " + action);
    }
  };
}
function system(constructor, dependencies, _temp) {
  if (dependencies === void 0) {
    dependencies = [];
  }
  var _ref = _temp === void 0 ? {
    singleton: true
  } : _temp, singleton = _ref.singleton;
  return {
    id: id(),
    constructor,
    dependencies,
    singleton
  };
}
var id = function id2() {
  return Symbol();
};
function init(systemSpec) {
  var singletons = /* @__PURE__ */ new Map();
  var _init = function _init2(_ref2) {
    var id3 = _ref2.id, constructor = _ref2.constructor, dependencies = _ref2.dependencies, singleton = _ref2.singleton;
    if (singleton && singletons.has(id3)) {
      return singletons.get(id3);
    }
    var system2 = constructor(dependencies.map(function(e) {
      return _init2(e);
    }));
    if (singleton) {
      singletons.set(id3, system2);
    }
    return system2;
  };
  return _init(systemSpec);
}

// node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (it2)
    return (it2 = it2.call(o2)).next.bind(it2);
  if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
    if (it2)
      o2 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o2.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o2[i2++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var _excluded = ["children"];
function omit(keys, obj) {
  var result = {};
  var index = {};
  var idx = 0;
  var len = keys.length;
  while (idx < len) {
    index[keys[idx]] = 1;
    idx += 1;
  }
  for (var prop in obj) {
    if (!index.hasOwnProperty(prop)) {
      result[prop] = obj[prop];
    }
  }
  return result;
}
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function systemToComponent(systemSpec, map2, Root) {
  var requiredPropNames = Object.keys(map2.required || {});
  var optionalPropNames = Object.keys(map2.optional || {});
  var methodNames = Object.keys(map2.methods || {});
  var eventNames = Object.keys(map2.events || {});
  var Context = (0, import_react.createContext)({});
  function applyPropsToSystem(system2, props) {
    if (system2["propsReady"]) {
      publish(system2["propsReady"], false);
    }
    for (var _iterator = _createForOfIteratorHelperLoose(requiredPropNames), _step; !(_step = _iterator()).done; ) {
      var requiredPropName = _step.value;
      var stream2 = system2[map2.required[requiredPropName]];
      publish(stream2, props[requiredPropName]);
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(optionalPropNames), _step2; !(_step2 = _iterator2()).done; ) {
      var optionalPropName = _step2.value;
      if (optionalPropName in props) {
        var _stream = system2[map2.optional[optionalPropName]];
        publish(_stream, props[optionalPropName]);
      }
    }
    if (system2["propsReady"]) {
      publish(system2["propsReady"], true);
    }
  }
  function buildMethods(system2) {
    return methodNames.reduce(function(acc, methodName) {
      acc[methodName] = function(value) {
        var stream2 = system2[map2.methods[methodName]];
        publish(stream2, value);
      };
      return acc;
    }, {});
  }
  function buildEventHandlers(system2) {
    return eventNames.reduce(function(handlers, eventName) {
      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);
      return handlers;
    }, {});
  }
  var Component = (0, import_react.forwardRef)(function(propsWithChildren, ref) {
    var children = propsWithChildren.children, props = _objectWithoutPropertiesLoose(propsWithChildren, _excluded);
    var _useState = (0, import_react.useState)(function() {
      return tap(init(systemSpec), function(system3) {
        return applyPropsToSystem(system3, props);
      });
    }), system2 = _useState[0];
    var _useState2 = (0, import_react.useState)(curry1to0(buildEventHandlers, system2)), handlers = _useState2[0];
    useIsomorphicLayoutEffect(function() {
      for (var _iterator3 = _createForOfIteratorHelperLoose(eventNames), _step3; !(_step3 = _iterator3()).done; ) {
        var eventName = _step3.value;
        if (eventName in props) {
          subscribe(handlers[eventName], props[eventName]);
        }
      }
      return function() {
        Object.values(handlers).map(reset);
      };
    }, [props, handlers, system2]);
    useIsomorphicLayoutEffect(function() {
      applyPropsToSystem(system2, props);
    });
    (0, import_react.useImperativeHandle)(ref, always(buildMethods(system2)));
    return (0, import_react.createElement)(Context.Provider, {
      value: system2
    }, Root ? (0, import_react.createElement)(Root, omit([].concat(requiredPropNames, optionalPropNames, eventNames), props), children) : children);
  });
  var usePublisher = function usePublisher2(key) {
    return (0, import_react.useCallback)(curry2to1(publish, (0, import_react.useContext)(Context)[key]), [key]);
  };
  var useEmitterValue = function useEmitterValue2(key) {
    var context = (0, import_react.useContext)(Context);
    var source = context[key];
    var _useState3 = (0, import_react.useState)(curry1to0(getValue, source)), value = _useState3[0], setValue = _useState3[1];
    useIsomorphicLayoutEffect(function() {
      return subscribe(source, function(next) {
        if (next !== value) {
          setValue(always(next));
        }
      });
    }, [source, value]);
    return value;
  };
  var useEmitter = function useEmitter2(key, callback) {
    var context = (0, import_react.useContext)(Context);
    var source = context[key];
    useIsomorphicLayoutEffect(function() {
      return subscribe(source, callback);
    }, [callback, source]);
  };
  return {
    Component,
    usePublisher,
    useEmitterValue,
    useEmitter
  };
}

// node_modules/react-virtuoso/dist/index.m.js
var n = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function u() {
  return u = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (t[r2] = n2[r2]);
    }
    return t;
  }, u.apply(this, arguments);
}
function c(t, e) {
  if (null == t)
    return {};
  var n2, r2, o2 = {}, i2 = Object.keys(t);
  for (r2 = 0; r2 < i2.length; r2++)
    e.indexOf(n2 = i2[r2]) >= 0 || (o2[n2] = t[n2]);
  return o2;
}
function m(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var n2 = 0, r2 = new Array(e); n2 < e; n2++)
    r2[n2] = t[n2];
  return r2;
}
function d(t, e) {
  var n2 = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
  if (n2)
    return (n2 = n2.call(t)).next.bind(n2);
  if (Array.isArray(t) || (n2 = function(t2, e2) {
    if (t2) {
      if ("string" == typeof t2)
        return m(t2, e2);
      var n3 = Object.prototype.toString.call(t2).slice(8, -1);
      return "Object" === n3 && t2.constructor && (n3 = t2.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t2) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? m(t2, e2) : void 0;
    }
  }(t)) || e && t && "number" == typeof t.length) {
    n2 && (t = n2);
    var r2 = 0;
    return function() {
      return r2 >= t.length ? { done: true } : { done: false, value: t[r2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var f;
var p;
var h = "undefined" != typeof document ? import_react2.useLayoutEffect : import_react2.useEffect;
!function(t) {
  t[t.DEBUG = 0] = "DEBUG", t[t.INFO = 1] = "INFO", t[t.WARN = 2] = "WARN", t[t.ERROR = 3] = "ERROR";
}(p || (p = {}));
var g = ((f = {})[p.DEBUG] = "debug", f[p.INFO] = "log", f[p.WARN] = "warn", f[p.ERROR] = "error", f);
var v = system(function() {
  var t = statefulStream(p.ERROR);
  return { log: statefulStream(function(n2, r2, o2) {
    var i2;
    void 0 === o2 && (o2 = p.INFO), o2 >= (null != (i2 = ("undefined" == typeof globalThis ? window : globalThis).VIRTUOSO_LOG_LEVEL) ? i2 : getValue(t)) && console[g[o2]]("%creact-virtuoso: %c%s %o", "color: #0253b3; font-weight: bold", "color: initial", n2, r2);
  }), logLevel: t };
}, [], { singleton: true });
function S(t, e) {
  void 0 === e && (e = true);
  var n2 = (0, import_react2.useRef)(null), r2 = function(t2) {
  };
  if ("undefined" != typeof ResizeObserver) {
    var o2 = new ResizeObserver(function(e2) {
      var n3 = e2[0].target;
      null !== n3.offsetParent && t(n3);
    });
    r2 = function(t2) {
      t2 && e ? (o2.observe(t2), n2.current = t2) : (n2.current && o2.unobserve(n2.current), n2.current = null);
    };
  }
  return { ref: n2, callbackRef: r2 };
}
function I(t, e) {
  return void 0 === e && (e = true), S(t, e).callbackRef;
}
function C(t, e, n2, r2, o2, i2, a2) {
  return S(function(n3) {
    for (var l2 = function(t2, e2, n4, r3) {
      var o3 = t2.length;
      if (0 === o3)
        return null;
      for (var i3 = [], a3 = 0; a3 < o3; a3++) {
        var l3 = t2.item(a3);
        if (l3 && void 0 !== l3.dataset.index) {
          var s3 = parseInt(l3.dataset.index), u3 = parseFloat(l3.dataset.knownSize), c3 = e2(l3, "offsetHeight");
          if (0 === c3 && r3("Zero-sized element, this should not happen", { child: l3 }, p.ERROR), c3 !== u3) {
            var m3 = i3[i3.length - 1];
            0 === i3.length || m3.size !== c3 || m3.endIndex !== s3 - 1 ? i3.push({ startIndex: s3, endIndex: s3, size: c3 }) : i3[i3.length - 1].endIndex++;
          }
        }
      }
      return i3;
    }(n3.children, e, 0, o2), s2 = n3.parentElement; !s2.dataset.virtuosoScroller; )
      s2 = s2.parentElement;
    var u2 = "window" === s2.firstElementChild.dataset.viewportType, c2 = a2 ? a2.scrollTop : u2 ? window.pageYOffset || document.documentElement.scrollTop : s2.scrollTop, m2 = a2 ? a2.scrollHeight : u2 ? document.documentElement.scrollHeight : s2.scrollHeight, d2 = a2 ? a2.offsetHeight : u2 ? window.innerHeight : s2.offsetHeight;
    r2({ scrollTop: Math.max(c2, 0), scrollHeight: m2, viewportHeight: d2 }), null == i2 || i2(function(t2, e2, n4) {
      return "normal" === e2 || null != e2 && e2.endsWith("px") || n4("row-gap was not resolved to pixel value correctly", e2, p.WARN), "normal" === e2 ? 0 : parseInt(null != e2 ? e2 : "0", 10);
    }(0, getComputedStyle(n3).rowGap, o2)), null !== l2 && t(l2);
  }, n2);
}
function T(t, e) {
  return Math.round(t.getBoundingClientRect()[e]);
}
function w(t, e) {
  return Math.abs(t - e) < 1.01;
}
function x(t, n2, r2, l2, u2) {
  void 0 === l2 && (l2 = noop);
  var c2 = (0, import_react2.useRef)(null), m2 = (0, import_react2.useRef)(null), d2 = (0, import_react2.useRef)(null), f2 = (0, import_react2.useRef)(false), p2 = (0, import_react2.useCallback)(function(e) {
    var r3 = e.target, o2 = r3 === window || r3 === document, i2 = o2 ? window.pageYOffset || document.documentElement.scrollTop : r3.scrollTop, a2 = o2 ? document.documentElement.scrollHeight : r3.scrollHeight, l3 = o2 ? window.innerHeight : r3.offsetHeight, u3 = function() {
      t({ scrollTop: Math.max(i2, 0), scrollHeight: a2, viewportHeight: l3 });
    };
    f2.current ? (0, import_react_dom.flushSync)(u3) : u3(), f2.current = false, null !== m2.current && (i2 === m2.current || i2 <= 0 || i2 === a2 - l3) && (m2.current = null, n2(true), d2.current && (clearTimeout(d2.current), d2.current = null));
  }, [t, n2]);
  return (0, import_react2.useEffect)(function() {
    var t2 = u2 || c2.current;
    return l2(u2 || c2.current), p2({ target: t2 }), t2.addEventListener("scroll", p2, { passive: true }), function() {
      l2(null), t2.removeEventListener("scroll", p2);
    };
  }, [c2, p2, r2, l2, u2]), { scrollerRef: c2, scrollByCallback: function(t2) {
    f2.current = true, c2.current.scrollBy(t2);
  }, scrollToCallback: function(e) {
    var r3 = c2.current;
    if (r3 && (!("offsetHeight" in r3) || 0 !== r3.offsetHeight)) {
      var o2, i2, a2, l3 = "smooth" === e.behavior;
      if (r3 === window ? (i2 = Math.max(T(document.documentElement, "height"), document.documentElement.scrollHeight), o2 = window.innerHeight, a2 = document.documentElement.scrollTop) : (i2 = r3.scrollHeight, o2 = T(r3, "height"), a2 = r3.scrollTop), e.top = Math.ceil(Math.max(Math.min(i2 - o2, e.top), 0)), w(o2, i2) || e.top === a2)
        return t({ scrollTop: a2, scrollHeight: i2, viewportHeight: o2 }), void (l3 && n2(true));
      l3 ? (m2.current = e.top, d2.current && clearTimeout(d2.current), d2.current = setTimeout(function() {
        d2.current = null, m2.current = null, n2(true);
      }, 1e3)) : m2.current = null, r3.scrollTo(e);
    }
  } };
}
var b = system(function() {
  var t = stream(), n2 = stream(), r2 = statefulStream(0), o2 = stream(), i2 = statefulStream(0), a2 = stream(), l2 = stream(), s2 = statefulStream(0), u2 = statefulStream(0), c2 = statefulStream(0), m2 = stream(), d2 = stream(), f2 = statefulStream(false), p2 = statefulStream(false);
  return connect(pipe(t, map(function(t2) {
    return t2.scrollTop;
  })), n2), connect(pipe(t, map(function(t2) {
    return t2.scrollHeight;
  })), l2), connect(n2, i2), { scrollContainerState: t, scrollTop: n2, viewportHeight: a2, headerHeight: s2, fixedHeaderHeight: u2, footerHeight: c2, scrollHeight: l2, smoothScrollTargetReached: o2, react18ConcurrentRendering: p2, scrollTo: m2, scrollBy: d2, statefulScrollTop: i2, deviation: r2, scrollingInProgress: f2 };
}, [], { singleton: true });
var y = { lvl: 0 };
function E(t, e, n2, r2, o2) {
  return void 0 === r2 && (r2 = y), void 0 === o2 && (o2 = y), { k: t, v: e, lvl: n2, l: r2, r: o2 };
}
function H(t) {
  return t === y;
}
function R() {
  return y;
}
function L(t, e) {
  if (H(t))
    return y;
  var n2 = t.k, r2 = t.l, o2 = t.r;
  if (e === n2) {
    if (H(r2))
      return o2;
    if (H(o2))
      return r2;
    var i2 = P(r2);
    return U(M(t, { k: i2[0], v: i2[1], l: O(r2) }));
  }
  return U(M(t, e < n2 ? { l: L(r2, e) } : { r: L(o2, e) }));
}
function k(t, e, n2) {
  if (void 0 === n2 && (n2 = "k"), H(t))
    return [-Infinity, void 0];
  if (t[n2] === e)
    return [t.k, t.v];
  if (t[n2] < e) {
    var r2 = k(t.r, e, n2);
    return -Infinity === r2[0] ? [t.k, t.v] : r2;
  }
  return k(t.l, e, n2);
}
function z(t, e, n2) {
  return H(t) ? E(e, n2, 1) : e === t.k ? M(t, { k: e, v: n2 }) : function(t2) {
    return N(D(t2));
  }(M(t, e < t.k ? { l: z(t.l, e, n2) } : { r: z(t.r, e, n2) }));
}
function B(t, e, n2) {
  if (H(t))
    return [];
  var r2 = t.k, o2 = t.v, i2 = t.r, a2 = [];
  return r2 > e && (a2 = a2.concat(B(t.l, e, n2))), r2 >= e && r2 <= n2 && a2.push({ k: r2, v: o2 }), r2 <= n2 && (a2 = a2.concat(B(i2, e, n2))), a2;
}
function F(t) {
  return H(t) ? [] : [].concat(F(t.l), [{ k: t.k, v: t.v }], F(t.r));
}
function P(t) {
  return H(t.r) ? [t.k, t.v] : P(t.r);
}
function O(t) {
  return H(t.r) ? t.l : U(M(t, { r: O(t.r) }));
}
function M(t, e) {
  return E(void 0 !== e.k ? e.k : t.k, void 0 !== e.v ? e.v : t.v, void 0 !== e.lvl ? e.lvl : t.lvl, void 0 !== e.l ? e.l : t.l, void 0 !== e.r ? e.r : t.r);
}
function V(t) {
  return H(t) || t.lvl > t.r.lvl;
}
function U(t) {
  var e = t.l, n2 = t.r, r2 = t.lvl;
  if (n2.lvl >= r2 - 1 && e.lvl >= r2 - 1)
    return t;
  if (r2 > n2.lvl + 1) {
    if (V(e))
      return D(M(t, { lvl: r2 - 1 }));
    if (H(e) || H(e.r))
      throw new Error("Unexpected empty nodes");
    return M(e.r, { l: M(e, { r: e.r.l }), r: M(t, { l: e.r.r, lvl: r2 - 1 }), lvl: r2 });
  }
  if (V(t))
    return N(M(t, { lvl: r2 - 1 }));
  if (H(n2) || H(n2.l))
    throw new Error("Unexpected empty nodes");
  var o2 = n2.l, i2 = V(o2) ? n2.lvl - 1 : n2.lvl;
  return M(o2, { l: M(t, { r: o2.l, lvl: r2 - 1 }), r: N(M(n2, { l: o2.r, lvl: i2 })), lvl: o2.lvl + 1 });
}
function A(t, e, n2) {
  return H(t) ? [] : W(B(t, k(t, e)[0], n2), function(t2) {
    return { index: t2.k, value: t2.v };
  });
}
function W(t, e) {
  var n2 = t.length;
  if (0 === n2)
    return [];
  for (var r2 = e(t[0]), o2 = r2.index, i2 = r2.value, a2 = [], l2 = 1; l2 < n2; l2++) {
    var s2 = e(t[l2]), u2 = s2.index, c2 = s2.value;
    a2.push({ start: o2, end: u2 - 1, value: i2 }), o2 = u2, i2 = c2;
  }
  return a2.push({ start: o2, end: Infinity, value: i2 }), a2;
}
function N(t) {
  var e = t.r, n2 = t.lvl;
  return H(e) || H(e.r) || e.lvl !== n2 || e.r.lvl !== n2 ? t : M(e, { l: M(t, { r: e.l }), lvl: n2 + 1 });
}
function D(t) {
  var e = t.l;
  return H(e) || e.lvl !== t.lvl ? t : M(e, { r: M(t, { l: e.r }) });
}
function G(t, e, n2, r2) {
  void 0 === r2 && (r2 = 0);
  for (var o2 = t.length - 1; r2 <= o2; ) {
    var i2 = Math.floor((r2 + o2) / 2), a2 = n2(t[i2], e);
    if (0 === a2)
      return i2;
    if (-1 === a2) {
      if (o2 - r2 < 2)
        return i2 - 1;
      o2 = i2 - 1;
    } else {
      if (o2 === r2)
        return i2;
      r2 = i2 + 1;
    }
  }
  throw new Error("Failed binary finding record in array - " + t.join(",") + ", searched for " + e);
}
function _(t, e, n2) {
  return t[G(t, e, n2)];
}
var j = system(function() {
  return { recalcInProgress: statefulStream(false) };
}, [], { singleton: true });
function K(t) {
  var e = t.size, n2 = t.startIndex, r2 = t.endIndex;
  return function(t2) {
    return t2.start === n2 && (t2.end === r2 || Infinity === t2.end) && t2.value === e;
  };
}
function Y(t, e) {
  var n2 = t.index;
  return e === n2 ? 0 : e < n2 ? -1 : 1;
}
function q(t, e) {
  var n2 = t.offset;
  return e === n2 ? 0 : e < n2 ? -1 : 1;
}
function Z(t) {
  return { index: t.index, value: t };
}
function J(t, e, n2, r2) {
  var o2 = t, i2 = 0, a2 = 0, l2 = 0, s2 = 0;
  if (0 !== e) {
    l2 = o2[s2 = G(o2, e - 1, Y)].offset;
    var u2 = k(n2, e - 1);
    i2 = u2[0], a2 = u2[1], o2.length && o2[s2].size === k(n2, e)[1] && (s2 -= 1), o2 = o2.slice(0, s2 + 1);
  } else
    o2 = [];
  for (var c2, m2 = d(A(n2, e, Infinity)); !(c2 = m2()).done; ) {
    var f2 = c2.value, p2 = f2.start, h2 = f2.value, g2 = p2 - i2, v2 = g2 * a2 + l2 + g2 * r2;
    o2.push({ offset: v2, size: h2, index: p2 }), i2 = p2, l2 = v2, a2 = h2;
  }
  return { offsetTree: o2, lastIndex: i2, lastOffset: l2, lastSize: a2 };
}
function $(t, e) {
  var n2 = e[0], r2 = e[1], o2 = e[3];
  n2.length > 0 && (0, e[2])("received item sizes", n2, p.DEBUG);
  var i2 = t.sizeTree, a2 = i2, l2 = 0;
  if (r2.length > 0 && H(i2) && 2 === n2.length) {
    var s2 = n2[0].size, u2 = n2[1].size;
    a2 = r2.reduce(function(t2, e2) {
      return z(z(t2, e2, s2), e2 + 1, u2);
    }, a2);
  } else {
    var c2 = function(t2, e2) {
      for (var n3, r3 = H(t2) ? 0 : Infinity, o3 = d(e2); !(n3 = o3()).done; ) {
        var i3 = n3.value, a3 = i3.size, l3 = i3.startIndex, s3 = i3.endIndex;
        if (r3 = Math.min(r3, l3), H(t2))
          t2 = z(t2, 0, a3);
        else {
          var u3 = A(t2, l3 - 1, s3 + 1);
          if (!u3.some(K(i3))) {
            for (var c3, m3 = false, f3 = false, p2 = d(u3); !(c3 = p2()).done; ) {
              var h2 = c3.value, g2 = h2.start, v2 = h2.end, S2 = h2.value;
              m3 ? (s3 >= g2 || a3 === S2) && (t2 = L(t2, g2)) : (f3 = S2 !== a3, m3 = true), v2 > s3 && s3 >= g2 && S2 !== a3 && (t2 = z(t2, s3 + 1, S2));
            }
            f3 && (t2 = z(t2, l3, a3));
          }
        }
      }
      return [t2, r3];
    }(a2, n2);
    a2 = c2[0], l2 = c2[1];
  }
  if (a2 === i2)
    return t;
  var m2 = J(t.offsetTree, l2, a2, o2), f2 = m2.offsetTree;
  return { sizeTree: a2, offsetTree: f2, lastIndex: m2.lastIndex, lastOffset: m2.lastOffset, lastSize: m2.lastSize, groupOffsetTree: r2.reduce(function(t2, e2) {
    return z(t2, e2, Q(e2, f2, o2));
  }, R()), groupIndices: r2 };
}
function Q(t, e, n2) {
  if (0 === e.length)
    return 0;
  var r2 = _(e, t, Y), o2 = t - r2.index, i2 = r2.size * o2 + (o2 - 1) * n2 + r2.offset;
  return i2 > 0 ? i2 + n2 : i2;
}
function X(t, e, n2) {
  if (function(t2) {
    return void 0 !== t2.groupIndex;
  }(t))
    return e.groupIndices[t.groupIndex] + 1;
  var r2 = tt("LAST" === t.index ? n2 : t.index, e);
  return Math.max(0, r2, Math.min(n2, r2));
}
function tt(t, e) {
  if (!et(e))
    return t;
  for (var n2 = 0; e.groupIndices[n2] <= t + n2; )
    n2++;
  return t + n2;
}
function et(t) {
  return !H(t.groupOffsetTree);
}
var nt = { offsetHeight: "height", offsetWidth: "width" };
var rt = system(function(t) {
  var n2 = t[0].log, r2 = t[1].recalcInProgress, o2 = stream(), i2 = stream(), a2 = statefulStreamFromEmitter(i2, 0), l2 = stream(), s2 = stream(), c2 = statefulStream(0), m2 = statefulStream([]), d2 = statefulStream(void 0), f2 = statefulStream(void 0), h2 = statefulStream(function(t2, e) {
    return T(t2, nt[e]);
  }), g2 = statefulStream(void 0), v2 = statefulStream(0), S2 = { offsetTree: [], sizeTree: R(), groupOffsetTree: R(), lastIndex: 0, lastOffset: 0, lastSize: 0, groupIndices: [] }, I2 = statefulStreamFromEmitter(pipe(o2, withLatestFrom(m2, n2, v2), scan($, S2), distinctUntilChanged()), S2);
  connect(pipe(m2, filter(function(t2) {
    return t2.length > 0;
  }), withLatestFrom(I2, v2), map(function(t2) {
    var e = t2[0], n3 = t2[1], r3 = t2[2], o3 = e.reduce(function(t3, e2, o4) {
      return z(t3, e2, Q(e2, n3.offsetTree, r3) || o4);
    }, R());
    return u({}, n3, { groupIndices: e, groupOffsetTree: o3 });
  })), I2), connect(pipe(i2, withLatestFrom(I2), filter(function(t2) {
    return t2[0] < t2[1].lastIndex;
  }), map(function(t2) {
    var e = t2[1];
    return [{ startIndex: t2[0], endIndex: e.lastIndex, size: e.lastSize }];
  })), o2), connect(d2, f2);
  var C2 = statefulStreamFromEmitter(pipe(d2, map(function(t2) {
    return void 0 === t2;
  })), true);
  connect(pipe(f2, filter(function(t2) {
    return void 0 !== t2 && H(getValue(I2).sizeTree);
  }), map(function(t2) {
    return [{ startIndex: 0, endIndex: 0, size: t2 }];
  })), o2);
  var w2 = streamFromEmitter(pipe(o2, withLatestFrom(I2), scan(function(t2, e) {
    var n3 = e[1];
    return { changed: n3 !== t2.sizes, sizes: n3 };
  }, { changed: false, sizes: S2 }), map(function(t2) {
    return t2.changed;
  })));
  subscribe(pipe(c2, scan(function(t2, e) {
    return { diff: t2.prev - e, prev: e };
  }, { diff: 0, prev: 0 }), map(function(t2) {
    return t2.diff;
  })), function(t2) {
    t2 > 0 ? (publish(r2, true), publish(l2, t2)) : t2 < 0 && publish(s2, t2);
  }), subscribe(pipe(c2, withLatestFrom(n2)), function(t2) {
    t2[0] < 0 && (0, t2[1])("`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value", { firstItemIndex: c2 }, p.ERROR);
  });
  var x2 = streamFromEmitter(l2);
  connect(pipe(l2, withLatestFrom(I2), map(function(t2) {
    var e = t2[0], n3 = t2[1];
    if (n3.groupIndices.length > 0)
      throw new Error("Virtuoso: prepending items does not work with groups");
    return F(n3.sizeTree).reduce(function(t3, n4) {
      var r3 = n4.k, o3 = n4.v;
      return { ranges: [].concat(t3.ranges, [{ startIndex: t3.prevIndex, endIndex: r3 + e - 1, size: t3.prevSize }]), prevIndex: r3 + e, prevSize: o3 };
    }, { ranges: [], prevIndex: 0, prevSize: n3.lastSize }).ranges;
  })), o2);
  var b2 = streamFromEmitter(pipe(s2, withLatestFrom(I2, v2), map(function(t2) {
    return Q(-t2[0], t2[1].offsetTree, t2[2]);
  })));
  return connect(pipe(s2, withLatestFrom(I2, v2), map(function(t2) {
    var e = t2[0], n3 = t2[1], r3 = t2[2];
    if (n3.groupIndices.length > 0)
      throw new Error("Virtuoso: shifting items does not work with groups");
    var o3 = F(n3.sizeTree).reduce(function(t3, n4) {
      var r4 = n4.v;
      return z(t3, Math.max(0, n4.k + e), r4);
    }, R());
    return u({}, n3, { sizeTree: o3 }, J(n3.offsetTree, 0, o3, r3));
  })), I2), { data: g2, totalCount: i2, sizeRanges: o2, groupIndices: m2, defaultItemSize: f2, fixedItemSize: d2, unshiftWith: l2, shiftWith: s2, shiftWithOffset: b2, beforeUnshiftWith: x2, firstItemIndex: c2, gap: v2, sizes: I2, listRefresh: w2, statefulTotalCount: a2, trackItemSizes: C2, itemSize: h2 };
}, tup(v, j), { singleton: true });
var ot = "undefined" != typeof document && "scrollBehavior" in document.documentElement.style;
function it(t) {
  var e = "number" == typeof t ? { index: t } : t;
  return e.align || (e.align = "start"), e.behavior && ot || (e.behavior = "auto"), e.offset || (e.offset = 0), e;
}
var at = system(function(t) {
  var n2 = t[0], r2 = n2.sizes, o2 = n2.totalCount, i2 = n2.listRefresh, a2 = n2.gap, l2 = t[1], s2 = l2.scrollingInProgress, u2 = l2.viewportHeight, c2 = l2.scrollTo, m2 = l2.smoothScrollTargetReached, d2 = l2.headerHeight, f2 = l2.footerHeight, h2 = t[2].log, g2 = stream(), v2 = statefulStream(0), S2 = null, I2 = null, C2 = null;
  function T2() {
    S2 && (S2(), S2 = null), C2 && (C2(), C2 = null), I2 && (clearTimeout(I2), I2 = null), publish(s2, false);
  }
  return connect(pipe(g2, withLatestFrom(r2, u2, o2, v2, d2, f2, h2), withLatestFrom(a2), map(function(t2) {
    var n3 = t2[0], r3 = n3[0], o3 = n3[1], a3 = n3[2], l3 = n3[3], u3 = n3[4], c3 = n3[5], d3 = n3[6], f3 = n3[7], h3 = t2[1], v3 = it(r3), w2 = v3.align, x2 = v3.behavior, b2 = v3.offset, y2 = l3 - 1, E2 = X(v3, o3, y2), H2 = Q(E2, o3.offsetTree, h3) + c3;
    "end" === w2 ? (H2 = H2 - a3 + k(o3.sizeTree, E2)[1], E2 === y2 && (H2 += d3)) : "center" === w2 ? H2 = H2 - a3 / 2 + k(o3.sizeTree, E2)[1] / 2 : H2 -= u3, b2 && (H2 += b2);
    var R2 = function(t3) {
      T2(), t3 ? (f3("retrying to scroll to", { location: r3 }, p.DEBUG), publish(g2, r3)) : f3("list did not change, scroll successful", {}, p.DEBUG);
    };
    if (T2(), "smooth" === x2) {
      var L2 = false;
      C2 = subscribe(i2, function(t3) {
        L2 = L2 || t3;
      }), S2 = handleNext(m2, function() {
        R2(L2);
      });
    } else
      S2 = handleNext(pipe(i2, function(t3) {
        var e = setTimeout(function() {
          t3(false);
        }, 150);
        return function(n4) {
          n4 && (t3(true), clearTimeout(e));
        };
      }), R2);
    return I2 = setTimeout(function() {
      T2();
    }, 1200), publish(s2, true), f3("scrolling from index to", { index: E2, top: H2, behavior: x2 }, p.DEBUG), { top: H2, behavior: x2 };
  })), c2), { scrollToIndex: g2, topListHeight: v2 };
}, tup(rt, b, v), { singleton: true });
var lt = "up";
var st = { atBottom: false, notAtBottomBecause: "NOT_SHOWING_LAST_ITEM", state: { offsetBottom: 0, scrollTop: 0, viewportHeight: 0, scrollHeight: 0 } };
var ut = system(function(t) {
  var n2 = t[0], r2 = n2.scrollContainerState, o2 = n2.scrollTop, i2 = n2.viewportHeight, a2 = n2.headerHeight, l2 = n2.footerHeight, s2 = n2.scrollBy, u2 = statefulStream(false), c2 = statefulStream(true), m2 = stream(), d2 = stream(), f2 = statefulStream(4), p2 = statefulStream(0), h2 = statefulStreamFromEmitter(pipe(merge(pipe(duc(o2), skip(1), mapTo(true)), pipe(duc(o2), skip(1), mapTo(false), debounceTime(100))), distinctUntilChanged()), false), g2 = statefulStreamFromEmitter(pipe(merge(pipe(s2, mapTo(true)), pipe(s2, mapTo(false), debounceTime(200))), distinctUntilChanged()), false);
  connect(pipe(combineLatest(duc(o2), duc(p2)), map(function(t2) {
    return t2[0] <= t2[1];
  }), distinctUntilChanged()), c2), connect(pipe(c2, throttleTime(50)), d2);
  var v2 = streamFromEmitter(pipe(combineLatest(r2, duc(i2), duc(a2), duc(l2), duc(f2)), scan(function(t2, e) {
    var n3, r3, o3 = e[0], i3 = o3.scrollTop, a3 = o3.scrollHeight, l3 = e[1], s3 = { viewportHeight: l3, scrollTop: i3, scrollHeight: a3 };
    return i3 + l3 - a3 > -e[4] ? (i3 > t2.state.scrollTop ? (n3 = "SCROLLED_DOWN", r3 = t2.state.scrollTop - i3) : (n3 = "SIZE_DECREASED", r3 = t2.state.scrollTop - i3 || t2.scrollTopDelta), { atBottom: true, state: s3, atBottomBecause: n3, scrollTopDelta: r3 }) : { atBottom: false, notAtBottomBecause: s3.scrollHeight > t2.state.scrollHeight ? "SIZE_INCREASED" : l3 < t2.state.viewportHeight ? "VIEWPORT_HEIGHT_DECREASING" : i3 < t2.state.scrollTop ? "SCROLLING_UPWARDS" : "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", state: s3 };
  }, st), distinctUntilChanged(function(t2, e) {
    return t2 && t2.atBottom === e.atBottom;
  }))), S2 = statefulStreamFromEmitter(pipe(r2, scan(function(t2, e) {
    var n3 = e.scrollTop, r3 = e.scrollHeight, o3 = e.viewportHeight;
    return w(t2.scrollHeight, r3) ? { scrollTop: n3, scrollHeight: r3, jump: 0, changed: false } : t2.scrollTop !== n3 && r3 - (n3 + o3) < 1 ? { scrollHeight: r3, scrollTop: n3, jump: t2.scrollTop - n3, changed: true } : { scrollHeight: r3, scrollTop: n3, jump: 0, changed: true };
  }, { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }), filter(function(t2) {
    return t2.changed;
  }), map(function(t2) {
    return t2.jump;
  })), 0);
  connect(pipe(v2, map(function(t2) {
    return t2.atBottom;
  })), u2), connect(pipe(u2, throttleTime(50)), m2);
  var I2 = statefulStream("down");
  connect(pipe(r2, map(function(t2) {
    return t2.scrollTop;
  }), distinctUntilChanged(), scan(function(t2, n3) {
    return getValue(g2) ? { direction: t2.direction, prevScrollTop: n3 } : { direction: n3 < t2.prevScrollTop ? lt : "down", prevScrollTop: n3 };
  }, { direction: "down", prevScrollTop: 0 }), map(function(t2) {
    return t2.direction;
  })), I2), connect(pipe(r2, throttleTime(50), mapTo("none")), I2);
  var C2 = statefulStream(0);
  return connect(pipe(h2, filter(function(t2) {
    return !t2;
  }), mapTo(0)), C2), connect(pipe(o2, throttleTime(100), withLatestFrom(h2), filter(function(t2) {
    return !!t2[1];
  }), scan(function(t2, e) {
    return [t2[1], e[0]];
  }, [0, 0]), map(function(t2) {
    return t2[1] - t2[0];
  })), C2), { isScrolling: h2, isAtTop: c2, isAtBottom: u2, atBottomState: v2, atTopStateChange: d2, atBottomStateChange: m2, scrollDirection: I2, atBottomThreshold: f2, atTopThreshold: p2, scrollVelocity: C2, lastJumpDueToItemResize: S2 };
}, tup(b));
var ct = system(function(t) {
  var n2 = t[0].log, r2 = statefulStream(false), o2 = streamFromEmitter(pipe(r2, filter(function(t2) {
    return t2;
  }), distinctUntilChanged()));
  return subscribe(r2, function(t2) {
    t2 && getValue(n2)("props updated", {}, p.DEBUG);
  }), { propsReady: r2, didMount: o2 };
}, tup(v), { singleton: true });
var mt = system(function(t) {
  var n2 = t[0], r2 = n2.sizes, o2 = n2.listRefresh, i2 = n2.defaultItemSize, a2 = t[1].scrollTop, l2 = t[2].scrollToIndex, s2 = t[3].didMount, u2 = statefulStream(true), c2 = statefulStream(0);
  return connect(pipe(s2, withLatestFrom(c2), filter(function(t2) {
    return !!t2[1];
  }), mapTo(false)), u2), subscribe(pipe(combineLatest(o2, s2), withLatestFrom(u2, r2, i2), filter(function(t2) {
    var e = t2[1], n3 = t2[3];
    return t2[0][1] && (!H(t2[2].sizeTree) || void 0 !== n3) && !e;
  }), withLatestFrom(c2)), function(t2) {
    var n3 = t2[1];
    setTimeout(function() {
      handleNext(a2, function() {
        publish(u2, true);
      }), publish(l2, n3);
    });
  }), { scrolledToInitialItem: u2, initialTopMostItemIndex: c2 };
}, tup(rt, b, at, ct), { singleton: true });
function dt(t) {
  return !!t && ("smooth" === t ? "smooth" : "auto");
}
var ft = system(function(t) {
  var n2 = t[0], r2 = n2.totalCount, o2 = n2.listRefresh, i2 = t[1], a2 = i2.isAtBottom, l2 = i2.atBottomState, s2 = t[2].scrollToIndex, u2 = t[3].scrolledToInitialItem, c2 = t[4], m2 = c2.propsReady, d2 = c2.didMount, f2 = t[5].log, h2 = t[6].scrollingInProgress, g2 = statefulStream(false), v2 = stream(), S2 = null;
  function I2(t2) {
    publish(s2, { index: "LAST", align: "end", behavior: t2 });
  }
  function C2(t2) {
    var n3 = handleNext(l2, function(n4) {
      !t2 || n4.atBottom || "SIZE_INCREASED" !== n4.notAtBottomBecause || S2 || (getValue(f2)("scrolling to bottom due to increased size", {}, p.DEBUG), I2("auto"));
    });
    setTimeout(n3, 100);
  }
  return subscribe(pipe(combineLatest(pipe(duc(r2), skip(1)), d2), withLatestFrom(duc(g2), a2, u2, h2), map(function(t2) {
    var e = t2[0], n3 = e[0], r3 = e[1] && t2[3], o3 = "auto";
    return r3 && (o3 = function(t3, e2) {
      return "function" == typeof t3 ? dt(t3(e2)) : e2 && dt(t3);
    }(t2[1], t2[2] || t2[4]), r3 = r3 && !!o3), { totalCount: n3, shouldFollow: r3, followOutputBehavior: o3 };
  }), filter(function(t2) {
    return t2.shouldFollow;
  })), function(t2) {
    var n3 = t2.totalCount, r3 = t2.followOutputBehavior;
    S2 && (S2(), S2 = null), S2 = handleNext(o2, function() {
      getValue(f2)("following output to ", { totalCount: n3 }, p.DEBUG), I2(r3), S2 = null;
    });
  }), subscribe(pipe(combineLatest(duc(g2), r2, m2), filter(function(t2) {
    return t2[0] && t2[2];
  }), scan(function(t2, e) {
    var n3 = e[1];
    return { refreshed: t2.value === n3, value: n3 };
  }, { refreshed: false, value: 0 }), filter(function(t2) {
    return t2.refreshed;
  }), withLatestFrom(g2, r2)), function(t2) {
    C2(false !== t2[1]);
  }), subscribe(v2, function() {
    C2(false !== getValue(g2));
  }), subscribe(combineLatest(duc(g2), l2), function(t2) {
    var e = t2[1];
    t2[0] && !e.atBottom && "VIEWPORT_HEIGHT_DECREASING" === e.notAtBottomBecause && I2("auto");
  }), { followOutput: g2, autoscrollToBottom: v2 };
}, tup(rt, ut, at, mt, ct, v, b));
function pt(t) {
  return t.reduce(function(t2, e) {
    return t2.groupIndices.push(t2.totalCount), t2.totalCount += e + 1, t2;
  }, { totalCount: 0, groupIndices: [] });
}
var ht = system(function(t) {
  var n2 = t[0], r2 = n2.totalCount, o2 = n2.groupIndices, i2 = n2.sizes, a2 = t[1], l2 = a2.scrollTop, s2 = a2.headerHeight, u2 = stream(), c2 = stream(), m2 = streamFromEmitter(pipe(u2, map(pt)));
  return connect(pipe(m2, map(function(t2) {
    return t2.totalCount;
  })), r2), connect(pipe(m2, map(function(t2) {
    return t2.groupIndices;
  })), o2), connect(pipe(combineLatest(l2, i2, s2), filter(function(t2) {
    return et(t2[1]);
  }), map(function(t2) {
    return k(t2[1].groupOffsetTree, Math.max(t2[0] - t2[2], 0), "v")[0];
  }), distinctUntilChanged(), map(function(t2) {
    return [t2];
  })), c2), { groupCounts: u2, topItemsIndexes: c2 };
}, tup(rt, b));
function gt(t, e) {
  return !(!t || t[0] !== e[0] || t[1] !== e[1]);
}
function vt(t, e) {
  return !(!t || t.startIndex !== e.startIndex || t.endIndex !== e.endIndex);
}
function St(t, e, n2) {
  return "number" == typeof t ? n2 === lt && "top" === e || "down" === n2 && "bottom" === e ? t : 0 : n2 === lt ? "top" === e ? t.main : t.reverse : "bottom" === e ? t.main : t.reverse;
}
function It(t, e) {
  return "number" == typeof t ? t : t[e] || 0;
}
var Ct = system(function(t) {
  var n2 = t[0], r2 = n2.scrollTop, o2 = n2.viewportHeight, i2 = n2.deviation, a2 = n2.headerHeight, l2 = n2.fixedHeaderHeight, s2 = stream(), u2 = statefulStream(0), c2 = statefulStream(0), m2 = statefulStream(0), d2 = statefulStreamFromEmitter(pipe(combineLatest(duc(r2), duc(o2), duc(a2), duc(s2, gt), duc(m2), duc(u2), duc(l2), duc(i2), duc(c2)), map(function(t2) {
    var e = t2[0], n3 = t2[1], r3 = t2[2], o3 = t2[3], i3 = o3[0], a3 = o3[1], l3 = t2[4], s3 = t2[6], u3 = t2[7], c3 = t2[8], m3 = e - u3, d3 = t2[5] + s3, f2 = Math.max(r3 - m3, 0), p2 = "none", h2 = It(c3, "top"), g2 = It(c3, "bottom");
    return i3 -= u3, a3 += r3 + s3, (i3 += r3 + s3) > e + d3 - h2 && (p2 = lt), (a3 -= u3) < e - f2 + n3 + g2 && (p2 = "down"), "none" !== p2 ? [Math.max(m3 - r3 - St(l3, "top", p2) - h2, 0), m3 - f2 - s3 + n3 + St(l3, "bottom", p2) + g2] : null;
  }), filter(function(t2) {
    return null != t2;
  }), distinctUntilChanged(gt)), [0, 0]);
  return { listBoundary: s2, overscan: m2, topListHeight: u2, increaseViewportBy: c2, visibleRange: d2 };
}, tup(b), { singleton: true });
var Tt = { items: [], topItems: [], offsetTop: 0, offsetBottom: 0, top: 0, bottom: 0, topListHeight: 0, totalCount: 0, firstItemIndex: 0 };
function wt(t, e, n2) {
  if (0 === t.length)
    return [];
  if (!et(e))
    return t.map(function(t2) {
      return u({}, t2, { index: t2.index + n2, originalIndex: t2.index });
    });
  for (var r2, o2 = [], i2 = A(e.groupOffsetTree, t[0].index, t[t.length - 1].index), a2 = void 0, l2 = 0, s2 = d(t); !(r2 = s2()).done; ) {
    var c2 = r2.value;
    (!a2 || a2.end < c2.index) && (a2 = i2.shift(), l2 = e.groupIndices.indexOf(a2.start)), o2.push(u({}, c2.index === a2.start ? { type: "group", index: l2 } : { index: c2.index - (l2 + 1) + n2, groupIndex: l2 }, { size: c2.size, offset: c2.offset, originalIndex: c2.index, data: c2.data }));
  }
  return o2;
}
function xt(t, e, n2, r2, o2, i2) {
  var a2 = 0, l2 = 0;
  if (t.length > 0) {
    a2 = t[0].offset;
    var s2 = t[t.length - 1];
    l2 = s2.offset + s2.size;
  }
  var u2 = n2 - o2.lastIndex, c2 = a2, m2 = o2.lastOffset + u2 * o2.lastSize + (u2 - 1) * r2 - l2;
  return { items: wt(t, o2, i2), topItems: wt(e, o2, i2), topListHeight: e.reduce(function(t2, e2) {
    return e2.size + t2;
  }, 0), offsetTop: a2, offsetBottom: m2, top: c2, bottom: l2, totalCount: n2, firstItemIndex: i2 };
}
var bt = system(function(t) {
  var n2 = t[0], r2 = n2.sizes, o2 = n2.totalCount, i2 = n2.data, a2 = n2.firstItemIndex, l2 = n2.gap, s2 = t[1], c2 = t[2], m2 = c2.visibleRange, f2 = c2.listBoundary, p2 = c2.topListHeight, h2 = t[3], g2 = h2.scrolledToInitialItem, v2 = h2.initialTopMostItemIndex, S2 = t[4].topListHeight, I2 = t[5], C2 = t[6].didMount, T2 = t[7].recalcInProgress, w2 = statefulStream([]), x2 = stream();
  connect(s2.topItemsIndexes, w2);
  var b2 = statefulStreamFromEmitter(pipe(combineLatest(C2, T2, duc(m2, gt), duc(o2), duc(r2), duc(v2), g2, duc(w2), duc(a2), duc(l2), i2), filter(function(t2) {
    return t2[0] && !t2[1];
  }), map(function(t2) {
    var n3 = t2[2], r3 = n3[0], o3 = n3[1], i3 = t2[3], a3 = t2[5], l3 = t2[6], s3 = t2[7], c3 = t2[8], m3 = t2[9], f3 = t2[10], p3 = t2[4], h3 = p3.sizeTree, g3 = p3.offsetTree;
    if (0 === i3 || 0 === r3 && 0 === o3)
      return u({}, Tt, { totalCount: i3 });
    if (H(h3))
      return xt(function(t3, e, n4) {
        if (et(e)) {
          var r4 = tt(t3, e);
          return [{ index: k(e.groupOffsetTree, r4)[0], size: 0, offset: 0 }, { index: r4, size: 0, offset: 0, data: n4 && n4[0] }];
        }
        return [{ index: t3, size: 0, offset: 0, data: n4 && n4[0] }];
      }(function(t3, e) {
        return "number" == typeof t3 ? t3 : "LAST" === t3.index ? e - 1 : t3.index;
      }(a3, i3), p3, f3), [], i3, m3, p3, c3);
    var v3 = [];
    if (s3.length > 0)
      for (var S3, I3 = s3[0], C3 = s3[s3.length - 1], T3 = 0, w3 = d(A(h3, I3, C3)); !(S3 = w3()).done; )
        for (var x3 = S3.value, b3 = x3.value, y2 = Math.max(x3.start, I3), E2 = Math.min(x3.end, C3), R2 = y2; R2 <= E2; R2++)
          v3.push({ index: R2, size: b3, offset: T3, data: f3 && f3[R2] }), T3 += b3;
    if (!l3)
      return xt([], v3, i3, m3, p3, c3);
    var L2 = s3.length > 0 ? s3[s3.length - 1] + 1 : 0, z2 = function(t3, e, n4, r4) {
      return void 0 === r4 && (r4 = 0), r4 > 0 && (e = Math.max(e, _(t3, r4, Y).offset)), W((i4 = n4, l4 = G(o4 = t3, e, a4 = q), s4 = G(o4, i4, a4, l4), o4.slice(l4, s4 + 1)), Z);
      var o4, i4, a4, l4, s4;
    }(g3, r3, o3, L2);
    if (0 === z2.length)
      return null;
    var B2 = i3 - 1;
    return xt(tap([], function(t3) {
      for (var e, n4 = d(z2); !(e = n4()).done; ) {
        var i4 = e.value, a4 = i4.value, l4 = a4.offset, s4 = i4.start, u2 = a4.size;
        if (a4.offset < r3) {
          var c4 = (s4 += Math.floor((r3 - a4.offset + m3) / (u2 + m3))) - i4.start;
          l4 += c4 * u2 + c4 * m3;
        }
        s4 < L2 && (l4 += (L2 - s4) * u2, s4 = L2);
        for (var p4 = Math.min(i4.end, B2), h4 = s4; h4 <= p4 && !(l4 >= o3); h4++)
          t3.push({ index: h4, size: u2, offset: l4, data: f3 && f3[h4] }), l4 += u2 + m3;
      }
    }), v3, i3, m3, p3, c3);
  }), filter(function(t2) {
    return null !== t2;
  }), distinctUntilChanged()), Tt);
  return connect(pipe(i2, filter(function(t2) {
    return void 0 !== t2;
  }), map(function(t2) {
    return t2.length;
  })), o2), connect(pipe(b2, map(function(t2) {
    return t2.topListHeight;
  })), S2), connect(S2, p2), connect(pipe(b2, map(function(t2) {
    return [t2.top, t2.bottom];
  })), f2), connect(pipe(b2, map(function(t2) {
    return t2.items;
  })), x2), u({ listState: b2, topItemsIndexes: w2, endReached: streamFromEmitter(pipe(b2, filter(function(t2) {
    return t2.items.length > 0;
  }), withLatestFrom(o2, i2), filter(function(t2) {
    var e = t2[0].items;
    return e[e.length - 1].originalIndex === t2[1] - 1;
  }), map(function(t2) {
    return [t2[1] - 1, t2[2]];
  }), distinctUntilChanged(gt), map(function(t2) {
    return t2[0];
  }))), startReached: streamFromEmitter(pipe(b2, throttleTime(200), filter(function(t2) {
    var e = t2.items;
    return e.length > 0 && e[0].originalIndex === t2.topItems.length;
  }), map(function(t2) {
    return t2.items[0].index;
  }), distinctUntilChanged())), rangeChanged: streamFromEmitter(pipe(b2, filter(function(t2) {
    return t2.items.length > 0;
  }), map(function(t2) {
    for (var e = t2.items, n3 = 0, r3 = e.length - 1; "group" === e[n3].type && n3 < r3; )
      n3++;
    for (; "group" === e[r3].type && r3 > n3; )
      r3--;
    return { startIndex: e[n3].index, endIndex: e[r3].index };
  }), distinctUntilChanged(vt))), itemsRendered: x2 }, I2);
}, tup(rt, ht, Ct, mt, at, ut, ct, j), { singleton: true });
var yt = system(function(t) {
  var n2 = t[0], r2 = n2.sizes, o2 = n2.firstItemIndex, i2 = n2.data, a2 = n2.gap, l2 = t[1].listState, s2 = t[2].didMount, u2 = statefulStream(0);
  return connect(pipe(s2, withLatestFrom(u2), filter(function(t2) {
    return 0 !== t2[1];
  }), withLatestFrom(r2, o2, a2, i2), map(function(t2) {
    var e = t2[0][1], n3 = t2[1], r3 = t2[2], o3 = t2[3], i3 = t2[4], a3 = void 0 === i3 ? [] : i3, l3 = 0;
    if (n3.groupIndices.length > 0)
      for (var s3, u3 = d(n3.groupIndices); !((s3 = u3()).done || s3.value - l3 >= e); )
        l3++;
    var c2 = e + l3;
    return xt(Array.from({ length: c2 }).map(function(t3, e2) {
      return { index: e2, size: 0, offset: 0, data: a3[e2] };
    }), [], c2, o3, n3, r3);
  })), l2), { initialItemCount: u2 };
}, tup(rt, bt, ct), { singleton: true });
var Et = system(function(t) {
  var n2 = t[0].scrollVelocity, r2 = statefulStream(false), o2 = stream(), i2 = statefulStream(false);
  return connect(pipe(n2, withLatestFrom(i2, r2, o2), filter(function(t2) {
    return !!t2[1];
  }), map(function(t2) {
    var e = t2[0], n3 = t2[1], r3 = t2[2], o3 = t2[3], i3 = n3.enter;
    if (r3) {
      if ((0, n3.exit)(e, o3))
        return false;
    } else if (i3(e, o3))
      return true;
    return r3;
  }), distinctUntilChanged()), r2), subscribe(pipe(combineLatest(r2, n2, o2), withLatestFrom(i2)), function(t2) {
    var e = t2[0], n3 = t2[1];
    return e[0] && n3 && n3.change && n3.change(e[1], e[2]);
  }), { isSeeking: r2, scrollSeekConfiguration: i2, scrollVelocity: n2, scrollSeekRangeChanged: o2 };
}, tup(ut), { singleton: true });
var Ht = system(function(t) {
  var n2 = t[0].topItemsIndexes, r2 = statefulStream(0);
  return connect(pipe(r2, filter(function(t2) {
    return t2 > 0;
  }), map(function(t2) {
    return Array.from({ length: t2 }).map(function(t3, e) {
      return e;
    });
  })), n2), { topItemCount: r2 };
}, tup(bt));
var Rt = system(function(t) {
  var n2 = t[0], r2 = n2.footerHeight, o2 = n2.headerHeight, i2 = n2.fixedHeaderHeight, a2 = t[1].listState, l2 = stream(), s2 = statefulStreamFromEmitter(pipe(combineLatest(r2, o2, i2, a2), map(function(t2) {
    var e = t2[3];
    return t2[0] + t2[1] + t2[2] + e.offsetBottom + e.bottom;
  })), 0);
  return connect(duc(s2), l2), { totalListHeight: s2, totalListHeightChanged: l2 };
}, tup(b, bt), { singleton: true });
function Lt(t) {
  var e, n2 = false;
  return function() {
    return n2 || (n2 = true, e = t()), e;
  };
}
var kt = Lt(function() {
  return /iP(ad|hone|od).+Version\/[\d.]+.*Safari/i.test(navigator.userAgent);
});
var zt = system(function(t) {
  var n2 = t[0], r2 = n2.scrollBy, o2 = n2.scrollTop, i2 = n2.deviation, a2 = n2.scrollingInProgress, l2 = t[1], s2 = l2.isScrolling, u2 = l2.isAtBottom, c2 = l2.scrollDirection, m2 = t[3], d2 = m2.beforeUnshiftWith, f2 = m2.shiftWithOffset, h2 = m2.sizes, g2 = m2.gap, v2 = t[4].log, S2 = t[5].recalcInProgress, I2 = streamFromEmitter(pipe(t[2].listState, withLatestFrom(l2.lastJumpDueToItemResize), scan(function(t2, e) {
    var n3 = t2[1], r3 = e[0], o3 = r3.items, i3 = r3.totalCount, a3 = r3.bottom + r3.offsetBottom, l3 = 0;
    return t2[2] === i3 && n3.length > 0 && o3.length > 0 && (0 === o3[0].originalIndex && 0 === n3[0].originalIndex || 0 != (l3 = a3 - t2[3]) && (l3 += e[1])), [l3, o3, i3, a3];
  }, [0, [], 0, 0]), filter(function(t2) {
    return 0 !== t2[0];
  }), withLatestFrom(o2, c2, a2, u2, v2), filter(function(t2) {
    return !t2[3] && 0 !== t2[1] && t2[2] === lt;
  }), map(function(t2) {
    var e = t2[0][0];
    return (0, t2[5])("Upward scrolling compensation", { amount: e }, p.DEBUG), e;
  })));
  function C2(t2) {
    t2 > 0 ? (publish(r2, { top: -t2, behavior: "auto" }), publish(i2, 0)) : (publish(i2, 0), publish(r2, { top: -t2, behavior: "auto" }));
  }
  return subscribe(pipe(I2, withLatestFrom(i2, s2)), function(t2) {
    var n3 = t2[0], r3 = t2[1];
    t2[2] && kt() ? publish(i2, r3 - n3) : C2(-n3);
  }), subscribe(pipe(combineLatest(statefulStreamFromEmitter(s2, false), i2, S2), filter(function(t2) {
    return !t2[0] && !t2[2] && 0 !== t2[1];
  }), map(function(t2) {
    return t2[1];
  }), throttleTime(1)), C2), connect(pipe(f2, map(function(t2) {
    return { top: -t2 };
  })), r2), subscribe(pipe(d2, withLatestFrom(h2, g2), map(function(t2) {
    var e = t2[0];
    return e * t2[1].lastSize + e * t2[2];
  })), function(t2) {
    publish(i2, t2), requestAnimationFrame(function() {
      publish(r2, { top: t2 }), requestAnimationFrame(function() {
        publish(i2, 0), publish(S2, false);
      });
    });
  }), { deviation: i2 };
}, tup(b, ut, bt, rt, v, j));
var Bt = system(function(t) {
  var n2 = t[0].totalListHeight, r2 = t[1].didMount, o2 = t[2].scrollTo, i2 = statefulStream(0);
  return subscribe(pipe(r2, withLatestFrom(i2), filter(function(t2) {
    return 0 !== t2[1];
  }), map(function(t2) {
    return { top: t2[1] };
  })), function(t2) {
    handleNext(pipe(n2, filter(function(t3) {
      return 0 !== t3;
    })), function() {
      setTimeout(function() {
        publish(o2, t2);
      });
    });
  }), { initialScrollTop: i2 };
}, tup(Rt, ct, b), { singleton: true });
var Ft = system(function(t) {
  var n2 = t[0].viewportHeight, r2 = t[1].totalListHeight, o2 = statefulStream(false);
  return { alignToBottom: o2, paddingTopAddition: statefulStreamFromEmitter(pipe(combineLatest(o2, n2, r2), filter(function(t2) {
    return t2[0];
  }), map(function(t2) {
    return Math.max(0, t2[1] - t2[2]);
  }), distinctUntilChanged()), 0) };
}, tup(b, Rt), { singleton: true });
var Pt = system(function(t) {
  var n2 = t[0], r2 = n2.scrollTo, o2 = n2.scrollContainerState, i2 = stream(), a2 = stream(), l2 = stream(), s2 = statefulStream(false), c2 = statefulStream(void 0);
  return connect(pipe(combineLatest(i2, a2), map(function(t2) {
    var e = t2[0], n3 = e.viewportHeight, r3 = e.scrollHeight;
    return { scrollTop: Math.max(0, e.scrollTop - t2[1].offsetTop), scrollHeight: r3, viewportHeight: n3 };
  })), o2), connect(pipe(r2, withLatestFrom(a2), map(function(t2) {
    var e = t2[0];
    return u({}, e, { top: e.top + t2[1].offsetTop });
  })), l2), { useWindowScroll: s2, customScrollParent: c2, windowScrollContainerState: i2, windowViewportRect: a2, windowScrollTo: l2 };
}, tup(b));
var Ot = ["done", "behavior", "align"];
var Mt = system(function(t) {
  var n2 = t[0], r2 = n2.sizes, o2 = n2.totalCount, i2 = n2.gap, a2 = t[1], l2 = a2.scrollTop, s2 = a2.viewportHeight, m2 = a2.headerHeight, d2 = a2.scrollingInProgress, f2 = t[2].scrollToIndex, p2 = stream();
  return connect(pipe(p2, withLatestFrom(r2, s2, o2, m2, l2, i2), map(function(t2) {
    var n3 = t2[0], r3 = t2[1], o3 = t2[2], i3 = t2[3], a3 = t2[4], l3 = t2[5], s3 = t2[6], m3 = n3.done, f3 = n3.behavior, p3 = n3.align, h2 = c(n3, Ot), g2 = null, v2 = X(n3, r3, i3 - 1), S2 = Q(v2, r3.offsetTree, s3) + a3;
    return S2 < l3 ? g2 = u({}, h2, { behavior: f3, align: null != p3 ? p3 : "start" }) : S2 + k(r3.sizeTree, v2)[1] > l3 + o3 && (g2 = u({}, h2, { behavior: f3, align: null != p3 ? p3 : "end" })), g2 ? m3 && handleNext(pipe(d2, skip(1), filter(function(t3) {
      return false === t3;
    })), m3) : m3 && m3(), g2;
  }), filter(function(t2) {
    return null !== t2;
  })), f2), { scrollIntoView: p2 };
}, tup(rt, b, at, bt, v), { singleton: true });
var Vt = ["listState", "topItemsIndexes"];
var Ut = system(function(t) {
  return u({}, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
}, tup(Ct, yt, ct, Et, Rt, Bt, Ft, Pt, Mt));
var At = system(function(t) {
  var n2 = t[0], r2 = n2.totalCount, o2 = n2.sizeRanges, i2 = n2.fixedItemSize, a2 = n2.defaultItemSize, l2 = n2.trackItemSizes, s2 = n2.itemSize, m2 = n2.data, d2 = n2.firstItemIndex, f2 = n2.groupIndices, p2 = n2.statefulTotalCount, h2 = n2.gap, g2 = t[1], v2 = g2.initialTopMostItemIndex, S2 = g2.scrolledToInitialItem, I2 = t[2], C2 = t[3], T2 = t[4], w2 = T2.listState, x2 = T2.topItemsIndexes, b2 = c(T2, Vt), y2 = t[5].scrollToIndex, E2 = t[7].topItemCount, H2 = t[8].groupCounts, R2 = t[9], L2 = t[10];
  return connect(b2.rangeChanged, R2.scrollSeekRangeChanged), connect(pipe(R2.windowViewportRect, map(function(t2) {
    return t2.visibleHeight;
  })), I2.viewportHeight), u({ totalCount: r2, data: m2, firstItemIndex: d2, sizeRanges: o2, initialTopMostItemIndex: v2, scrolledToInitialItem: S2, topItemsIndexes: x2, topItemCount: E2, groupCounts: H2, fixedItemHeight: i2, defaultItemHeight: a2, gap: h2 }, C2, { statefulTotalCount: p2, listState: w2, scrollToIndex: y2, trackItemSizes: l2, itemSize: s2, groupIndices: f2 }, b2, R2, I2, L2);
}, tup(rt, mt, b, ft, bt, at, zt, Ht, ht, Ut, v));
var Wt = Lt(function() {
  if ("undefined" == typeof document)
    return "sticky";
  var t = document.createElement("div");
  return t.style.position = "-webkit-sticky", "-webkit-sticky" === t.style.position ? "-webkit-sticky" : "sticky";
});
function Nt(t, e) {
  var n2 = (0, import_react2.useRef)(null), r2 = (0, import_react2.useCallback)(function(r3) {
    if (null !== r3 && r3.offsetParent) {
      var o2, i2, a2 = r3.getBoundingClientRect(), l3 = a2.width;
      if (e) {
        var s3 = e.getBoundingClientRect(), u3 = a2.top - s3.top;
        o2 = s3.height - Math.max(0, u3), i2 = u3 + e.scrollTop;
      } else
        o2 = window.innerHeight - Math.max(0, a2.top), i2 = a2.top + window.pageYOffset;
      n2.current = { offsetTop: i2, visibleHeight: o2, visibleWidth: l3 }, t(n2.current);
    }
  }, [t, e]), l2 = S(r2), s2 = l2.callbackRef, u2 = l2.ref, c2 = (0, import_react2.useCallback)(function() {
    r2(u2.current);
  }, [r2, u2]);
  return (0, import_react2.useEffect)(function() {
    if (e) {
      e.addEventListener("scroll", c2);
      var t2 = new ResizeObserver(c2);
      return t2.observe(e), function() {
        e.removeEventListener("scroll", c2), t2.unobserve(e);
      };
    }
    return window.addEventListener("scroll", c2), window.addEventListener("resize", c2), function() {
      window.removeEventListener("scroll", c2), window.removeEventListener("resize", c2);
    };
  }, [c2, e]), s2;
}
var Dt = ["placeholder"];
var Gt = ["style", "children"];
var _t = ["style", "children"];
function jt(t) {
  return t;
}
var Kt = system(function() {
  var t = statefulStream(function(t2) {
    return "Item " + t2;
  }), n2 = statefulStream(null), r2 = statefulStream(function(t2) {
    return "Group " + t2;
  }), o2 = statefulStream({}), i2 = statefulStream(jt), a2 = statefulStream("div"), l2 = statefulStream(noop), s2 = function(t2, n3) {
    return void 0 === n3 && (n3 = null), statefulStreamFromEmitter(pipe(o2, map(function(e) {
      return e[t2];
    }), distinctUntilChanged()), n3);
  };
  return { context: n2, itemContent: t, groupContent: r2, components: o2, computeItemKey: i2, headerFooterTag: a2, scrollerRef: l2, FooterComponent: s2("Footer"), HeaderComponent: s2("Header"), TopItemListComponent: s2("TopItemList"), ListComponent: s2("List", "div"), ItemComponent: s2("Item", "div"), GroupComponent: s2("Group", "div"), ScrollerComponent: s2("Scroller", "div"), EmptyPlaceholder: s2("EmptyPlaceholder"), ScrollSeekPlaceholder: s2("ScrollSeekPlaceholder") };
});
function Yt(t, n2) {
  var r2 = stream();
  return subscribe(r2, function() {
    return console.warn("react-virtuoso: You are using a deprecated property. " + n2, "color: red;", "color: inherit;", "color: blue;");
  }), connect(r2, t), r2;
}
var qt = system(function(t) {
  var n2 = t[0], r2 = t[1], o2 = { item: Yt(r2.itemContent, "Rename the %citem%c prop to %citemContent."), group: Yt(r2.groupContent, "Rename the %cgroup%c prop to %cgroupContent."), topItems: Yt(n2.topItemCount, "Rename the %ctopItems%c prop to %ctopItemCount."), itemHeight: Yt(n2.fixedItemHeight, "Rename the %citemHeight%c prop to %cfixedItemHeight."), scrollingStateChange: Yt(n2.isScrolling, "Rename the %cscrollingStateChange%c prop to %cisScrolling."), adjustForPrependedItems: stream(), maxHeightCacheSize: stream(), footer: stream(), header: stream(), HeaderContainer: stream(), FooterContainer: stream(), ItemContainer: stream(), ScrollContainer: stream(), GroupContainer: stream(), ListContainer: stream(), emptyComponent: stream(), scrollSeek: stream() };
  function i2(t2, n3, o3) {
    connect(pipe(t2, withLatestFrom(r2.components), map(function(t3) {
      var e, r3 = t3[0], i3 = t3[1];
      return console.warn("react-virtuoso: " + o3 + " property is deprecated. Pass components." + n3 + " instead."), u({}, i3, ((e = {})[n3] = r3, e));
    })), r2.components);
  }
  return subscribe(o2.adjustForPrependedItems, function() {
    console.warn("react-virtuoso: adjustForPrependedItems is no longer supported. Use the firstItemIndex property instead - https://virtuoso.dev/prepend-items.", "color: red;", "color: inherit;", "color: blue;");
  }), subscribe(o2.maxHeightCacheSize, function() {
    console.warn("react-virtuoso: maxHeightCacheSize is no longer necessary. Setting it has no effect - remove it from your code.");
  }), subscribe(o2.HeaderContainer, function() {
    console.warn("react-virtuoso: HeaderContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the header component and pass components.Header to change its contents.");
  }), subscribe(o2.FooterContainer, function() {
    console.warn("react-virtuoso: FooterContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the footer component and pass components.Footer to change its contents.");
  }), subscribe(o2.scrollSeek, function(t2) {
    var o3 = t2.placeholder, i3 = c(t2, Dt);
    console.warn("react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead."), publish(r2.components, u({}, getValue(r2.components), { ScrollSeekPlaceholder: o3 })), publish(n2.scrollSeekConfiguration, i3);
  }), i2(o2.footer, "Footer", "footer"), i2(o2.header, "Header", "header"), i2(o2.ItemContainer, "Item", "ItemContainer"), i2(o2.ListContainer, "List", "ListContainer"), i2(o2.ScrollContainer, "Scroller", "ScrollContainer"), i2(o2.emptyComponent, "EmptyPlaceholder", "emptyComponent"), i2(o2.GroupContainer, "Group", "GroupContainer"), u({}, n2, r2, o2);
}, tup(At, Kt));
var Zt = function(t) {
  return n.createElement("div", { style: { height: t.height } });
};
var Jt = { position: Wt(), zIndex: 1, overflowAnchor: "none" };
var $t = { overflowAnchor: "none" };
var Qt = n.memo(function(t) {
  var r2 = t.showTopList, o2 = void 0 !== r2 && r2, i2 = fe("listState"), a2 = de("sizeRanges"), s2 = fe("useWindowScroll"), c2 = fe("customScrollParent"), m2 = de("windowScrollContainerState"), d2 = de("scrollContainerState"), f2 = c2 || s2 ? m2 : d2, p2 = fe("itemContent"), h2 = fe("context"), g2 = fe("groupContent"), v2 = fe("trackItemSizes"), S2 = fe("itemSize"), I2 = fe("log"), T2 = de("gap"), w2 = C(a2, S2, v2, o2 ? noop : f2, I2, T2, c2).callbackRef, x2 = n.useState(0), b2 = x2[0], y2 = x2[1];
  pe("deviation", function(t2) {
    b2 !== t2 && y2(t2);
  });
  var E2 = fe("EmptyPlaceholder"), H2 = fe("ScrollSeekPlaceholder") || Zt, R2 = fe("ListComponent"), L2 = fe("ItemComponent"), k2 = fe("GroupComponent"), z2 = fe("computeItemKey"), B2 = fe("isSeeking"), F2 = fe("groupIndices").length > 0, P2 = fe("paddingTopAddition"), O2 = o2 ? {} : { boxSizing: "border-box", paddingTop: i2.offsetTop + P2, paddingBottom: i2.offsetBottom, marginTop: b2 };
  return !o2 && 0 === i2.totalCount && E2 ? (0, import_react2.createElement)(E2, ne(E2, h2)) : (0, import_react2.createElement)(R2, u({}, ne(R2, h2), { ref: w2, style: O2, "data-test-id": o2 ? "virtuoso-top-item-list" : "virtuoso-item-list" }), (o2 ? i2.topItems : i2.items).map(function(t2) {
    var e = t2.originalIndex, n2 = z2(e + i2.firstItemIndex, t2.data, h2);
    return B2 ? (0, import_react2.createElement)(H2, u({}, ne(H2, h2), { key: n2, index: t2.index, height: t2.size, type: t2.type || "item" }, "group" === t2.type ? {} : { groupIndex: t2.groupIndex })) : "group" === t2.type ? (0, import_react2.createElement)(k2, u({}, ne(k2, h2), { key: n2, "data-index": e, "data-known-size": t2.size, "data-item-index": t2.index, style: Jt }), g2(t2.index)) : (0, import_react2.createElement)(L2, u({}, ne(L2, h2), { key: n2, "data-index": e, "data-known-size": t2.size, "data-item-index": t2.index, "data-item-group-index": t2.groupIndex, style: $t }), F2 ? p2(t2.index, t2.groupIndex, t2.data, h2) : p2(t2.index, t2.data, h2));
  }));
});
var Xt = { height: "100%", outline: "none", overflowY: "auto", position: "relative", WebkitOverflowScrolling: "touch" };
var te = { width: "100%", height: "100%", position: "absolute", top: 0 };
var ee = { width: "100%", position: Wt(), top: 0 };
function ne(t, e) {
  if ("string" != typeof t)
    return { context: e };
}
var re = n.memo(function() {
  var t = fe("HeaderComponent"), e = de("headerHeight"), n2 = fe("headerFooterTag"), r2 = I(function(t2) {
    return e(T(t2, "height"));
  }), o2 = fe("context");
  return t ? (0, import_react2.createElement)(n2, { ref: r2 }, (0, import_react2.createElement)(t, ne(t, o2))) : null;
});
var oe = n.memo(function() {
  var t = fe("FooterComponent"), e = de("footerHeight"), n2 = fe("headerFooterTag"), r2 = I(function(t2) {
    return e(T(t2, "height"));
  }), o2 = fe("context");
  return t ? (0, import_react2.createElement)(n2, { ref: r2 }, (0, import_react2.createElement)(t, ne(t, o2))) : null;
});
function ie(t) {
  var e = t.usePublisher, r2 = t.useEmitter, o2 = t.useEmitterValue;
  return n.memo(function(t2) {
    var n2 = t2.style, i2 = t2.children, a2 = c(t2, Gt), s2 = e("scrollContainerState"), m2 = o2("ScrollerComponent"), d2 = e("smoothScrollTargetReached"), f2 = o2("scrollerRef"), p2 = o2("context"), h2 = x(s2, d2, m2, f2), g2 = h2.scrollerRef, v2 = h2.scrollByCallback;
    return r2("scrollTo", h2.scrollToCallback), r2("scrollBy", v2), (0, import_react2.createElement)(m2, u({ ref: g2, style: u({}, Xt, n2), "data-test-id": "virtuoso-scroller", "data-virtuoso-scroller": true, tabIndex: 0 }, a2, ne(m2, p2)), i2);
  });
}
function ae(t) {
  var r2 = t.usePublisher, o2 = t.useEmitter, i2 = t.useEmitterValue;
  return n.memo(function(t2) {
    var n2 = t2.style, a2 = t2.children, s2 = c(t2, _t), m2 = r2("windowScrollContainerState"), d2 = i2("ScrollerComponent"), f2 = r2("smoothScrollTargetReached"), p2 = i2("totalListHeight"), g2 = i2("deviation"), v2 = i2("customScrollParent"), S2 = i2("context"), I2 = x(m2, f2, d2, noop, v2), C2 = I2.scrollerRef, T2 = I2.scrollByCallback, w2 = I2.scrollToCallback;
    return h(function() {
      return C2.current = v2 || window, function() {
        C2.current = null;
      };
    }, [C2, v2]), o2("windowScrollTo", w2), o2("scrollBy", T2), (0, import_react2.createElement)(d2, u({ style: u({ position: "relative" }, n2, 0 !== p2 ? { height: p2 + g2 } : {}), "data-virtuoso-scroller": true }, s2, ne(d2, S2)), a2);
  });
}
var le = function(t) {
  var r2 = t.children, o2 = de("viewportHeight"), i2 = I(compose(o2, function(t2) {
    return T(t2, "height");
  }));
  return n.createElement("div", { style: te, ref: i2, "data-viewport-type": "element" }, r2);
};
var se = function(t) {
  var e = t.children, r2 = Nt(de("windowViewportRect"), fe("customScrollParent"));
  return n.createElement("div", { ref: r2, style: te, "data-viewport-type": "window" }, e);
};
var ue = function(t) {
  var e = t.children, n2 = fe("TopItemListComponent"), r2 = fe("headerHeight"), o2 = u({}, ee, { marginTop: r2 + "px" }), i2 = fe("context");
  return (0, import_react2.createElement)(n2 || "div", { style: o2, context: i2 }, e);
};
var ce = systemToComponent(qt, { required: {}, optional: { context: "context", followOutput: "followOutput", firstItemIndex: "firstItemIndex", itemContent: "itemContent", groupContent: "groupContent", overscan: "overscan", increaseViewportBy: "increaseViewportBy", totalCount: "totalCount", topItemCount: "topItemCount", initialTopMostItemIndex: "initialTopMostItemIndex", components: "components", groupCounts: "groupCounts", atBottomThreshold: "atBottomThreshold", atTopThreshold: "atTopThreshold", computeItemKey: "computeItemKey", defaultItemHeight: "defaultItemHeight", fixedItemHeight: "fixedItemHeight", itemSize: "itemSize", scrollSeekConfiguration: "scrollSeekConfiguration", headerFooterTag: "headerFooterTag", data: "data", initialItemCount: "initialItemCount", initialScrollTop: "initialScrollTop", alignToBottom: "alignToBottom", useWindowScroll: "useWindowScroll", customScrollParent: "customScrollParent", scrollerRef: "scrollerRef", logLevel: "logLevel", react18ConcurrentRendering: "react18ConcurrentRendering", item: "item", group: "group", topItems: "topItems", itemHeight: "itemHeight", scrollingStateChange: "scrollingStateChange", maxHeightCacheSize: "maxHeightCacheSize", footer: "footer", header: "header", ItemContainer: "ItemContainer", ScrollContainer: "ScrollContainer", ListContainer: "ListContainer", GroupContainer: "GroupContainer", emptyComponent: "emptyComponent", HeaderContainer: "HeaderContainer", FooterContainer: "FooterContainer", scrollSeek: "scrollSeek" }, methods: { scrollToIndex: "scrollToIndex", scrollIntoView: "scrollIntoView", scrollTo: "scrollTo", scrollBy: "scrollBy", adjustForPrependedItems: "adjustForPrependedItems", autoscrollToBottom: "autoscrollToBottom" }, events: { isScrolling: "isScrolling", endReached: "endReached", startReached: "startReached", rangeChanged: "rangeChanged", atBottomStateChange: "atBottomStateChange", atTopStateChange: "atTopStateChange", totalListHeightChanged: "totalListHeightChanged", itemsRendered: "itemsRendered", groupIndices: "groupIndices" } }, n.memo(function(t) {
  var e = fe("useWindowScroll"), r2 = fe("topItemsIndexes").length > 0, o2 = fe("customScrollParent"), i2 = o2 || e ? se : le;
  return n.createElement(o2 || e ? ge : he, u({}, t), n.createElement(i2, null, n.createElement(re, null), n.createElement(Qt, null), n.createElement(oe, null)), r2 && n.createElement(ue, null, n.createElement(Qt, { showTopList: true })));
}));
var me = ce.Component;
var de = ce.usePublisher;
var fe = ce.useEmitterValue;
var pe = ce.useEmitter;
var he = ie({ usePublisher: de, useEmitterValue: fe, useEmitter: pe });
var ge = ae({ usePublisher: de, useEmitterValue: fe, useEmitter: pe });
var ve = { items: [], offsetBottom: 0, offsetTop: 0, top: 0, bottom: 0, itemHeight: 0, itemWidth: 0 };
var Se = { items: [{ index: 0 }], offsetBottom: 0, offsetTop: 0, top: 0, bottom: 0, itemHeight: 0, itemWidth: 0 };
var Ie = Math.round;
var Ce = Math.ceil;
var Te = Math.floor;
var we = Math.min;
var xe = Math.max;
function be(t, e) {
  return Array.from({ length: e - t + 1 }).map(function(e2, n2) {
    return { index: n2 + t };
  });
}
function ye(t, e) {
  return t && t.column === e.column && t.row === e.row;
}
var Ee = system(function(t) {
  var n2 = t[0], r2 = n2.overscan, o2 = n2.visibleRange, i2 = n2.listBoundary, a2 = t[1], l2 = a2.scrollTop, s2 = a2.viewportHeight, c2 = a2.scrollBy, m2 = a2.scrollTo, d2 = a2.smoothScrollTargetReached, f2 = a2.scrollContainerState, p2 = t[2], h2 = t[3], g2 = t[4], v2 = g2.propsReady, S2 = g2.didMount, I2 = t[5], C2 = I2.windowViewportRect, T2 = I2.windowScrollTo, w2 = I2.useWindowScroll, x2 = I2.customScrollParent, b2 = I2.windowScrollContainerState, y2 = t[6], E2 = statefulStream(0), H2 = statefulStream(0), R2 = statefulStream(ve), L2 = statefulStream({ height: 0, width: 0 }), k2 = statefulStream({ height: 0, width: 0 }), z2 = stream(), B2 = stream(), F2 = statefulStream(0), P2 = statefulStream({ row: 0, column: 0 });
  connect(pipe(S2, withLatestFrom(H2), filter(function(t2) {
    return 0 !== t2[1];
  }), map(function(t2) {
    return { items: be(0, t2[1] - 1), top: 0, bottom: 0, offsetBottom: 0, offsetTop: 0, itemHeight: 0, itemWidth: 0 };
  })), R2), connect(pipe(combineLatest(duc(E2), o2, duc(P2, ye), duc(k2, function(t2, e) {
    return t2 && t2.width === e.width && t2.height === e.height;
  })), withLatestFrom(L2), map(function(t2) {
    var e = t2[0], n3 = e[0], r3 = e[1], o3 = r3[0], i3 = r3[1], a3 = e[2], l3 = e[3], s3 = t2[1], u2 = a3.row, c3 = l3.height, m3 = l3.width, d3 = s3.width;
    if (0 === n3 || 0 === d3)
      return ve;
    if (0 === m3)
      return Se;
    var f3 = Le(d3, m3, a3.column), p3 = f3 * Te((o3 + u2) / (c3 + u2)), h3 = f3 * Ce((i3 + u2) / (c3 + u2)) - 1;
    h3 = xe(0, we(n3 - 1, h3));
    var g3 = be(p3 = we(h3, xe(0, p3)), h3), v3 = He(s3, a3, l3, g3), S3 = v3.top, I3 = v3.bottom, C3 = Ce(n3 / f3);
    return { items: g3, offsetTop: S3, offsetBottom: C3 * c3 + (C3 - 1) * u2 - I3, top: S3, bottom: I3, itemHeight: c3, itemWidth: m3 };
  })), R2), connect(pipe(L2, map(function(t2) {
    return t2.height;
  })), s2), connect(pipe(combineLatest(L2, k2, R2, P2), map(function(t2) {
    var e = He(t2[0], t2[3], t2[1], t2[2].items);
    return [e.top, e.bottom];
  }), distinctUntilChanged(gt)), i2);
  var O2 = streamFromEmitter(pipe(duc(R2), filter(function(t2) {
    return t2.items.length > 0;
  }), withLatestFrom(E2), filter(function(t2) {
    var e = t2[0].items;
    return e[e.length - 1].index === t2[1] - 1;
  }), map(function(t2) {
    return t2[1] - 1;
  }), distinctUntilChanged())), M2 = streamFromEmitter(pipe(duc(R2), filter(function(t2) {
    var e = t2.items;
    return e.length > 0 && 0 === e[0].index;
  }), mapTo(0), distinctUntilChanged())), V2 = streamFromEmitter(pipe(duc(R2), filter(function(t2) {
    return t2.items.length > 0;
  }), map(function(t2) {
    var e = t2.items;
    return { startIndex: e[0].index, endIndex: e[e.length - 1].index };
  }), distinctUntilChanged(vt)));
  connect(V2, h2.scrollSeekRangeChanged), connect(pipe(z2, withLatestFrom(L2, k2, E2, P2), map(function(t2) {
    var e = t2[1], n3 = t2[2], r3 = t2[3], o3 = t2[4], i3 = it(t2[0]), a3 = i3.align, l3 = i3.behavior, s3 = i3.offset, u2 = i3.index;
    "LAST" === u2 && (u2 = r3 - 1);
    var c3 = Re(e, o3, n3, u2 = xe(0, u2, we(r3 - 1, u2)));
    return "end" === a3 ? c3 = Ie(c3 - e.height + n3.height) : "center" === a3 && (c3 = Ie(c3 - e.height / 2 + n3.height / 2)), s3 && (c3 += s3), { top: c3, behavior: l3 };
  })), m2);
  var U2 = statefulStreamFromEmitter(pipe(R2, map(function(t2) {
    return t2.offsetBottom + t2.bottom;
  })), 0);
  return connect(pipe(C2, map(function(t2) {
    return { width: t2.visibleWidth, height: t2.visibleHeight };
  })), L2), u({ totalCount: E2, viewportDimensions: L2, itemDimensions: k2, scrollTop: l2, scrollHeight: B2, overscan: r2, scrollBy: c2, scrollTo: m2, scrollToIndex: z2, smoothScrollTargetReached: d2, windowViewportRect: C2, windowScrollTo: T2, useWindowScroll: w2, customScrollParent: x2, windowScrollContainerState: b2, deviation: F2, scrollContainerState: f2, initialItemCount: H2, gap: P2 }, h2, { gridState: R2, totalListHeight: U2 }, p2, { startReached: M2, endReached: O2, rangeChanged: V2, propsReady: v2 }, y2);
}, tup(Ct, b, ut, Et, ct, Pt, v));
function He(t, e, n2, r2) {
  var o2 = n2.height;
  return void 0 === o2 || 0 === r2.length ? { top: 0, bottom: 0 } : { top: Re(t, e, n2, r2[0].index), bottom: Re(t, e, n2, r2[r2.length - 1].index) + o2 };
}
function Re(t, e, n2, r2) {
  var o2 = Le(t.width, n2.width, e.column), i2 = Te(r2 / o2), a2 = i2 * n2.height + xe(0, i2 - 1) * e.row;
  return a2 > 0 ? a2 + e.row : a2;
}
function Le(t, e, n2) {
  return xe(1, Te((t + n2) / (e + n2)));
}
var ke = ["placeholder"];
var ze = system(function() {
  var t = statefulStream(function(t2) {
    return "Item " + t2;
  }), n2 = statefulStream({}), r2 = statefulStream(null), o2 = statefulStream("virtuoso-grid-item"), i2 = statefulStream("virtuoso-grid-list"), a2 = statefulStream(jt), l2 = statefulStream(noop), s2 = function(t2, r3) {
    return void 0 === r3 && (r3 = null), statefulStreamFromEmitter(pipe(n2, map(function(e) {
      return e[t2];
    }), distinctUntilChanged()), r3);
  };
  return { context: r2, itemContent: t, components: n2, computeItemKey: a2, itemClassName: o2, listClassName: i2, scrollerRef: l2, ListComponent: s2("List", "div"), ItemComponent: s2("Item", "div"), ScrollerComponent: s2("Scroller", "div"), ScrollSeekPlaceholder: s2("ScrollSeekPlaceholder", "div") };
});
var Be = system(function(t) {
  var n2 = t[0], r2 = t[1], o2 = { item: Yt(r2.itemContent, "Rename the %citem%c prop to %citemContent."), ItemContainer: stream(), ScrollContainer: stream(), ListContainer: stream(), emptyComponent: stream(), scrollSeek: stream() };
  function i2(t2, n3, o3) {
    connect(pipe(t2, withLatestFrom(r2.components), map(function(t3) {
      var e, r3 = t3[0], i3 = t3[1];
      return console.warn("react-virtuoso: " + o3 + " property is deprecated. Pass components." + n3 + " instead."), u({}, i3, ((e = {})[n3] = r3, e));
    })), r2.components);
  }
  return subscribe(o2.scrollSeek, function(t2) {
    var o3 = t2.placeholder, i3 = c(t2, ke);
    console.warn("react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead."), publish(r2.components, u({}, getValue(r2.components), { ScrollSeekPlaceholder: o3 })), publish(n2.scrollSeekConfiguration, i3);
  }), i2(o2.ItemContainer, "Item", "ItemContainer"), i2(o2.ListContainer, "List", "ListContainer"), i2(o2.ScrollContainer, "Scroller", "ScrollContainer"), u({}, n2, r2, o2);
}, tup(Ee, ze));
var Fe = n.memo(function() {
  var t = Ae("gridState"), e = Ae("listClassName"), n2 = Ae("itemClassName"), r2 = Ae("itemContent"), o2 = Ae("computeItemKey"), i2 = Ae("isSeeking"), a2 = Ue("scrollHeight"), s2 = Ae("ItemComponent"), c2 = Ae("ListComponent"), m2 = Ae("ScrollSeekPlaceholder"), d2 = Ae("context"), f2 = Ue("itemDimensions"), p2 = Ue("gap"), h2 = Ae("log"), g2 = I(function(t2) {
    a2(t2.parentElement.parentElement.scrollHeight);
    var e2 = t2.firstChild;
    e2 && f2(e2.getBoundingClientRect()), p2({ row: Ge("row-gap", getComputedStyle(t2).rowGap, h2), column: Ge("column-gap", getComputedStyle(t2).columnGap, h2) });
  });
  return (0, import_react2.createElement)(c2, u({ ref: g2, className: e }, ne(c2, d2), { style: { paddingTop: t.offsetTop, paddingBottom: t.offsetBottom } }), t.items.map(function(e2) {
    var a3 = o2(e2.index);
    return i2 ? (0, import_react2.createElement)(m2, u({ key: a3 }, ne(m2, d2), { index: e2.index, height: t.itemHeight, width: t.itemWidth })) : (0, import_react2.createElement)(s2, u({}, ne(s2, d2), { className: n2, "data-index": e2.index, key: a3 }), r2(e2.index, d2));
  }));
});
var Pe = function(t) {
  var e = t.children, r2 = Ue("viewportDimensions"), o2 = I(function(t2) {
    r2(t2.getBoundingClientRect());
  });
  return n.createElement("div", { style: te, ref: o2 }, e);
};
var Oe = function(t) {
  var e = t.children, r2 = Nt(Ue("windowViewportRect"), Ae("customScrollParent"));
  return n.createElement("div", { ref: r2, style: te }, e);
};
var Me = systemToComponent(Be, { optional: { totalCount: "totalCount", overscan: "overscan", itemContent: "itemContent", components: "components", computeItemKey: "computeItemKey", initialItemCount: "initialItemCount", scrollSeekConfiguration: "scrollSeekConfiguration", listClassName: "listClassName", itemClassName: "itemClassName", useWindowScroll: "useWindowScroll", customScrollParent: "customScrollParent", scrollerRef: "scrollerRef", item: "item", ItemContainer: "ItemContainer", ScrollContainer: "ScrollContainer", ListContainer: "ListContainer", scrollSeek: "scrollSeek" }, methods: { scrollTo: "scrollTo", scrollBy: "scrollBy", scrollToIndex: "scrollToIndex" }, events: { isScrolling: "isScrolling", endReached: "endReached", startReached: "startReached", rangeChanged: "rangeChanged", atBottomStateChange: "atBottomStateChange", atTopStateChange: "atTopStateChange" } }, n.memo(function(t) {
  var e = u({}, t), r2 = Ae("useWindowScroll"), o2 = Ae("customScrollParent"), i2 = o2 || r2 ? Oe : Pe;
  return n.createElement(o2 || r2 ? De : Ne, u({}, e), n.createElement(i2, null, n.createElement(Fe, null)));
}));
var Ve = Me.Component;
var Ue = Me.usePublisher;
var Ae = Me.useEmitterValue;
var We = Me.useEmitter;
var Ne = ie({ usePublisher: Ue, useEmitterValue: Ae, useEmitter: We });
var De = ae({ usePublisher: Ue, useEmitterValue: Ae, useEmitter: We });
function Ge(t, e, n2) {
  return "normal" === e || null != e && e.endsWith("px") || n2(t + " was not resolved to pixel value correctly", e, p.WARN), "normal" === e ? 0 : parseInt(null != e ? e : "0", 10);
}
var _e = system(function() {
  var t = statefulStream(function(t2) {
    return n.createElement("td", null, "Item $", t2);
  }), r2 = statefulStream(null), o2 = statefulStream(null), i2 = statefulStream({}), a2 = statefulStream(jt), l2 = statefulStream(noop), s2 = function(t2, n2) {
    return void 0 === n2 && (n2 = null), statefulStreamFromEmitter(pipe(i2, map(function(e) {
      return e[t2];
    }), distinctUntilChanged()), n2);
  };
  return { context: r2, itemContent: t, fixedHeaderContent: o2, components: i2, computeItemKey: a2, scrollerRef: l2, TableComponent: s2("Table", "table"), TableHeadComponent: s2("TableHead", "thead"), TableBodyComponent: s2("TableBody", "tbody"), TableRowComponent: s2("TableRow", "tr"), ScrollerComponent: s2("Scroller", "div"), EmptyPlaceholder: s2("EmptyPlaceholder"), ScrollSeekPlaceholder: s2("ScrollSeekPlaceholder"), FillerRow: s2("FillerRow") };
});
var je = system(function(t) {
  return u({}, t[0], t[1]);
}, tup(At, _e));
var Ke = function(t) {
  return n.createElement("tr", null, n.createElement("td", { style: { height: t.height } }));
};
var Ye = function(t) {
  return n.createElement("tr", null, n.createElement("td", { style: { height: t.height, padding: 0, border: 0 } }));
};
var qe = n.memo(function() {
  var t = tn("listState"), e = Xe("sizeRanges"), r2 = tn("useWindowScroll"), o2 = tn("customScrollParent"), i2 = Xe("windowScrollContainerState"), a2 = Xe("scrollContainerState"), s2 = o2 || r2 ? i2 : a2, c2 = tn("itemContent"), m2 = tn("trackItemSizes"), d2 = C(e, tn("itemSize"), m2, s2, tn("log"), void 0, o2), f2 = d2.callbackRef, p2 = d2.ref, h2 = n.useState(0), g2 = h2[0], v2 = h2[1];
  en("deviation", function(t2) {
    g2 !== t2 && (p2.current.style.marginTop = t2 + "px", v2(t2));
  });
  var S2 = tn("EmptyPlaceholder"), I2 = tn("ScrollSeekPlaceholder") || Ke, T2 = tn("FillerRow") || Ye, w2 = tn("TableBodyComponent"), x2 = tn("TableRowComponent"), b2 = tn("computeItemKey"), y2 = tn("isSeeking"), E2 = tn("paddingTopAddition"), H2 = tn("firstItemIndex"), R2 = tn("statefulTotalCount"), L2 = tn("context");
  if (0 === R2 && S2)
    return (0, import_react2.createElement)(S2, ne(S2, L2));
  var k2 = t.offsetTop + E2 + g2, z2 = t.offsetBottom, B2 = k2 > 0 ? n.createElement(T2, { height: k2, key: "padding-top" }) : null, F2 = z2 > 0 ? n.createElement(T2, { height: z2, key: "padding-bottom" }) : null, P2 = t.items.map(function(t2) {
    var e2 = t2.originalIndex, n2 = b2(e2 + H2, t2.data, L2);
    return y2 ? (0, import_react2.createElement)(I2, u({}, ne(I2, L2), { key: n2, index: t2.index, height: t2.size, type: t2.type || "item" })) : (0, import_react2.createElement)(x2, u({}, ne(x2, L2), { key: n2, "data-index": e2, "data-known-size": t2.size, "data-item-index": t2.index, style: { overflowAnchor: "none" } }), c2(t2.index, t2.data, L2));
  });
  return (0, import_react2.createElement)(w2, u({ ref: f2, "data-test-id": "virtuoso-item-list" }, ne(w2, L2)), [B2].concat(P2, [F2]));
});
var Ze = function(t) {
  var r2 = t.children, o2 = Xe("viewportHeight"), i2 = I(compose(o2, function(t2) {
    return T(t2, "height");
  }));
  return n.createElement("div", { style: te, ref: i2, "data-viewport-type": "element" }, r2);
};
var Je = function(t) {
  var e = t.children, r2 = Nt(Xe("windowViewportRect"), tn("customScrollParent"));
  return n.createElement("div", { ref: r2, style: te, "data-viewport-type": "window" }, e);
};
var $e = systemToComponent(je, { required: {}, optional: { context: "context", followOutput: "followOutput", firstItemIndex: "firstItemIndex", itemContent: "itemContent", fixedHeaderContent: "fixedHeaderContent", overscan: "overscan", increaseViewportBy: "increaseViewportBy", totalCount: "totalCount", topItemCount: "topItemCount", initialTopMostItemIndex: "initialTopMostItemIndex", components: "components", groupCounts: "groupCounts", atBottomThreshold: "atBottomThreshold", atTopThreshold: "atTopThreshold", computeItemKey: "computeItemKey", defaultItemHeight: "defaultItemHeight", fixedItemHeight: "fixedItemHeight", itemSize: "itemSize", scrollSeekConfiguration: "scrollSeekConfiguration", data: "data", initialItemCount: "initialItemCount", initialScrollTop: "initialScrollTop", alignToBottom: "alignToBottom", useWindowScroll: "useWindowScroll", customScrollParent: "customScrollParent", scrollerRef: "scrollerRef", logLevel: "logLevel", react18ConcurrentRendering: "react18ConcurrentRendering" }, methods: { scrollToIndex: "scrollToIndex", scrollIntoView: "scrollIntoView", scrollTo: "scrollTo", scrollBy: "scrollBy" }, events: { isScrolling: "isScrolling", endReached: "endReached", startReached: "startReached", rangeChanged: "rangeChanged", atBottomStateChange: "atBottomStateChange", atTopStateChange: "atTopStateChange", totalListHeightChanged: "totalListHeightChanged", itemsRendered: "itemsRendered", groupIndices: "groupIndices" } }, n.memo(function(t) {
  var r2 = tn("useWindowScroll"), o2 = tn("customScrollParent"), i2 = Xe("fixedHeaderHeight"), a2 = tn("fixedHeaderContent"), l2 = tn("context"), s2 = I(compose(i2, function(t2) {
    return T(t2, "height");
  })), c2 = o2 || r2 ? rn : nn, m2 = o2 || r2 ? Je : Ze, d2 = tn("TableComponent"), f2 = tn("TableHeadComponent"), p2 = a2 ? n.createElement(f2, u({ key: "TableHead", style: { zIndex: 1, position: "sticky", top: 0 }, ref: s2 }, ne(f2, l2)), a2()) : null;
  return n.createElement(c2, u({}, t), n.createElement(m2, null, n.createElement(d2, u({ style: { borderSpacing: 0 } }, ne(d2, l2)), [p2, n.createElement(qe, { key: "TableBody" })])));
}));
var Qe = $e.Component;
var Xe = $e.usePublisher;
var tn = $e.useEmitterValue;
var en = $e.useEmitter;
var nn = ie({ usePublisher: Xe, useEmitterValue: tn, useEmitter: en });
var rn = ae({ usePublisher: Xe, useEmitterValue: tn, useEmitter: en });
var on = me;

export {
  require_dist,
  require_dayjs_min,
  require_linkifyjs,
  require_immutable,
  require_unist_util_visit,
  require_symbols,
  require_react_markdown,
  on
};
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
//# sourceMappingURL=chunk-UB44DJPQ.js.map
