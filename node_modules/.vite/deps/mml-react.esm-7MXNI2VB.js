import {
  on,
  require_dayjs_min,
  require_dist,
  require_linkifyjs,
  require_react_markdown
} from "./chunk-UB44DJPQ.js";
import "./chunk-KXTM2JPT.js";
import "./chunk-LRKUXM6X.js";
import {
  require_react
} from "./chunk-IGOAJGOA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@rgrove/parse-xml/src/lib/StringScanner.js
var require_StringScanner = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/StringScanner.js"(exports, module) {
    "use strict";
    var emptyString = "";
    var StringScanner = class {
      constructor(string) {
        this.chars = [...string];
        this.charCount = this.chars.length;
        this.charIndex = 0;
        this.charsToBytes = new Array(this.charCount);
        this.multiByteMode = false;
        this.string = string;
        let { chars, charCount, charsToBytes } = this;
        if (charCount === string.length) {
          for (let i = 0; i < charCount; ++i) {
            charsToBytes[i] = i;
          }
        } else {
          for (let byteIndex = 0, charIndex = 0; charIndex < charCount; ++charIndex) {
            charsToBytes[charIndex] = byteIndex;
            byteIndex += chars[charIndex].length;
          }
          this.multiByteMode = true;
        }
      }
      get isEnd() {
        return this.charIndex >= this.charCount;
      }
      _charLength(string) {
        let { length } = string;
        if (length < 2 || !this.multiByteMode) {
          return length;
        }
        return string.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
      }
      advance(count = 1) {
        this.charIndex = Math.min(this.charCount, this.charIndex + count);
      }
      consume(count = 1) {
        let chars = this.peek(count);
        this.advance(count);
        return chars;
      }
      consumeMatch(regex) {
        if (!regex.sticky) {
          throw new Error('`regex` must have a sticky flag ("y")');
        }
        regex.lastIndex = this.charsToBytes[this.charIndex];
        let result = regex.exec(this.string);
        if (result === null) {
          return emptyString;
        }
        let match = result[0];
        this.advance(this._charLength(match));
        return match;
      }
      consumeMatchFn(fn) {
        let startIndex = this.charIndex;
        while (!this.isEnd && fn(this.peek())) {
          this.advance();
        }
        return this.charIndex > startIndex ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex]) : emptyString;
      }
      consumeString(stringToConsume) {
        if (this.consumeStringFast(stringToConsume)) {
          return stringToConsume;
        }
        if (!this.multiByteMode) {
          return emptyString;
        }
        let { length } = stringToConsume;
        let charLengthToMatch = this._charLength(stringToConsume);
        if (charLengthToMatch !== length && stringToConsume === this.peek(charLengthToMatch)) {
          this.advance(charLengthToMatch);
          return stringToConsume;
        }
        return emptyString;
      }
      consumeStringFast(stringToConsume) {
        if (this.peek() === stringToConsume[0]) {
          let { length } = stringToConsume;
          if (length === 1) {
            this.advance();
            return stringToConsume;
          }
          if (this.peek(length) === stringToConsume) {
            this.advance(length);
            return stringToConsume;
          }
        }
        return emptyString;
      }
      consumeUntilMatch(regex) {
        if (!regex.global) {
          throw new Error('`regex` must have a global flag ("g")');
        }
        let byteIndex = this.charsToBytes[this.charIndex];
        regex.lastIndex = byteIndex;
        let match = regex.exec(this.string);
        if (match === null || match.index === byteIndex) {
          return emptyString;
        }
        let result = this.string.slice(byteIndex, match.index);
        this.advance(this._charLength(result));
        return result;
      }
      consumeUntilString(searchString) {
        let { charIndex, charsToBytes, string } = this;
        let byteIndex = charsToBytes[charIndex];
        let matchByteIndex = string.indexOf(searchString, byteIndex);
        if (matchByteIndex <= 0) {
          return emptyString;
        }
        let result = string.slice(byteIndex, matchByteIndex);
        this.advance(this._charLength(result));
        return result;
      }
      peek(count = 1) {
        if (this.charIndex >= this.charCount) {
          return emptyString;
        }
        if (count === 1) {
          return this.chars[this.charIndex];
        }
        let { charsToBytes, charIndex } = this;
        return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);
      }
      reset(index = 0) {
        this.charIndex = index >= 0 ? Math.min(this.charCount, index) : Math.max(0, this.charIndex + index);
      }
    };
    module.exports = StringScanner;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/syntax.js
var require_syntax = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/syntax.js"(exports) {
    "use strict";
    var predefinedEntities = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }));
    exports.predefinedEntities = predefinedEntities;
    function isNameChar(char) {
      if (isNameStartChar(char)) {
        return true;
      }
      let cp = getCodePoint(char);
      return cp === 45 || cp === 46 || cp >= 48 && cp <= 57 || cp === 183 || cp >= 768 && cp <= 879 || cp >= 8255 && cp <= 8256;
    }
    exports.isNameChar = isNameChar;
    function isNameStartChar(char) {
      let cp = getCodePoint(char);
      return cp === 58 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 192 && cp <= 214 || cp >= 216 && cp <= 246 || cp >= 248 && cp <= 767 || cp >= 880 && cp <= 893 || cp >= 895 && cp <= 8191 || cp >= 8204 && cp <= 8205 || cp >= 8304 && cp <= 8591 || cp >= 11264 && cp <= 12271 || cp >= 12289 && cp <= 55295 || cp >= 63744 && cp <= 64975 || cp >= 65008 && cp <= 65533 || cp >= 65536 && cp <= 983039;
    }
    exports.isNameStartChar = isNameStartChar;
    function isNotXmlChar(char) {
      return !isXmlChar(char);
    }
    exports.isNotXmlChar = isNotXmlChar;
    function isReferenceChar(char) {
      return char === "#" || isNameChar(char);
    }
    exports.isReferenceChar = isReferenceChar;
    function isWhitespace(char) {
      let cp = getCodePoint(char);
      return cp === 32 || cp === 9 || cp === 10 || cp === 13;
    }
    exports.isWhitespace = isWhitespace;
    function isXmlChar(char) {
      let cp = getCodePoint(char);
      return cp === 9 || cp === 10 || cp === 13 || cp >= 32 && cp <= 55295 || cp >= 57344 && cp <= 65533 || cp >= 65536 && cp <= 1114111;
    }
    exports.isXmlChar = isXmlChar;
    function getCodePoint(char) {
      return char.codePointAt(0) || -1;
    }
  }
});

// node_modules/@rgrove/parse-xml/src/lib/XmlNode.js
var require_XmlNode = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/XmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor() {
        this.parent = null;
      }
      get document() {
        return this.parent ? this.parent.document : null;
      }
      get isRootNode() {
        return this.parent ? this.parent === this.document : false;
      }
      get preserveWhitespace() {
        return Boolean(this.parent && this.parent.preserveWhitespace);
      }
      get type() {
        return "";
      }
      toJSON() {
        let json = {
          type: this.type
        };
        if (this.isRootNode) {
          json.isRootNode = true;
        }
        if (this.preserveWhitespace) {
          json.preserveWhitespace = true;
        }
        return json;
      }
    };
    XmlNode.TYPE_CDATA = "cdata";
    XmlNode.TYPE_COMMENT = "comment";
    XmlNode.TYPE_DOCUMENT = "document";
    XmlNode.TYPE_ELEMENT = "element";
    XmlNode.TYPE_PROCESSING_INSTRUCTION = "pi";
    XmlNode.TYPE_TEXT = "text";
    module.exports = XmlNode;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/XmlText.js
var require_XmlText = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/XmlText.js"(exports, module) {
    "use strict";
    var XmlNode = require_XmlNode();
    var XmlText = class extends XmlNode {
      constructor(text2 = "") {
        super();
        this.text = text2;
      }
      get type() {
        return XmlNode.TYPE_TEXT;
      }
      toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
          text: this.text
        });
      }
    };
    module.exports = XmlText;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/XmlCdata.js
var require_XmlCdata = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/XmlCdata.js"(exports, module) {
    "use strict";
    var XmlNode = require_XmlNode();
    var XmlText = require_XmlText();
    var XmlCdata = class extends XmlText {
      get type() {
        return XmlNode.TYPE_CDATA;
      }
    };
    module.exports = XmlCdata;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/XmlComment.js
var require_XmlComment = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/XmlComment.js"(exports, module) {
    "use strict";
    var XmlNode = require_XmlNode();
    var XmlComment = class extends XmlNode {
      constructor(content = "") {
        super();
        this.content = content;
      }
      get type() {
        return XmlNode.TYPE_COMMENT;
      }
      toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
          content: this.content
        });
      }
    };
    module.exports = XmlComment;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/XmlElement.js
var require_XmlElement = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/XmlElement.js"(exports, module) {
    "use strict";
    var XmlNode = require_XmlNode();
    var XmlElement = class extends XmlNode {
      constructor(name, attributes = /* @__PURE__ */ Object.create(null), children = []) {
        super();
        this.name = name;
        this.attributes = attributes;
        this.children = children;
      }
      get isEmpty() {
        return this.children.length === 0;
      }
      get preserveWhitespace() {
        let node = this;
        while (node instanceof XmlElement) {
          if ("xml:space" in node.attributes) {
            return node.attributes["xml:space"] === "preserve";
          }
          node = node.parent;
        }
        return false;
      }
      get text() {
        return this.children.map((child) => "text" in child ? child.text : "").join("");
      }
      get type() {
        return XmlNode.TYPE_ELEMENT;
      }
      toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
          name: this.name,
          attributes: this.attributes,
          children: this.children.map((child) => child.toJSON())
        });
      }
    };
    module.exports = XmlElement;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/XmlDocument.js
var require_XmlDocument = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/XmlDocument.js"(exports, module) {
    "use strict";
    var XmlElement = require_XmlElement();
    var XmlNode = require_XmlNode();
    var XmlDocument = class extends XmlNode {
      constructor(children = []) {
        super();
        this.children = children;
      }
      get document() {
        return this;
      }
      get root() {
        return this.children.find((child) => child instanceof XmlElement) || null;
      }
      get text() {
        return this.children.map((child) => "text" in child ? child.text : "").join("");
      }
      get type() {
        return XmlNode.TYPE_DOCUMENT;
      }
      toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
          children: this.children.map((child) => child.toJSON())
        });
      }
    };
    module.exports = XmlDocument;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/XmlProcessingInstruction.js
var require_XmlProcessingInstruction = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/XmlProcessingInstruction.js"(exports, module) {
    "use strict";
    var XmlNode = require_XmlNode();
    var XmlProcessingInstruction = class extends XmlNode {
      constructor(name, content = "") {
        super();
        this.name = name;
        this.content = content;
      }
      get type() {
        return XmlNode.TYPE_PROCESSING_INSTRUCTION;
      }
      toJSON() {
        return Object.assign(XmlNode.prototype.toJSON.call(this), {
          name: this.name,
          content: this.content
        });
      }
    };
    module.exports = XmlProcessingInstruction;
  }
});

// node_modules/@rgrove/parse-xml/src/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/@rgrove/parse-xml/src/lib/Parser.js"(exports, module) {
    "use strict";
    var StringScanner = require_StringScanner();
    var syntax = require_syntax();
    var XmlCdata = require_XmlCdata();
    var XmlComment = require_XmlComment();
    var XmlDocument = require_XmlDocument();
    var XmlElement = require_XmlElement();
    var XmlProcessingInstruction = require_XmlProcessingInstruction();
    var XmlText = require_XmlText();
    var emptyString = "";
    var Parser = class {
      constructor(xml, options = {}) {
        this.document = new XmlDocument();
        this.currentNode = this.document;
        this.options = options;
        this.scanner = new StringScanner(normalizeXmlString(xml));
        this.consumeProlog();
        if (!this.consumeElement()) {
          this.error("Root element is missing or invalid");
        }
        while (this.consumeMisc()) {
        }
        if (!this.scanner.isEnd) {
          this.error("Extra content at the end of the document");
        }
      }
      addNode(node) {
        node.parent = this.currentNode;
        this.currentNode.children.push(node);
      }
      addText(text2) {
        let { children } = this.currentNode;
        if (children.length > 0) {
          let prevNode = children[children.length - 1];
          if (prevNode instanceof XmlText) {
            prevNode.text += text2;
            return;
          }
        }
        this.addNode(new XmlText(text2));
      }
      consumeAttributeValue() {
        let { scanner } = this;
        let quote = scanner.peek();
        if (quote !== '"' && quote !== "'") {
          return false;
        }
        scanner.advance();
        let chars;
        let isClosed = false;
        let value = emptyString;
        let regex = quote === '"' ? /[^"&<]+/y : /[^'&<]+/y;
        matchLoop:
          while (!scanner.isEnd) {
            chars = scanner.consumeMatch(regex);
            if (chars) {
              this.validateChars(chars);
              value += chars.replace(/[\t\r\n]/g, " ");
            }
            let nextChar = scanner.peek();
            switch (nextChar) {
              case quote:
                isClosed = true;
                break matchLoop;
              case "&":
                value += this.consumeReference();
                continue;
              case "<":
                this.error("Unescaped `<` is not allowed in an attribute value");
                break;
              case emptyString:
                this.error("Unclosed attribute");
                break;
            }
          }
        if (!isClosed) {
          this.error("Unclosed attribute");
        }
        scanner.advance();
        return value;
      }
      consumeCdataSection() {
        let { scanner } = this;
        if (!scanner.consumeStringFast("<![CDATA[")) {
          return false;
        }
        let text2 = scanner.consumeUntilString("]]>");
        this.validateChars(text2);
        if (!scanner.consumeStringFast("]]>")) {
          this.error("Unclosed CDATA section");
        }
        if (this.options.preserveCdata) {
          this.addNode(new XmlCdata(text2));
        } else {
          this.addText(text2);
        }
        return true;
      }
      consumeCharData() {
        let { scanner } = this;
        let charData = scanner.consumeUntilMatch(/<|&|]]>/g);
        if (!charData) {
          return false;
        }
        this.validateChars(charData);
        if (scanner.peek() === "]" && scanner.peek(3) === "]]>") {
          this.error("Element content may not contain the CDATA section close delimiter `]]>`");
        }
        this.addText(charData);
        return true;
      }
      consumeComment() {
        let { scanner } = this;
        if (!scanner.consumeStringFast("<!--")) {
          return false;
        }
        let content = scanner.consumeUntilString("--");
        this.validateChars(content);
        if (!scanner.consumeStringFast("-->")) {
          if (scanner.peek(2) === "--") {
            this.error("The string `--` isn't allowed inside a comment");
          } else {
            this.error("Unclosed comment");
          }
        }
        if (this.options.preserveComments) {
          this.addNode(new XmlComment(content.trim()));
        }
        return true;
      }
      consumeContentReference() {
        let ref = this.consumeReference();
        if (ref) {
          this.addText(ref);
          return true;
        }
        return false;
      }
      consumeDoctypeDeclaration() {
        let { scanner } = this;
        if (!scanner.consumeStringFast("<!DOCTYPE") || !this.consumeWhitespace()) {
          return false;
        }
        scanner.consumeMatch(/[^[>]+/y);
        if (scanner.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y)) {
          return true;
        }
        if (!scanner.consumeStringFast(">")) {
          this.error("Unclosed doctype declaration");
        }
        return true;
      }
      consumeElement() {
        let { scanner } = this;
        let mark = scanner.charIndex;
        if (scanner.peek() !== "<") {
          return false;
        }
        scanner.advance();
        let name = this.consumeName();
        if (!name) {
          scanner.reset(mark);
          return false;
        }
        let attributes = /* @__PURE__ */ Object.create(null);
        while (this.consumeWhitespace()) {
          let attrName = this.consumeName();
          if (!attrName) {
            continue;
          }
          let attrValue = this.consumeEqual() && this.consumeAttributeValue();
          if (attrValue === false) {
            this.error("Attribute value expected");
          }
          if (attrName in attributes) {
            this.error(`Duplicate attribute: ${attrName}`);
          }
          if (attrName === "xml:space" && attrValue !== "default" && attrValue !== "preserve") {
            this.error('Value of the `xml:space` attribute must be "default" or "preserve"');
          }
          attributes[attrName] = attrValue;
        }
        if (this.options.sortAttributes) {
          let attrNames = Object.keys(attributes).sort();
          let sortedAttributes = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < attrNames.length; ++i) {
            let attrName = attrNames[i];
            sortedAttributes[attrName] = attributes[attrName];
          }
          attributes = sortedAttributes;
        }
        let isEmpty = Boolean(scanner.consumeStringFast("/>"));
        let element = new XmlElement(name, attributes);
        element.parent = this.currentNode;
        if (!isEmpty) {
          if (!scanner.consumeStringFast(">")) {
            this.error(`Unclosed start tag for element \`${name}\``);
          }
          this.currentNode = element;
          this.consumeCharData();
          while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()) {
            this.consumeCharData();
          }
          let endTagMark = scanner.charIndex;
          let endTagName;
          if (!scanner.consumeStringFast("</") || !(endTagName = this.consumeName()) || endTagName !== name) {
            scanner.reset(endTagMark);
            this.error(`Missing end tag for element ${name}`);
          }
          this.consumeWhitespace();
          if (!scanner.consumeStringFast(">")) {
            this.error(`Unclosed end tag for element ${name}`);
          }
          this.currentNode = element.parent;
        }
        this.addNode(element);
        return true;
      }
      consumeEqual() {
        this.consumeWhitespace();
        if (this.scanner.consumeStringFast("=")) {
          this.consumeWhitespace();
          return true;
        }
        return false;
      }
      consumeMisc() {
        return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
      }
      consumeName() {
        return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;
      }
      consumeProcessingInstruction() {
        let { scanner } = this;
        let mark = scanner.charIndex;
        if (!scanner.consumeStringFast("<?")) {
          return false;
        }
        let name = this.consumeName();
        if (name) {
          if (name.toLowerCase() === "xml") {
            scanner.reset(mark);
            this.error("XML declaration isn't allowed here");
          }
        } else {
          this.error("Invalid processing instruction");
        }
        if (!this.consumeWhitespace()) {
          if (scanner.consumeStringFast("?>")) {
            this.addNode(new XmlProcessingInstruction(name));
            return true;
          }
          this.error("Whitespace is required after a processing instruction name");
        }
        let content = scanner.consumeUntilString("?>");
        this.validateChars(content);
        if (!scanner.consumeStringFast("?>")) {
          this.error("Unterminated processing instruction");
        }
        this.addNode(new XmlProcessingInstruction(name, content));
        return true;
      }
      consumeProlog() {
        let { scanner } = this;
        let mark = scanner.charIndex;
        this.consumeXmlDeclaration();
        while (this.consumeMisc()) {
        }
        if (this.consumeDoctypeDeclaration()) {
          while (this.consumeMisc()) {
          }
        }
        return mark < scanner.charIndex;
      }
      consumeReference() {
        let { scanner } = this;
        if (scanner.peek() !== "&") {
          return false;
        }
        scanner.advance();
        let ref = scanner.consumeMatchFn(syntax.isReferenceChar);
        if (scanner.consume() !== ";") {
          this.error("Unterminated reference (a reference must end with `;`)");
        }
        let parsedValue;
        if (ref[0] === "#") {
          let codePoint = ref[1] === "x" ? parseInt(ref.slice(2), 16) : parseInt(ref.slice(1), 10);
          if (isNaN(codePoint)) {
            this.error("Invalid character reference");
          }
          parsedValue = String.fromCodePoint(codePoint);
          if (!syntax.isXmlChar(parsedValue)) {
            this.error("Character reference resolves to an invalid character");
          }
        } else {
          parsedValue = syntax.predefinedEntities[ref];
          if (parsedValue === void 0) {
            let {
              ignoreUndefinedEntities,
              resolveUndefinedEntity
            } = this.options;
            let wrappedRef = `&${ref};`;
            if (resolveUndefinedEntity) {
              let resolvedValue = resolveUndefinedEntity(wrappedRef);
              if (resolvedValue !== null && resolvedValue !== void 0) {
                let type = typeof resolvedValue;
                if (type !== "string") {
                  throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${type}`);
                }
                return resolvedValue;
              }
            }
            if (ignoreUndefinedEntities) {
              return wrappedRef;
            }
            scanner.reset(-wrappedRef.length);
            this.error(`Named entity isn't defined: ${wrappedRef}`);
          }
        }
        return parsedValue;
      }
      consumeSystemLiteral() {
        let { scanner } = this;
        let quote = scanner.consumeStringFast('"') || scanner.consumeStringFast("'");
        if (!quote) {
          return false;
        }
        let value = scanner.consumeUntilString(quote);
        this.validateChars(value);
        if (!scanner.consumeStringFast(quote)) {
          this.error("Missing end quote");
        }
        return value;
      }
      consumeWhitespace() {
        return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));
      }
      consumeXmlDeclaration() {
        let { scanner } = this;
        if (!scanner.consumeStringFast("<?xml")) {
          return false;
        }
        if (!this.consumeWhitespace()) {
          this.error("Invalid XML declaration");
        }
        let version = Boolean(scanner.consumeStringFast("version")) && this.consumeEqual() && this.consumeSystemLiteral();
        if (version === false) {
          this.error("XML version is missing or invalid");
        } else if (!/^1\.[0-9]+$/.test(version)) {
          this.error("Invalid character in version number");
        }
        if (this.consumeWhitespace()) {
          let encoding = Boolean(scanner.consumeStringFast("encoding")) && this.consumeEqual() && this.consumeSystemLiteral();
          if (encoding) {
            this.consumeWhitespace();
          }
          let standalone = Boolean(scanner.consumeStringFast("standalone")) && this.consumeEqual() && this.consumeSystemLiteral();
          if (standalone) {
            if (standalone !== "yes" && standalone !== "no") {
              this.error('Only "yes" and "no" are permitted as values of `standalone`');
            }
            this.consumeWhitespace();
          }
        }
        if (!scanner.consumeStringFast("?>")) {
          this.error("Invalid or unclosed XML declaration");
        }
        return true;
      }
      error(message) {
        let { charIndex, string: xml } = this.scanner;
        let column = 1;
        let excerpt = "";
        let line = 1;
        for (let i = 0; i < charIndex; ++i) {
          let char = xml[i];
          if (char === "\n") {
            column = 1;
            excerpt = "";
            line += 1;
          } else {
            column += 1;
            excerpt += char;
          }
        }
        let eol = xml.indexOf("\n", charIndex);
        excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);
        let excerptStart = 0;
        if (excerpt.length > 50) {
          if (column < 40) {
            excerpt = excerpt.slice(0, 50);
          } else {
            excerptStart = column - 20;
            excerpt = excerpt.slice(excerptStart, column + 30);
          }
        }
        let err = new Error(
          `${message} (line ${line}, column ${column})
  ${excerpt}
` + " ".repeat(column - excerptStart + 1) + "^\n"
        );
        Object.assign(err, {
          column,
          excerpt,
          line,
          pos: charIndex
        });
        throw err;
      }
      validateChars(string) {
        let charIndex = 0;
        for (let char of string) {
          if (syntax.isNotXmlChar(char)) {
            this.scanner.reset(-([...string].length - charIndex));
            this.error("Invalid character");
          }
          charIndex += 1;
        }
      }
    };
    module.exports = Parser;
    function normalizeXmlString(xml) {
      if (xml[0] === "\uFEFF") {
        xml = xml.slice(1);
      }
      return xml.replace(/\r\n?/g, "\n");
    }
  }
});

// node_modules/@rgrove/parse-xml/src/index.js
var require_src = __commonJS({
  "node_modules/@rgrove/parse-xml/src/index.js"(exports, module) {
    "use strict";
    var Parser = require_Parser();
    var XmlCdata = require_XmlCdata();
    var XmlComment = require_XmlComment();
    var XmlDocument = require_XmlDocument();
    var XmlElement = require_XmlElement();
    var XmlNode = require_XmlNode();
    var XmlProcessingInstruction = require_XmlProcessingInstruction();
    var XmlText = require_XmlText();
    function parseXml2(xml, options) {
      return new Parser(xml, options).document;
    }
    parseXml2.XmlCdata = XmlCdata;
    parseXml2.XmlComment = XmlComment;
    parseXml2.XmlDocument = XmlDocument;
    parseXml2.XmlElement = XmlElement;
    parseXml2.XmlNode = XmlNode;
    parseXml2.XmlProcessingInstruction = XmlProcessingInstruction;
    parseXml2.XmlText = XmlText;
    module.exports = parseXml2;
  }
});

// node_modules/ical.js/build/ical.js
var require_ical = __commonJS({
  "node_modules/ical.js/build/ical.js"(exports, module) {
    var ICAL;
    (function() {
      if (typeof module === "object") {
        ICAL = module.exports;
      } else if (typeof HTMLScriptElement !== "undefined" && "noModule" in HTMLScriptElement.prototype) {
        window.ICAL = ICAL = {};
      } else if (typeof ICAL !== "object") {
        ICAL = {};
      }
    })();
    ICAL.foldLength = 75;
    ICAL.newLineChar = "\r\n";
    ICAL.helpers = {
      updateTimezones: function(vcal) {
        var allsubs, properties, vtimezones, reqTzid, i, tzid;
        if (!vcal || vcal.name !== "vcalendar") {
          return vcal;
        }
        allsubs = vcal.getAllSubcomponents();
        properties = [];
        vtimezones = {};
        for (i = 0; i < allsubs.length; i++) {
          if (allsubs[i].name === "vtimezone") {
            tzid = allsubs[i].getFirstProperty("tzid").getFirstValue();
            vtimezones[tzid] = allsubs[i];
          } else {
            properties = properties.concat(allsubs[i].getAllProperties());
          }
        }
        reqTzid = {};
        for (i = 0; i < properties.length; i++) {
          if (tzid = properties[i].getParameter("tzid")) {
            reqTzid[tzid] = true;
          }
        }
        for (i in vtimezones) {
          if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {
            vcal.removeSubcomponent(vtimezones[i]);
          }
        }
        for (i in reqTzid) {
          if (reqTzid.hasOwnProperty(i) && !vtimezones[i] && ICAL.TimezoneService.has(i)) {
            vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);
          }
        }
        return vcal;
      },
      isStrictlyNaN: function(number2) {
        return typeof number2 === "number" && isNaN(number2);
      },
      strictParseInt: function(string) {
        var result = parseInt(string, 10);
        if (ICAL.helpers.isStrictlyNaN(result)) {
          throw new Error(
            'Could not extract integer from "' + string + '"'
          );
        }
        return result;
      },
      formatClassType: function formatClassType(data, type) {
        if (typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof type) {
          return data;
        }
        return new type(data);
      },
      unescapedIndexOf: function(buffer, search, pos) {
        while ((pos = buffer.indexOf(search, pos)) !== -1) {
          if (pos > 0 && buffer[pos - 1] === "\\") {
            pos += 1;
          } else {
            return pos;
          }
        }
        return -1;
      },
      binsearchInsert: function(list, seekVal, cmpfunc) {
        if (!list.length)
          return 0;
        var low = 0, high = list.length - 1, mid, cmpval;
        while (low <= high) {
          mid = low + Math.floor((high - low) / 2);
          cmpval = cmpfunc(seekVal, list[mid]);
          if (cmpval < 0)
            high = mid - 1;
          else if (cmpval > 0)
            low = mid + 1;
          else
            break;
        }
        if (cmpval < 0)
          return mid;
        else if (cmpval > 0)
          return mid + 1;
        else
          return mid;
      },
      dumpn: function() {
        if (!ICAL.debug) {
          return;
        }
        if (typeof console !== "undefined" && "log" in console) {
          ICAL.helpers.dumpn = function consoleDumpn(input2) {
            console.log(input2);
          };
        } else {
          ICAL.helpers.dumpn = function geckoDumpn(input2) {
            dump(input2 + "\n");
          };
        }
        ICAL.helpers.dumpn(arguments[0]);
      },
      clone: function(aSrc, aDeep) {
        if (!aSrc || typeof aSrc != "object") {
          return aSrc;
        } else if (aSrc instanceof Date) {
          return new Date(aSrc.getTime());
        } else if ("clone" in aSrc) {
          return aSrc.clone();
        } else if (Array.isArray(aSrc)) {
          var arr = [];
          for (var i = 0; i < aSrc.length; i++) {
            arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);
          }
          return arr;
        } else {
          var obj = {};
          for (var name in aSrc) {
            if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
              if (aDeep) {
                obj[name] = ICAL.helpers.clone(aSrc[name], true);
              } else {
                obj[name] = aSrc[name];
              }
            }
          }
          return obj;
        }
      },
      foldline: function foldline(aLine) {
        var result = "";
        var line = aLine || "", pos = 0, line_length = 0;
        while (line.length) {
          var cp = line.codePointAt(pos);
          if (cp < 128)
            ++line_length;
          else if (cp < 2048)
            line_length += 2;
          else if (cp < 65536)
            line_length += 3;
          else
            line_length += 4;
          if (line_length < ICAL.foldLength + 1)
            pos += cp > 65535 ? 2 : 1;
          else {
            result += ICAL.newLineChar + " " + line.substring(0, pos);
            line = line.substring(pos);
            pos = line_length = 0;
          }
        }
        return result.substr(ICAL.newLineChar.length + 1);
      },
      pad2: function pad(data) {
        if (typeof data !== "string") {
          if (typeof data === "number") {
            data = parseInt(data);
          }
          data = String(data);
        }
        var len = data.length;
        switch (len) {
          case 0:
            return "00";
          case 1:
            return "0" + data;
          default:
            return data;
        }
      },
      trunc: function trunc(number2) {
        return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
      },
      inherits: function(base, child, extra) {
        function F() {
        }
        F.prototype = base.prototype;
        child.prototype = new F();
        if (extra) {
          ICAL.helpers.extend(extra, child.prototype);
        }
      },
      extend: function(source, target) {
        for (var key in source) {
          var descr = Object.getOwnPropertyDescriptor(source, key);
          if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
            Object.defineProperty(target, key, descr);
          }
        }
        return target;
      }
    };
    ICAL.design = function() {
      "use strict";
      var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
      var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
      var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
      var TO_VCARD_NEWLINE = /\\|,|\n/g;
      function createTextType(fromNewline, toNewline) {
        var result = {
          matches: /.*/,
          fromICAL: function(aValue, structuredEscape) {
            return replaceNewline(aValue, fromNewline, structuredEscape);
          },
          toICAL: function(aValue, structuredEscape) {
            var regEx = toNewline;
            if (structuredEscape)
              regEx = new RegExp(regEx.source + "|" + structuredEscape);
            return aValue.replace(regEx, function(str) {
              switch (str) {
                case "\\":
                  return "\\\\";
                case ";":
                  return "\\;";
                case ",":
                  return "\\,";
                case "\n":
                  return "\\n";
                default:
                  return str;
              }
            });
          }
        };
        return result;
      }
      var DEFAULT_TYPE_TEXT = { defaultType: "text" };
      var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
      var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
      var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
      var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
      var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
      var DEFAULT_TYPE_URI = { defaultType: "uri" };
      var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
      var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
      var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };
      function replaceNewlineReplace(string) {
        switch (string) {
          case "\\\\":
            return "\\";
          case "\\;":
            return ";";
          case "\\,":
            return ",";
          case "\\n":
          case "\\N":
            return "\n";
          default:
            return string;
        }
      }
      function replaceNewline(value, newline, structuredEscape) {
        if (value.indexOf("\\") === -1) {
          return value;
        }
        if (structuredEscape)
          newline = new RegExp(newline.source + "|\\\\" + structuredEscape);
        return value.replace(newline, replaceNewlineReplace);
      }
      var commonProperties = {
        "categories": DEFAULT_TYPE_TEXT_MULTI,
        "url": DEFAULT_TYPE_URI,
        "version": DEFAULT_TYPE_TEXT,
        "uid": DEFAULT_TYPE_TEXT
      };
      var commonValues = {
        "boolean": {
          values: ["TRUE", "FALSE"],
          fromICAL: function(aValue) {
            switch (aValue) {
              case "TRUE":
                return true;
              case "FALSE":
                return false;
              default:
                return false;
            }
          },
          toICAL: function(aValue) {
            if (aValue) {
              return "TRUE";
            }
            return "FALSE";
          }
        },
        float: {
          matches: /^[+-]?\d+\.\d+$/,
          fromICAL: function(aValue) {
            var parsed = parseFloat(aValue);
            if (ICAL.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        integer: {
          fromICAL: function(aValue) {
            var parsed = parseInt(aValue);
            if (ICAL.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        "utc-offset": {
          toICAL: function(aValue) {
            if (aValue.length < 7) {
              return aValue.substr(0, 3) + aValue.substr(4, 2);
            } else {
              return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);
            }
          },
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2);
            } else {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2) + ":" + aValue.substr(5, 2);
            }
          },
          decorate: function(aValue) {
            return ICAL.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      };
      var icalParams = {
        "cutype": {
          values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
          allowXName: true,
          allowIanaToken: true
        },
        "delegated-from": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "delegated-to": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "encoding": {
          values: ["8BIT", "BASE64"]
        },
        "fbtype": {
          values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
          allowXName: true,
          allowIanaToken: true
        },
        "member": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "partstat": {
          values: [
            "NEEDS-ACTION",
            "ACCEPTED",
            "DECLINED",
            "TENTATIVE",
            "DELEGATED",
            "COMPLETED",
            "IN-PROCESS"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "range": {
          values: ["THISANDFUTURE"]
        },
        "related": {
          values: ["START", "END"]
        },
        "reltype": {
          values: ["PARENT", "CHILD", "SIBLING"],
          allowXName: true,
          allowIanaToken: true
        },
        "role": {
          values: [
            "REQ-PARTICIPANT",
            "CHAIR",
            "OPT-PARTICIPANT",
            "NON-PARTICIPANT"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "rsvp": {
          values: ["TRUE", "FALSE"]
        },
        "sent-by": {
          valueType: "cal-address"
        },
        "tzid": {
          matches: /^\//
        },
        "value": {
          values: [
            "binary",
            "boolean",
            "cal-address",
            "date",
            "date-time",
            "duration",
            "float",
            "integer",
            "period",
            "recur",
            "text",
            "time",
            "uri",
            "utc-offset"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var icalValues = ICAL.helpers.extend(commonValues, {
        text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),
        uri: {},
        "binary": {
          decorate: function(aString) {
            return ICAL.Binary.fromString(aString);
          },
          undecorate: function(aBinary) {
            return aBinary.toString();
          }
        },
        "cal-address": {},
        "date": {
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL.Time.fromDateString(aValue, aProp);
            } else {
              return ICAL.Time.fromString(aValue, aProp);
            }
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length >= 15) {
              return icalValues["date-time"].fromICAL(aValue);
            } else {
              return aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2);
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10) {
              return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);
            } else if (len >= 19) {
              return icalValues["date-time"].toICAL(aValue);
            } else {
              return aValue;
            }
          }
        },
        "date-time": {
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else {
              var result = aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2) + "T" + aValue.substr(9, 2) + ":" + aValue.substr(11, 2) + ":" + aValue.substr(13, 2);
              if (aValue[15] && aValue[15] === "Z") {
                result += "Z";
              }
              return result;
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10 && !design.strict) {
              return icalValues.date.toICAL(aValue);
            } else if (len >= 19) {
              var result = aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 5) + aValue.substr(14, 2) + aValue.substr(17, 2);
              if (aValue[19] && aValue[19] === "Z") {
                result += "Z";
              }
              return result;
            } else {
              return aValue;
            }
          },
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL.Time.fromDateTimeString(aValue, aProp);
            } else {
              return ICAL.Time.fromString(aValue, aProp);
            }
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        duration: {
          decorate: function(aValue) {
            return ICAL.Duration.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        period: {
          fromICAL: function(string) {
            var parts = string.split("/");
            parts[0] = icalValues["date-time"].fromICAL(parts[0]);
            if (!ICAL.Duration.isValueString(parts[1])) {
              parts[1] = icalValues["date-time"].fromICAL(parts[1]);
            }
            return parts;
          },
          toICAL: function(parts) {
            if (!design.strict && parts[0].length == 10) {
              parts[0] = icalValues.date.toICAL(parts[0]);
            } else {
              parts[0] = icalValues["date-time"].toICAL(parts[0]);
            }
            if (!ICAL.Duration.isValueString(parts[1])) {
              if (!design.strict && parts[1].length == 10) {
                parts[1] = icalValues.date.toICAL(parts[1]);
              } else {
                parts[1] = icalValues["date-time"].toICAL(parts[1]);
              }
            }
            return parts.join("/");
          },
          decorate: function(aValue, aProp) {
            return ICAL.Period.fromJSON(aValue, aProp, !design.strict);
          },
          undecorate: function(aValue) {
            return aValue.toJSON();
          }
        },
        recur: {
          fromICAL: function(string) {
            return ICAL.Recur._stringToData(string, true);
          },
          toICAL: function(data) {
            var str = "";
            for (var k in data) {
              if (!Object.prototype.hasOwnProperty.call(data, k)) {
                continue;
              }
              var val = data[k];
              if (k == "until") {
                if (val.length > 10) {
                  val = icalValues["date-time"].toICAL(val);
                } else {
                  val = icalValues.date.toICAL(val);
                }
              } else if (k == "wkst") {
                if (typeof val === "number") {
                  val = ICAL.Recur.numericDayToIcalDay(val);
                }
              } else if (Array.isArray(val)) {
                val = val.join(",");
              }
              str += k.toUpperCase() + "=" + val + ";";
            }
            return str.substr(0, str.length - 1);
          },
          decorate: function decorate(aValue) {
            return ICAL.Recur.fromData(aValue);
          },
          undecorate: function(aRecur) {
            return aRecur.toJSON();
          }
        },
        time: {
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + ":" + aValue.substr(2, 2) + ":" + aValue.substr(4, 2);
            if (aValue[6] === "Z") {
              result += "Z";
            }
            return result;
          },
          toICAL: function(aValue) {
            if (aValue.length < 8) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);
            if (aValue[8] === "Z") {
              result += "Z";
            }
            return result;
          }
        }
      });
      var icalProperties = ICAL.helpers.extend(commonProperties, {
        "action": DEFAULT_TYPE_TEXT,
        "attach": { defaultType: "uri" },
        "attendee": { defaultType: "cal-address" },
        "calscale": DEFAULT_TYPE_TEXT,
        "class": DEFAULT_TYPE_TEXT,
        "comment": DEFAULT_TYPE_TEXT,
        "completed": DEFAULT_TYPE_DATETIME,
        "contact": DEFAULT_TYPE_TEXT,
        "created": DEFAULT_TYPE_DATETIME,
        "description": DEFAULT_TYPE_TEXT,
        "dtend": DEFAULT_TYPE_DATETIME_DATE,
        "dtstamp": DEFAULT_TYPE_DATETIME,
        "dtstart": DEFAULT_TYPE_DATETIME_DATE,
        "due": DEFAULT_TYPE_DATETIME_DATE,
        "duration": { defaultType: "duration" },
        "exdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          multiValue: ","
        },
        "exrule": DEFAULT_TYPE_RECUR,
        "freebusy": { defaultType: "period", multiValue: "," },
        "geo": { defaultType: "float", structuredValue: ";" },
        "last-modified": DEFAULT_TYPE_DATETIME,
        "location": DEFAULT_TYPE_TEXT,
        "method": DEFAULT_TYPE_TEXT,
        "organizer": { defaultType: "cal-address" },
        "percent-complete": DEFAULT_TYPE_INTEGER,
        "priority": DEFAULT_TYPE_INTEGER,
        "prodid": DEFAULT_TYPE_TEXT,
        "related-to": DEFAULT_TYPE_TEXT,
        "repeat": DEFAULT_TYPE_INTEGER,
        "rdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date", "period"],
          multiValue: ",",
          detectType: function(string) {
            if (string.indexOf("/") !== -1) {
              return "period";
            }
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
        "resources": DEFAULT_TYPE_TEXT_MULTI,
        "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
        "rrule": DEFAULT_TYPE_RECUR,
        "sequence": DEFAULT_TYPE_INTEGER,
        "status": DEFAULT_TYPE_TEXT,
        "summary": DEFAULT_TYPE_TEXT,
        "transp": DEFAULT_TYPE_TEXT,
        "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
        "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
        "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
        "tzurl": DEFAULT_TYPE_URI,
        "tzid": DEFAULT_TYPE_TEXT,
        "tzname": DEFAULT_TYPE_TEXT
      });
      var vcardValues = ICAL.helpers.extend(commonValues, {
        text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        date: {
          decorate: function(aValue) {
            return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 6) {
              return aValue.substr(0, 4) + "-" + aValue.substr(4);
            } else {
              return aValue;
            }
          },
          toICAL: function(aValue) {
            if (aValue.length == 10) {
              return icalValues.date.toICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 7) {
              return aValue.substr(0, 4) + aValue.substr(5);
            } else {
              return aValue;
            }
          }
        },
        time: {
          decorate: function(aValue) {
            return ICAL.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue, true);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 6) {
              value = value.substr(0, 2) + ":" + value.substr(2, 2) + ":" + value.substr(4, 2);
            } else if (value.length == 4 && value[0] != "-") {
              value = value.substr(0, 2) + ":" + value.substr(2, 2);
            } else if (value.length == 5) {
              value = value.substr(0, 3) + ":" + value.substr(3, 2);
            }
            if (zone.length == 5 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + ":" + zone.substr(3);
            }
            return value + zone;
          },
          toICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 8) {
              value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);
            } else if (value.length == 5 && value[0] != "-") {
              value = value.substr(0, 2) + value.substr(3, 2);
            } else if (value.length == 6) {
              value = value.substr(0, 3) + value.substr(4, 2);
            }
            if (zone.length == 6 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + zone.substr(4);
            }
            return value + zone;
          },
          _splitZone: function(aValue, isFromIcal) {
            var lastChar = aValue.length - 1;
            var signChar = aValue.length - (isFromIcal ? 5 : 6);
            var sign = aValue[signChar];
            var zone, value;
            if (aValue[lastChar] == "Z") {
              zone = aValue[lastChar];
              value = aValue.substr(0, lastChar);
            } else if (aValue.length > 6 && (sign == "-" || sign == "+")) {
              zone = aValue.substr(signChar);
              value = aValue.substr(0, signChar);
            } else {
              zone = "";
              value = aValue;
            }
            return [zone, value];
          }
        },
        "date-time": {
          decorate: function(aValue) {
            return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            return vcardValues["date-and-or-time"].fromICAL(aValue);
          },
          toICAL: function(aValue) {
            return vcardValues["date-and-or-time"].toICAL(aValue);
          }
        },
        "date-and-or-time": {
          decorate: function(aValue) {
            return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var parts = aValue.split("T");
            return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : "") + (parts[1] ? "T" + vcardValues.time.fromICAL(parts[1]) : "");
          },
          toICAL: function(aValue) {
            var parts = aValue.split("T");
            return vcardValues.date.toICAL(parts[0]) + (parts[1] ? "T" + vcardValues.time.toICAL(parts[1]) : "");
          }
        },
        timestamp: icalValues["date-time"],
        "language-tag": {
          matches: /^[a-zA-Z0-9-]+$/
        }
      });
      var vcardParams = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          values: [
            "text",
            "uri",
            "date",
            "time",
            "date-time",
            "date-and-or-time",
            "timestamp",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "language-tag"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcardProperties = ICAL.helpers.extend(commonProperties, {
        "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "caladruri": DEFAULT_TYPE_URI,
        "caluri": DEFAULT_TYPE_URI,
        "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
        "email": DEFAULT_TYPE_TEXT,
        "fburl": DEFAULT_TYPE_URI,
        "fn": DEFAULT_TYPE_TEXT,
        "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
        "geo": DEFAULT_TYPE_URI,
        "impp": DEFAULT_TYPE_URI,
        "key": DEFAULT_TYPE_URI,
        "kind": DEFAULT_TYPE_TEXT,
        "lang": { defaultType: "language-tag" },
        "logo": DEFAULT_TYPE_URI,
        "member": DEFAULT_TYPE_URI,
        "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "nickname": DEFAULT_TYPE_TEXT_MULTI,
        "note": DEFAULT_TYPE_TEXT,
        "org": { defaultType: "text", structuredValue: ";" },
        "photo": DEFAULT_TYPE_URI,
        "related": DEFAULT_TYPE_URI,
        "rev": { defaultType: "timestamp" },
        "role": DEFAULT_TYPE_TEXT,
        "sound": DEFAULT_TYPE_URI,
        "source": DEFAULT_TYPE_URI,
        "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
        "title": DEFAULT_TYPE_TEXT,
        "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
        "xml": DEFAULT_TYPE_TEXT
      });
      var vcard3Values = ICAL.helpers.extend(commonValues, {
        binary: icalValues.binary,
        date: vcardValues.date,
        "date-time": vcardValues["date-time"],
        "phone-number": {},
        uri: icalValues.uri,
        text: icalValues.text,
        time: icalValues.time,
        vcard: icalValues.text,
        "utc-offset": {
          toICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          fromICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          decorate: function(aValue) {
            return ICAL.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      });
      var vcard3Params = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          values: [
            "text",
            "uri",
            "date",
            "date-time",
            "phone-number",
            "time",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "vcard",
            "binary"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcard3Properties = ICAL.helpers.extend(commonProperties, {
        fn: DEFAULT_TYPE_TEXT,
        n: { defaultType: "text", structuredValue: ";", multiValue: "," },
        nickname: DEFAULT_TYPE_TEXT_MULTI,
        photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        bday: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
        label: DEFAULT_TYPE_TEXT,
        tel: { defaultType: "phone-number" },
        email: DEFAULT_TYPE_TEXT,
        mailer: DEFAULT_TYPE_TEXT,
        tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
        geo: { defaultType: "float", structuredValue: ";" },
        title: DEFAULT_TYPE_TEXT,
        role: DEFAULT_TYPE_TEXT,
        logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
        org: DEFAULT_TYPE_TEXT_STRUCTURED,
        note: DEFAULT_TYPE_TEXT_MULTI,
        prodid: DEFAULT_TYPE_TEXT,
        rev: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "sort-string": DEFAULT_TYPE_TEXT,
        sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        class: DEFAULT_TYPE_TEXT,
        key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
      });
      var icalSet = {
        value: icalValues,
        param: icalParams,
        property: icalProperties
      };
      var vcardSet = {
        value: vcardValues,
        param: vcardParams,
        property: vcardProperties
      };
      var vcard3Set = {
        value: vcard3Values,
        param: vcard3Params,
        property: vcard3Properties
      };
      var design = {
        strict: true,
        defaultSet: icalSet,
        defaultType: "unknown",
        components: {
          vcard: vcardSet,
          vcard3: vcard3Set,
          vevent: icalSet,
          vtodo: icalSet,
          vjournal: icalSet,
          valarm: icalSet,
          vtimezone: icalSet,
          daylight: icalSet,
          standard: icalSet
        },
        icalendar: icalSet,
        vcard: vcardSet,
        vcard3: vcard3Set,
        getDesignSet: function(componentName) {
          var isInDesign = componentName && componentName in design.components;
          return isInDesign ? design.components[componentName] : design.defaultSet;
        }
      };
      return design;
    }();
    ICAL.stringify = function() {
      "use strict";
      var LINE_ENDING = "\r\n";
      var DEFAULT_VALUE_TYPE = "unknown";
      var design = ICAL.design;
      var helpers = ICAL.helpers;
      function stringify(jCal) {
        if (typeof jCal[0] == "string") {
          jCal = [jCal];
        }
        var i = 0;
        var len = jCal.length;
        var result = "";
        for (; i < len; i++) {
          result += stringify.component(jCal[i]) + LINE_ENDING;
        }
        return result;
      }
      stringify.component = function(component, designSet) {
        var name = component[0].toUpperCase();
        var result = "BEGIN:" + name + LINE_ENDING;
        var props = component[1];
        var propIdx = 0;
        var propLen = props.length;
        var designSetName = component[0];
        if (designSetName === "vcard" && component[1].length > 0 && !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
          designSetName = "vcard3";
        }
        designSet = designSet || design.getDesignSet(designSetName);
        for (; propIdx < propLen; propIdx++) {
          result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
        }
        var comps = component[2] || [];
        var compIdx = 0;
        var compLen = comps.length;
        for (; compIdx < compLen; compIdx++) {
          result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
        }
        result += "END:" + name;
        return result;
      };
      stringify.property = function(property, designSet, noFold) {
        var name = property[0].toUpperCase();
        var jsName = property[0];
        var params = property[1];
        var line = name;
        var paramName;
        for (paramName in params) {
          var value = params[paramName];
          if (params.hasOwnProperty(paramName)) {
            var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;
            if (multiValue && Array.isArray(value)) {
              if (designSet.param[paramName].multiValueSeparateDQuote) {
                multiValue = '"' + multiValue + '"';
              }
              value = value.map(stringify._rfc6868Unescape);
              value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
            } else {
              value = stringify._rfc6868Unescape(value);
            }
            line += ";" + paramName.toUpperCase();
            line += "=" + stringify.propertyValue(value);
          }
        }
        if (property.length === 3) {
          return line + ":";
        }
        var valueType = property[2];
        if (!designSet) {
          designSet = design.defaultSet;
        }
        var propDetails;
        var multiValue = false;
        var structuredValue = false;
        var isDefault = false;
        if (jsName in designSet.property) {
          propDetails = designSet.property[jsName];
          if ("multiValue" in propDetails) {
            multiValue = propDetails.multiValue;
          }
          if ("structuredValue" in propDetails && Array.isArray(property[3])) {
            structuredValue = propDetails.structuredValue;
          }
          if ("defaultType" in propDetails) {
            if (valueType === propDetails.defaultType) {
              isDefault = true;
            }
          } else {
            if (valueType === DEFAULT_VALUE_TYPE) {
              isDefault = true;
            }
          }
        } else {
          if (valueType === DEFAULT_VALUE_TYPE) {
            isDefault = true;
          }
        }
        if (!isDefault) {
          line += ";VALUE=" + valueType.toUpperCase();
        }
        line += ":";
        if (multiValue && structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            multiValue,
            designSet,
            structuredValue
          );
        } else if (multiValue) {
          line += stringify.multiValue(
            property.slice(3),
            multiValue,
            valueType,
            null,
            designSet,
            false
          );
        } else if (structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            null,
            designSet,
            structuredValue
          );
        } else {
          line += stringify.value(property[3], valueType, designSet, false);
        }
        return noFold ? line : ICAL.helpers.foldline(line);
      };
      stringify.propertyValue = function(value) {
        if (helpers.unescapedIndexOf(value, ",") === -1 && helpers.unescapedIndexOf(value, ":") === -1 && helpers.unescapedIndexOf(value, ";") === -1) {
          return value;
        }
        return '"' + value + '"';
      };
      stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
        var result = "";
        var len = values.length;
        var i = 0;
        for (; i < len; i++) {
          if (innerMulti && Array.isArray(values[i])) {
            result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);
          } else {
            result += stringify.value(values[i], type, designSet, structuredValue);
          }
          if (i !== len - 1) {
            result += delim;
          }
        }
        return result;
      };
      stringify.value = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "toICAL" in designSet.value[type]) {
          return designSet.value[type].toICAL(value, structuredValue);
        }
        return value;
      };
      stringify._rfc6868Unescape = function(val) {
        return val.replace(/[\n^"]/g, function(x) {
          return RFC6868_REPLACE_MAP[x];
        });
      };
      var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };
      return stringify;
    }();
    ICAL.parse = function() {
      "use strict";
      var CHAR = /[^ \t]/;
      var MULTIVALUE_DELIMITER = ",";
      var VALUE_DELIMITER = ":";
      var PARAM_DELIMITER = ";";
      var PARAM_NAME_DELIMITER = "=";
      var DEFAULT_VALUE_TYPE = "unknown";
      var DEFAULT_PARAM_TYPE = "text";
      var design = ICAL.design;
      var helpers = ICAL.helpers;
      function ParserError(message) {
        this.message = message;
        this.name = "ParserError";
        try {
          throw new Error();
        } catch (e) {
          if (e.stack) {
            var split = e.stack.split("\n");
            split.shift();
            this.stack = split.join("\n");
          }
        }
      }
      ParserError.prototype = Error.prototype;
      function parser(input2) {
        var state = {};
        var root = state.component = [];
        state.stack = [root];
        parser._eachLine(input2, function(err, line) {
          parser._handleContentLine(line, state);
        });
        if (state.stack.length > 1) {
          throw new ParserError(
            "invalid ical body. component began but did not end"
          );
        }
        state = null;
        return root.length == 1 ? root[0] : root;
      }
      parser.property = function(str, designSet) {
        var state = {
          component: [[], []],
          designSet: designSet || design.defaultSet
        };
        parser._handleContentLine(str, state);
        return state.component[1][0];
      };
      parser.component = function(str) {
        return parser(str);
      };
      parser.ParserError = ParserError;
      parser._handleContentLine = function(line, state) {
        var valuePos = line.indexOf(VALUE_DELIMITER);
        var paramPos = line.indexOf(PARAM_DELIMITER);
        var lastParamIndex;
        var lastValuePos;
        var name;
        var value;
        var params = {};
        if (paramPos !== -1 && valuePos !== -1) {
          if (paramPos > valuePos) {
            paramPos = -1;
          }
        }
        var parsedParams;
        if (paramPos !== -1) {
          name = line.substring(0, paramPos).toLowerCase();
          parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);
          if (parsedParams[2] == -1) {
            throw new ParserError("Invalid parameters in '" + line + "'");
          }
          params = parsedParams[0];
          lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
          if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
            value = line.substring(lastParamIndex + lastValuePos + 1);
          } else {
            throw new ParserError("Missing parameter value in '" + line + "'");
          }
        } else if (valuePos !== -1) {
          name = line.substring(0, valuePos).toLowerCase();
          value = line.substring(valuePos + 1);
          if (name === "begin") {
            var newComponent = [value.toLowerCase(), [], []];
            if (state.stack.length === 1) {
              state.component.push(newComponent);
            } else {
              state.component[2].push(newComponent);
            }
            state.stack.push(state.component);
            state.component = newComponent;
            if (!state.designSet) {
              state.designSet = design.getDesignSet(state.component[0]);
            }
            return;
          } else if (name === "end") {
            state.component = state.stack.pop();
            return;
          }
        } else {
          throw new ParserError(
            'invalid line (no token ";" or ":") "' + line + '"'
          );
        }
        var valueType;
        var multiValue = false;
        var structuredValue = false;
        var propertyDetails;
        if (name in state.designSet.property) {
          propertyDetails = state.designSet.property[name];
          if ("multiValue" in propertyDetails) {
            multiValue = propertyDetails.multiValue;
          }
          if ("structuredValue" in propertyDetails) {
            structuredValue = propertyDetails.structuredValue;
          }
          if (value && "detectType" in propertyDetails) {
            valueType = propertyDetails.detectType(value);
          }
        }
        if (!valueType) {
          if (!("value" in params)) {
            if (propertyDetails) {
              valueType = propertyDetails.defaultType;
            } else {
              valueType = DEFAULT_VALUE_TYPE;
            }
          } else {
            valueType = params.value.toLowerCase();
          }
        }
        delete params.value;
        var result;
        if (multiValue && structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else if (multiValue) {
          result = [name, params, valueType];
          parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
        } else if (structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else {
          value = parser._parseValue(value, valueType, state.designSet, false);
          result = [name, params, valueType, value];
        }
        if (state.component[0] === "vcard" && state.component[1].length === 0 && !(name === "version" && value === "4.0")) {
          state.designSet = design.getDesignSet("vcard3");
        }
        state.component[1].push(result);
      };
      parser._parseValue = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "fromICAL" in designSet.value[type]) {
          return designSet.value[type].fromICAL(value, structuredValue);
        }
        return value;
      };
      parser._parseParameters = function(line, start, designSet) {
        var lastParam = start;
        var pos = 0;
        var delim = PARAM_NAME_DELIMITER;
        var result = {};
        var name, lcname;
        var value, valuePos = -1;
        var type, multiValue, mvdelim;
        while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {
          name = line.substr(lastParam + 1, pos - lastParam - 1);
          if (name.length == 0) {
            throw new ParserError("Empty parameter name in '" + line + "'");
          }
          lcname = name.toLowerCase();
          mvdelim = false;
          multiValue = false;
          if (lcname in designSet.param && designSet.param[lcname].valueType) {
            type = designSet.param[lcname].valueType;
          } else {
            type = DEFAULT_PARAM_TYPE;
          }
          if (lcname in designSet.param) {
            multiValue = designSet.param[lcname].multiValue;
            if (designSet.param[lcname].multiValueSeparateDQuote) {
              mvdelim = parser._rfc6868Escape('"' + multiValue + '"');
            }
          }
          var nextChar = line[pos + 1];
          if (nextChar === '"') {
            valuePos = pos + 2;
            pos = helpers.unescapedIndexOf(line, '"', valuePos);
            if (multiValue && pos != -1) {
              var extendedValue = true;
              while (extendedValue) {
                if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                  pos = helpers.unescapedIndexOf(line, '"', pos + 3);
                } else {
                  extendedValue = false;
                }
              }
            }
            if (pos === -1) {
              throw new ParserError(
                'invalid line (no matching double quote) "' + line + '"'
              );
            }
            value = line.substr(valuePos, pos - valuePos);
            lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
            if (lastParam === -1) {
              pos = false;
            }
          } else {
            valuePos = pos + 1;
            var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
            var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
            if (propValuePos !== -1 && nextPos > propValuePos) {
              nextPos = propValuePos;
              pos = false;
            } else if (nextPos === -1) {
              if (propValuePos === -1) {
                nextPos = line.length;
              } else {
                nextPos = propValuePos;
              }
              pos = false;
            } else {
              lastParam = nextPos;
              pos = nextPos;
            }
            value = line.substr(valuePos, nextPos - valuePos);
          }
          value = parser._rfc6868Escape(value);
          if (multiValue) {
            var delimiter = mvdelim || multiValue;
            value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);
          } else {
            value = parser._parseValue(value, type, designSet);
          }
          if (multiValue && lcname in result) {
            if (Array.isArray(result[lcname])) {
              result[lcname].push(value);
            } else {
              result[lcname] = [
                result[lcname],
                value
              ];
            }
          } else {
            result[lcname] = value;
          }
        }
        return [result, value, valuePos];
      };
      parser._rfc6868Escape = function(val) {
        return val.replace(/\^['n^]/g, function(x) {
          return RFC6868_REPLACE_MAP[x];
        });
      };
      var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };
      parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
        var pos = 0;
        var lastPos = 0;
        var value;
        if (delim.length === 0) {
          return buffer;
        }
        while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
          value = buffer.substr(lastPos, pos - lastPos);
          if (innerMulti) {
            value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
          } else {
            value = parser._parseValue(value, type, designSet, structuredValue);
          }
          result.push(value);
          lastPos = pos + delim.length;
        }
        value = buffer.substr(lastPos);
        if (innerMulti) {
          value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
        } else {
          value = parser._parseValue(value, type, designSet, structuredValue);
        }
        result.push(value);
        return result.length == 1 ? result[0] : result;
      };
      parser._eachLine = function(buffer, callback) {
        var len = buffer.length;
        var lastPos = buffer.search(CHAR);
        var pos = lastPos;
        var line;
        var firstChar;
        var newlineOffset;
        do {
          pos = buffer.indexOf("\n", lastPos) + 1;
          if (pos > 1 && buffer[pos - 2] === "\r") {
            newlineOffset = 2;
          } else {
            newlineOffset = 1;
          }
          if (pos === 0) {
            pos = len;
            newlineOffset = 0;
          }
          firstChar = buffer[lastPos];
          if (firstChar === " " || firstChar === "	") {
            line += buffer.substr(
              lastPos + 1,
              pos - lastPos - (newlineOffset + 1)
            );
          } else {
            if (line)
              callback(null, line);
            line = buffer.substr(
              lastPos,
              pos - lastPos - newlineOffset
            );
          }
          lastPos = pos;
        } while (pos !== len);
        line = line.trim();
        if (line.length)
          callback(null, line);
      };
      return parser;
    }();
    ICAL.Component = function() {
      "use strict";
      var PROPERTY_INDEX = 1;
      var COMPONENT_INDEX = 2;
      var NAME_INDEX = 0;
      function Component(jCal, parent) {
        if (typeof jCal === "string") {
          jCal = [jCal, [], []];
        }
        this.jCal = jCal;
        this.parent = parent || null;
      }
      Component.prototype = {
        _hydratedPropertyCount: 0,
        _hydratedComponentCount: 0,
        get name() {
          return this.jCal[NAME_INDEX];
        },
        get _designSet() {
          var parentDesign = this.parent && this.parent._designSet;
          return parentDesign || ICAL.design.getDesignSet(this.name);
        },
        _hydrateComponent: function(index) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (this._components[index]) {
            return this._components[index];
          }
          var comp = new Component(
            this.jCal[COMPONENT_INDEX][index],
            this
          );
          this._hydratedComponentCount++;
          return this._components[index] = comp;
        },
        _hydrateProperty: function(index) {
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (this._properties[index]) {
            return this._properties[index];
          }
          var prop = new ICAL.Property(
            this.jCal[PROPERTY_INDEX][index],
            this
          );
          this._hydratedPropertyCount++;
          return this._properties[index] = prop;
        },
        getFirstSubcomponent: function(name) {
          if (name) {
            var i = 0;
            var comps = this.jCal[COMPONENT_INDEX];
            var len = comps.length;
            for (; i < len; i++) {
              if (comps[i][NAME_INDEX] === name) {
                var result = this._hydrateComponent(i);
                return result;
              }
            }
          } else {
            if (this.jCal[COMPONENT_INDEX].length) {
              return this._hydrateComponent(0);
            }
          }
          return null;
        },
        getAllSubcomponents: function(name) {
          var jCalLen = this.jCal[COMPONENT_INDEX].length;
          var i = 0;
          if (name) {
            var comps = this.jCal[COMPONENT_INDEX];
            var result = [];
            for (; i < jCalLen; i++) {
              if (name === comps[i][NAME_INDEX]) {
                result.push(
                  this._hydrateComponent(i)
                );
              }
            }
            return result;
          } else {
            if (!this._components || this._hydratedComponentCount !== jCalLen) {
              for (; i < jCalLen; i++) {
                this._hydrateComponent(i);
              }
            }
            return this._components || [];
          }
        },
        hasProperty: function(name) {
          var props = this.jCal[PROPERTY_INDEX];
          var len = props.length;
          var i = 0;
          for (; i < len; i++) {
            if (props[i][NAME_INDEX] === name) {
              return true;
            }
          }
          return false;
        },
        getFirstProperty: function(name) {
          if (name) {
            var i = 0;
            var props = this.jCal[PROPERTY_INDEX];
            var len = props.length;
            for (; i < len; i++) {
              if (props[i][NAME_INDEX] === name) {
                var result = this._hydrateProperty(i);
                return result;
              }
            }
          } else {
            if (this.jCal[PROPERTY_INDEX].length) {
              return this._hydrateProperty(0);
            }
          }
          return null;
        },
        getFirstPropertyValue: function(name) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            return prop.getFirstValue();
          }
          return null;
        },
        getAllProperties: function(name) {
          var jCalLen = this.jCal[PROPERTY_INDEX].length;
          var i = 0;
          if (name) {
            var props = this.jCal[PROPERTY_INDEX];
            var result = [];
            for (; i < jCalLen; i++) {
              if (name === props[i][NAME_INDEX]) {
                result.push(
                  this._hydrateProperty(i)
                );
              }
            }
            return result;
          } else {
            if (!this._properties || this._hydratedPropertyCount !== jCalLen) {
              for (; i < jCalLen; i++) {
                this._hydrateProperty(i);
              }
            }
            return this._properties || [];
          }
        },
        _removeObjectByIndex: function(jCalIndex, cache, index) {
          cache = cache || [];
          if (cache[index]) {
            var obj = cache[index];
            if ("parent" in obj) {
              obj.parent = null;
            }
          }
          cache.splice(index, 1);
          this.jCal[jCalIndex].splice(index, 1);
        },
        _removeObject: function(jCalIndex, cache, nameOrObject) {
          var i = 0;
          var objects = this.jCal[jCalIndex];
          var len = objects.length;
          var cached = this[cache];
          if (typeof nameOrObject === "string") {
            for (; i < len; i++) {
              if (objects[i][NAME_INDEX] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i);
                return true;
              }
            }
          } else if (cached) {
            for (; i < len; i++) {
              if (cached[i] && cached[i] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i);
                return true;
              }
            }
          }
          return false;
        },
        _removeAllObjects: function(jCalIndex, cache, name) {
          var cached = this[cache];
          var objects = this.jCal[jCalIndex];
          var i = objects.length - 1;
          for (; i >= 0; i--) {
            if (!name || objects[i][NAME_INDEX] === name) {
              this._removeObjectByIndex(jCalIndex, cached, i);
            }
          }
        },
        addSubcomponent: function(component) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (component.parent) {
            component.parent.removeSubcomponent(component);
          }
          var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
          this._components[idx - 1] = component;
          this._hydratedComponentCount++;
          component.parent = this;
          return component;
        },
        removeSubcomponent: function(nameOrComp) {
          var removed = this._removeObject(COMPONENT_INDEX, "_components", nameOrComp);
          if (removed) {
            this._hydratedComponentCount--;
          }
          return removed;
        },
        removeAllSubcomponents: function(name) {
          var removed = this._removeAllObjects(COMPONENT_INDEX, "_components", name);
          this._hydratedComponentCount = 0;
          return removed;
        },
        addProperty: function(property) {
          if (!(property instanceof ICAL.Property)) {
            throw new TypeError("must instance of ICAL.Property");
          }
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (property.parent) {
            property.parent.removeProperty(property);
          }
          var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
          this._properties[idx - 1] = property;
          this._hydratedPropertyCount++;
          property.parent = this;
          return property;
        },
        addPropertyWithValue: function(name, value) {
          var prop = new ICAL.Property(name);
          prop.setValue(value);
          this.addProperty(prop);
          return prop;
        },
        updatePropertyWithValue: function(name, value) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            prop.setValue(value);
          } else {
            prop = this.addPropertyWithValue(name, value);
          }
          return prop;
        },
        removeProperty: function(nameOrProp) {
          var removed = this._removeObject(PROPERTY_INDEX, "_properties", nameOrProp);
          if (removed) {
            this._hydratedPropertyCount--;
          }
          return removed;
        },
        removeAllProperties: function(name) {
          var removed = this._removeAllObjects(PROPERTY_INDEX, "_properties", name);
          this._hydratedPropertyCount = 0;
          return removed;
        },
        toJSON: function() {
          return this.jCal;
        },
        toString: function() {
          return ICAL.stringify.component(
            this.jCal,
            this._designSet
          );
        }
      };
      Component.fromString = function(str) {
        return new Component(ICAL.parse.component(str));
      };
      return Component;
    }();
    ICAL.Property = function() {
      "use strict";
      var NAME_INDEX = 0;
      var PROP_INDEX = 1;
      var TYPE_INDEX = 2;
      var VALUE_INDEX = 3;
      var design = ICAL.design;
      function Property(jCal, parent) {
        this._parent = parent || null;
        if (typeof jCal === "string") {
          this.jCal = [jCal, {}, design.defaultType];
          this.jCal[TYPE_INDEX] = this.getDefaultType();
        } else {
          this.jCal = jCal;
        }
        this._updateType();
      }
      Property.prototype = {
        get type() {
          return this.jCal[TYPE_INDEX];
        },
        get name() {
          return this.jCal[NAME_INDEX];
        },
        get parent() {
          return this._parent;
        },
        set parent(p) {
          var designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;
          this._parent = p;
          if (this.type == design.defaultType && designSetChanged) {
            this.jCal[TYPE_INDEX] = this.getDefaultType();
            this._updateType();
          }
          return p;
        },
        get _designSet() {
          return this.parent ? this.parent._designSet : design.defaultSet;
        },
        _updateType: function() {
          var designSet = this._designSet;
          if (this.type in designSet.value) {
            var designType = designSet.value[this.type];
            if ("decorate" in designSet.value[this.type]) {
              this.isDecorated = true;
            } else {
              this.isDecorated = false;
            }
            if (this.name in designSet.property) {
              this.isMultiValue = "multiValue" in designSet.property[this.name];
              this.isStructuredValue = "structuredValue" in designSet.property[this.name];
            }
          }
        },
        _hydrateValue: function(index) {
          if (this._values && this._values[index]) {
            return this._values[index];
          }
          if (this.jCal.length <= VALUE_INDEX + index) {
            return null;
          }
          if (this.isDecorated) {
            if (!this._values) {
              this._values = [];
            }
            return this._values[index] = this._decorate(
              this.jCal[VALUE_INDEX + index]
            );
          } else {
            return this.jCal[VALUE_INDEX + index];
          }
        },
        _decorate: function(value) {
          return this._designSet.value[this.type].decorate(value, this);
        },
        _undecorate: function(value) {
          return this._designSet.value[this.type].undecorate(value, this);
        },
        _setDecoratedValue: function(value, index) {
          if (!this._values) {
            this._values = [];
          }
          if (typeof value === "object" && "icaltype" in value) {
            this.jCal[VALUE_INDEX + index] = this._undecorate(value);
            this._values[index] = value;
          } else {
            this.jCal[VALUE_INDEX + index] = value;
            this._values[index] = this._decorate(value);
          }
        },
        getParameter: function(name) {
          if (name in this.jCal[PROP_INDEX]) {
            return this.jCal[PROP_INDEX][name];
          } else {
            return void 0;
          }
        },
        getFirstParameter: function(name) {
          var parameters = this.getParameter(name);
          if (Array.isArray(parameters)) {
            return parameters[0];
          }
          return parameters;
        },
        setParameter: function(name, value) {
          var lcname = name.toLowerCase();
          if (typeof value === "string" && lcname in this._designSet.param && "multiValue" in this._designSet.param[lcname]) {
            value = [value];
          }
          this.jCal[PROP_INDEX][name] = value;
        },
        removeParameter: function(name) {
          delete this.jCal[PROP_INDEX][name];
        },
        getDefaultType: function() {
          var name = this.jCal[NAME_INDEX];
          var designSet = this._designSet;
          if (name in designSet.property) {
            var details = designSet.property[name];
            if ("defaultType" in details) {
              return details.defaultType;
            }
          }
          return design.defaultType;
        },
        resetType: function(type) {
          this.removeAllValues();
          this.jCal[TYPE_INDEX] = type;
          this._updateType();
        },
        getFirstValue: function() {
          return this._hydrateValue(0);
        },
        getValues: function() {
          var len = this.jCal.length - VALUE_INDEX;
          if (len < 1) {
            return [];
          }
          var i = 0;
          var result = [];
          for (; i < len; i++) {
            result[i] = this._hydrateValue(i);
          }
          return result;
        },
        removeAllValues: function() {
          if (this._values) {
            this._values.length = 0;
          }
          this.jCal.length = 3;
        },
        setValues: function(values) {
          if (!this.isMultiValue) {
            throw new Error(
              this.name + ": does not not support mulitValue.\noverride isMultiValue"
            );
          }
          var len = values.length;
          var i = 0;
          this.removeAllValues();
          if (len > 0 && typeof values[0] === "object" && "icaltype" in values[0]) {
            this.resetType(values[0].icaltype);
          }
          if (this.isDecorated) {
            for (; i < len; i++) {
              this._setDecoratedValue(values[i], i);
            }
          } else {
            for (; i < len; i++) {
              this.jCal[VALUE_INDEX + i] = values[i];
            }
          }
        },
        setValue: function(value) {
          this.removeAllValues();
          if (typeof value === "object" && "icaltype" in value) {
            this.resetType(value.icaltype);
          }
          if (this.isDecorated) {
            this._setDecoratedValue(value, 0);
          } else {
            this.jCal[VALUE_INDEX] = value;
          }
        },
        toJSON: function() {
          return this.jCal;
        },
        toICALString: function() {
          return ICAL.stringify.property(
            this.jCal,
            this._designSet,
            true
          );
        }
      };
      Property.fromString = function(str, designSet) {
        return new Property(ICAL.parse.property(str, designSet));
      };
      return Property;
    }();
    ICAL.UtcOffset = function() {
      function UtcOffset(aData) {
        this.fromData(aData);
      }
      UtcOffset.prototype = {
        hours: 0,
        minutes: 0,
        factor: 1,
        icaltype: "utc-offset",
        clone: function() {
          return ICAL.UtcOffset.fromSeconds(this.toSeconds());
        },
        fromData: function(aData) {
          if (aData) {
            for (var key in aData) {
              if (aData.hasOwnProperty(key)) {
                this[key] = aData[key];
              }
            }
          }
          this._normalize();
        },
        fromSeconds: function(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.factor = aSeconds < 0 ? -1 : 1;
          this.hours = ICAL.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL.helpers.trunc(secs / 60);
          return this;
        },
        toSeconds: function() {
          return this.factor * (60 * this.minutes + 3600 * this.hours);
        },
        compare: function icaltime_compare(other) {
          var a = this.toSeconds();
          var b = other.toSeconds();
          return (a > b) - (b > a);
        },
        _normalize: function() {
          var secs = this.toSeconds();
          var factor = this.factor;
          while (secs < -43200) {
            secs += 97200;
          }
          while (secs > 50400) {
            secs -= 97200;
          }
          this.fromSeconds(secs);
          if (secs == 0) {
            this.factor = factor;
          }
        },
        toICALString: function() {
          return ICAL.design.icalendar.value["utc-offset"].toICAL(this.toString());
        },
        toString: function toString() {
          return (this.factor == 1 ? "+" : "-") + ICAL.helpers.pad2(this.hours) + ":" + ICAL.helpers.pad2(this.minutes);
        }
      };
      UtcOffset.fromString = function(aString) {
        var options = {};
        options.factor = aString[0] === "+" ? 1 : -1;
        options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));
        options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));
        return new ICAL.UtcOffset(options);
      };
      UtcOffset.fromSeconds = function(aSeconds) {
        var instance = new UtcOffset();
        instance.fromSeconds(aSeconds);
        return instance;
      };
      return UtcOffset;
    }();
    ICAL.Binary = function() {
      function Binary(aValue) {
        this.value = aValue;
      }
      Binary.prototype = {
        icaltype: "binary",
        decodeValue: function decodeValue() {
          return this._b64_decode(this.value);
        },
        setEncodedValue: function setEncodedValue(aValue) {
          this.value = this._b64_encode(aValue);
        },
        _b64_encode: function base64_encode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          do {
            o1 = data.charCodeAt(i++);
            o2 = data.charCodeAt(i++);
            o3 = data.charCodeAt(i++);
            bits = o1 << 16 | o2 << 8 | o3;
            h1 = bits >> 18 & 63;
            h2 = bits >> 12 & 63;
            h3 = bits >> 6 & 63;
            h4 = bits & 63;
            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
          } while (i < data.length);
          enc = tmp_arr.join("");
          var r = data.length % 3;
          return (r ? enc.slice(0, r - 3) : enc) + "===".slice(r || 3);
        },
        _b64_decode: function base64_decode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          data += "";
          do {
            h1 = b64.indexOf(data.charAt(i++));
            h2 = b64.indexOf(data.charAt(i++));
            h3 = b64.indexOf(data.charAt(i++));
            h4 = b64.indexOf(data.charAt(i++));
            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;
            o1 = bits >> 16 & 255;
            o2 = bits >> 8 & 255;
            o3 = bits & 255;
            if (h3 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1);
            } else if (h4 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1, o2);
            } else {
              tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
            }
          } while (i < data.length);
          dec = tmp_arr.join("");
          return dec;
        },
        toString: function() {
          return this.value;
        }
      };
      Binary.fromString = function(aString) {
        return new Binary(aString);
      };
      return Binary;
    }();
    (function() {
      ICAL.Period = function icalperiod(aData) {
        this.wrappedJSObject = this;
        if (aData && "start" in aData) {
          if (aData.start && !(aData.start instanceof ICAL.Time)) {
            throw new TypeError(".start must be an instance of ICAL.Time");
          }
          this.start = aData.start;
        }
        if (aData && aData.end && aData.duration) {
          throw new Error("cannot accept both end and duration");
        }
        if (aData && "end" in aData) {
          if (aData.end && !(aData.end instanceof ICAL.Time)) {
            throw new TypeError(".end must be an instance of ICAL.Time");
          }
          this.end = aData.end;
        }
        if (aData && "duration" in aData) {
          if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {
            throw new TypeError(".duration must be an instance of ICAL.Duration");
          }
          this.duration = aData.duration;
        }
      };
      ICAL.Period.prototype = {
        start: null,
        end: null,
        duration: null,
        icalclass: "icalperiod",
        icaltype: "period",
        clone: function() {
          return ICAL.Period.fromData({
            start: this.start ? this.start.clone() : null,
            end: this.end ? this.end.clone() : null,
            duration: this.duration ? this.duration.clone() : null
          });
        },
        getDuration: function duration() {
          if (this.duration) {
            return this.duration;
          } else {
            return this.end.subtractDate(this.start);
          }
        },
        getEnd: function() {
          if (this.end) {
            return this.end;
          } else {
            var end = this.start.clone();
            end.addDuration(this.duration);
            return end;
          }
        },
        toString: function toString() {
          return this.start + "/" + (this.end || this.duration);
        },
        toJSON: function() {
          return [this.start.toString(), (this.end || this.duration).toString()];
        },
        toICALString: function() {
          return this.start.toICALString() + "/" + (this.end || this.duration).toICALString();
        }
      };
      ICAL.Period.fromString = function fromString(str, prop) {
        var parts = str.split("/");
        if (parts.length !== 2) {
          throw new Error(
            'Invalid string value: "' + str + '" must contain a "/" char.'
          );
        }
        var options = {
          start: ICAL.Time.fromDateTimeString(parts[0], prop)
        };
        var end = parts[1];
        if (ICAL.Duration.isValueString(end)) {
          options.duration = ICAL.Duration.fromString(end);
        } else {
          options.end = ICAL.Time.fromDateTimeString(end, prop);
        }
        return new ICAL.Period(options);
      };
      ICAL.Period.fromData = function fromData(aData) {
        return new ICAL.Period(aData);
      };
      ICAL.Period.fromJSON = function(aData, aProp, aLenient) {
        function fromDateOrDateTimeString(aValue, aProp2) {
          if (aLenient) {
            return ICAL.Time.fromString(aValue, aProp2);
          } else {
            return ICAL.Time.fromDateTimeString(aValue, aProp2);
          }
        }
        if (ICAL.Duration.isValueString(aData[1])) {
          return ICAL.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            duration: ICAL.Duration.fromString(aData[1])
          });
        } else {
          return ICAL.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            end: fromDateOrDateTimeString(aData[1], aProp)
          });
        }
      };
    })();
    (function() {
      var DURATION_LETTERS = /([PDWHMTS]{1,1})/;
      ICAL.Duration = function icalduration(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL.Duration.prototype = {
        weeks: 0,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        isNegative: false,
        icalclass: "icalduration",
        icaltype: "duration",
        clone: function clone() {
          return ICAL.Duration.fromData(this);
        },
        toSeconds: function toSeconds() {
          var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;
          return this.isNegative ? -seconds : seconds;
        },
        fromSeconds: function fromSeconds(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.isNegative = aSeconds < 0;
          this.days = ICAL.helpers.trunc(secs / 86400);
          if (this.days % 7 == 0) {
            this.weeks = this.days / 7;
            this.days = 0;
          } else {
            this.weeks = 0;
          }
          secs -= (this.days + 7 * this.weeks) * 86400;
          this.hours = ICAL.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL.helpers.trunc(secs / 60);
          secs -= this.minutes * 60;
          this.seconds = secs;
          return this;
        },
        fromData: function fromData(aData) {
          var propsToCopy = [
            "weeks",
            "days",
            "hours",
            "minutes",
            "seconds",
            "isNegative"
          ];
          for (var key in propsToCopy) {
            if (!propsToCopy.hasOwnProperty(key)) {
              continue;
            }
            var prop = propsToCopy[key];
            if (aData && prop in aData) {
              this[prop] = aData[prop];
            } else {
              this[prop] = 0;
            }
          }
        },
        reset: function reset() {
          this.isNegative = false;
          this.weeks = 0;
          this.days = 0;
          this.hours = 0;
          this.minutes = 0;
          this.seconds = 0;
        },
        compare: function compare(aOther) {
          var thisSeconds = this.toSeconds();
          var otherSeconds = aOther.toSeconds();
          return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
        },
        normalize: function normalize() {
          this.fromSeconds(this.toSeconds());
        },
        toString: function toString() {
          if (this.toSeconds() == 0) {
            return "PT0S";
          } else {
            var str = "";
            if (this.isNegative)
              str += "-";
            str += "P";
            if (this.weeks)
              str += this.weeks + "W";
            if (this.days)
              str += this.days + "D";
            if (this.hours || this.minutes || this.seconds) {
              str += "T";
              if (this.hours)
                str += this.hours + "H";
              if (this.minutes)
                str += this.minutes + "M";
              if (this.seconds)
                str += this.seconds + "S";
            }
            return str;
          }
        },
        toICALString: function() {
          return this.toString();
        }
      };
      ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
        return new ICAL.Duration().fromSeconds(aSeconds);
      };
      function parseDurationChunk(letter, number2, object) {
        var type;
        switch (letter) {
          case "P":
            if (number2 && number2 === "-") {
              object.isNegative = true;
            } else {
              object.isNegative = false;
            }
            break;
          case "D":
            type = "days";
            break;
          case "W":
            type = "weeks";
            break;
          case "H":
            type = "hours";
            break;
          case "M":
            type = "minutes";
            break;
          case "S":
            type = "seconds";
            break;
          default:
            return 0;
        }
        if (type) {
          if (!number2 && number2 !== 0) {
            throw new Error(
              'invalid duration value: Missing number before "' + letter + '"'
            );
          }
          var num = parseInt(number2, 10);
          if (ICAL.helpers.isStrictlyNaN(num)) {
            throw new Error(
              'invalid duration value: Invalid number "' + number2 + '" before "' + letter + '"'
            );
          }
          object[type] = num;
        }
        return 1;
      }
      ICAL.Duration.isValueString = function(string) {
        return string[0] === "P" || string[1] === "P";
      };
      ICAL.Duration.fromString = function icalduration_from_string(aStr) {
        var pos = 0;
        var dict = /* @__PURE__ */ Object.create(null);
        var chunks = 0;
        while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
          var type = aStr[pos];
          var numeric = aStr.substr(0, pos);
          aStr = aStr.substr(pos + 1);
          chunks += parseDurationChunk(type, numeric, dict);
        }
        if (chunks < 2) {
          throw new Error(
            'invalid duration value: Not enough duration components in "' + aStr + '"'
          );
        }
        return new ICAL.Duration(dict);
      };
      ICAL.Duration.fromData = function icalduration_from_data(aData) {
        return new ICAL.Duration(aData);
      };
    })();
    (function() {
      var OPTIONS = [
        "tzid",
        "location",
        "tznames",
        "latitude",
        "longitude"
      ];
      ICAL.Timezone = function icaltimezone(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL.Timezone.prototype = {
        tzid: "",
        location: "",
        tznames: "",
        latitude: 0,
        longitude: 0,
        component: null,
        expandedUntilYear: 0,
        icalclass: "icaltimezone",
        fromData: function fromData(aData) {
          this.expandedUntilYear = 0;
          this.changes = [];
          if (aData instanceof ICAL.Component) {
            this.component = aData;
          } else {
            if (aData && "component" in aData) {
              if (typeof aData.component == "string") {
                var jCal = ICAL.parse(aData.component);
                this.component = new ICAL.Component(jCal);
              } else if (aData.component instanceof ICAL.Component) {
                this.component = aData.component;
              } else {
                this.component = null;
              }
            }
            for (var key in OPTIONS) {
              if (OPTIONS.hasOwnProperty(key)) {
                var prop = OPTIONS[key];
                if (aData && prop in aData) {
                  this[prop] = aData[prop];
                }
              }
            }
          }
          if (this.component instanceof ICAL.Component && !this.tzid) {
            this.tzid = this.component.getFirstPropertyValue("tzid");
          }
          return this;
        },
        utcOffset: function utcOffset(tt) {
          if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {
            return 0;
          }
          this._ensureCoverage(tt.year);
          if (!this.changes.length) {
            return 0;
          }
          var tt_change = {
            year: tt.year,
            month: tt.month,
            day: tt.day,
            hour: tt.hour,
            minute: tt.minute,
            second: tt.second
          };
          var change_num = this._findNearbyChange(tt_change);
          var change_num_to_use = -1;
          var step = 1;
          for (; ; ) {
            var change = ICAL.helpers.clone(this.changes[change_num], true);
            if (change.utcOffset < change.prevUtcOffset) {
              ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
            } else {
              ICAL.Timezone.adjust_change(
                change,
                0,
                0,
                0,
                change.prevUtcOffset
              );
            }
            var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);
            if (cmp >= 0) {
              change_num_to_use = change_num;
            } else {
              step = -1;
            }
            if (step == -1 && change_num_to_use != -1) {
              break;
            }
            change_num += step;
            if (change_num < 0) {
              return 0;
            }
            if (change_num >= this.changes.length) {
              break;
            }
          }
          var zone_change = this.changes[change_num_to_use];
          var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;
          if (utcOffset_change < 0 && change_num_to_use > 0) {
            var tmp_change = ICAL.helpers.clone(zone_change, true);
            ICAL.Timezone.adjust_change(
              tmp_change,
              0,
              0,
              0,
              tmp_change.prevUtcOffset
            );
            if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
              var prev_zone_change = this.changes[change_num_to_use - 1];
              var want_daylight = false;
              if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {
                zone_change = prev_zone_change;
              }
            }
          }
          return zone_change.utcOffset;
        },
        _findNearbyChange: function icaltimezone_find_nearby_change(change) {
          var idx = ICAL.helpers.binsearchInsert(
            this.changes,
            change,
            ICAL.Timezone._compare_change_fn
          );
          if (idx >= this.changes.length) {
            return this.changes.length - 1;
          }
          return idx;
        },
        _ensureCoverage: function(aYear) {
          if (ICAL.Timezone._minimumExpansionYear == -1) {
            var today = ICAL.Time.now();
            ICAL.Timezone._minimumExpansionYear = today.year;
          }
          var changesEndYear = aYear;
          if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {
            changesEndYear = ICAL.Timezone._minimumExpansionYear;
          }
          changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;
          if (changesEndYear > ICAL.Timezone.MAX_YEAR) {
            changesEndYear = ICAL.Timezone.MAX_YEAR;
          }
          if (!this.changes.length || this.expandedUntilYear < aYear) {
            var subcomps = this.component.getAllSubcomponents();
            var compLen = subcomps.length;
            var compIdx = 0;
            for (; compIdx < compLen; compIdx++) {
              this._expandComponent(
                subcomps[compIdx],
                changesEndYear,
                this.changes
              );
            }
            this.changes.sort(ICAL.Timezone._compare_change_fn);
            this.expandedUntilYear = changesEndYear;
          }
        },
        _expandComponent: function(aComponent, aYear, changes) {
          if (!aComponent.hasProperty("dtstart") || !aComponent.hasProperty("tzoffsetto") || !aComponent.hasProperty("tzoffsetfrom")) {
            return null;
          }
          var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
          var change;
          function convert_tzoffset(offset) {
            return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
          }
          function init_changes() {
            var changebase = {};
            changebase.is_daylight = aComponent.name == "daylight";
            changebase.utcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetto").getFirstValue()
            );
            changebase.prevUtcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
            );
            return changebase;
          }
          if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
            change = init_changes();
            change.year = dtstart.year;
            change.month = dtstart.month;
            change.day = dtstart.day;
            change.hour = dtstart.hour;
            change.minute = dtstart.minute;
            change.second = dtstart.second;
            ICAL.Timezone.adjust_change(
              change,
              0,
              0,
              0,
              -change.prevUtcOffset
            );
            changes.push(change);
          } else {
            var props = aComponent.getAllProperties("rdate");
            for (var rdatekey in props) {
              if (!props.hasOwnProperty(rdatekey)) {
                continue;
              }
              var rdate = props[rdatekey];
              var time = rdate.getFirstValue();
              change = init_changes();
              change.year = time.year;
              change.month = time.month;
              change.day = time.day;
              if (time.isDate) {
                change.hour = dtstart.hour;
                change.minute = dtstart.minute;
                change.second = dtstart.second;
                if (dtstart.zone != ICAL.Timezone.utcTimezone) {
                  ICAL.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              } else {
                change.hour = time.hour;
                change.minute = time.minute;
                change.second = time.second;
                if (time.zone != ICAL.Timezone.utcTimezone) {
                  ICAL.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              }
              changes.push(change);
            }
            var rrule = aComponent.getFirstProperty("rrule");
            if (rrule) {
              rrule = rrule.getFirstValue();
              change = init_changes();
              if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {
                rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
                rrule.until.zone = ICAL.Timezone.localTimezone;
              }
              var iterator = rrule.iterator(dtstart);
              var occ;
              while (occ = iterator.next()) {
                change = init_changes();
                if (occ.year > aYear || !occ) {
                  break;
                }
                change.year = occ.year;
                change.month = occ.month;
                change.day = occ.day;
                change.hour = occ.hour;
                change.minute = occ.minute;
                change.second = occ.second;
                change.isDate = occ.isDate;
                ICAL.Timezone.adjust_change(
                  change,
                  0,
                  0,
                  0,
                  -change.prevUtcOffset
                );
                changes.push(change);
              }
            }
          }
          return changes;
        },
        toString: function toString() {
          return this.tznames ? this.tznames : this.tzid;
        }
      };
      ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {
        if (a.year < b.year)
          return -1;
        else if (a.year > b.year)
          return 1;
        if (a.month < b.month)
          return -1;
        else if (a.month > b.month)
          return 1;
        if (a.day < b.day)
          return -1;
        else if (a.day > b.day)
          return 1;
        if (a.hour < b.hour)
          return -1;
        else if (a.hour > b.hour)
          return 1;
        if (a.minute < b.minute)
          return -1;
        else if (a.minute > b.minute)
          return 1;
        if (a.second < b.second)
          return -1;
        else if (a.second > b.second)
          return 1;
        return 0;
      };
      ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL.Timezone.localTimezone || to_zone == ICAL.Timezone.localTimezone) {
          tt.zone = to_zone;
          return tt;
        }
        var utcOffset = from_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, -utcOffset);
        utcOffset = to_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, utcOffset);
        return null;
      };
      ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {
        var tt = new ICAL.Timezone();
        return tt.fromData(aData);
      };
      ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({
        tzid: "UTC"
      });
      ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({
        tzid: "floating"
      });
      ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
        return ICAL.Time.prototype.adjust.call(
          change,
          days,
          hours,
          minutes,
          seconds,
          change
        );
      };
      ICAL.Timezone._minimumExpansionYear = -1;
      ICAL.Timezone.MAX_YEAR = 2035;
      ICAL.Timezone.EXTRA_COVERAGE = 5;
    })();
    ICAL.TimezoneService = function() {
      var zones;
      var TimezoneService = {
        get count() {
          return Object.keys(zones).length;
        },
        reset: function() {
          zones = /* @__PURE__ */ Object.create(null);
          var utc = ICAL.Timezone.utcTimezone;
          zones.Z = utc;
          zones.UTC = utc;
          zones.GMT = utc;
        },
        has: function(tzid) {
          return !!zones[tzid];
        },
        get: function(tzid) {
          return zones[tzid];
        },
        register: function(name, timezone) {
          if (name instanceof ICAL.Component) {
            if (name.name === "vtimezone") {
              timezone = new ICAL.Timezone(name);
              name = timezone.tzid;
            }
          }
          if (timezone instanceof ICAL.Timezone) {
            zones[name] = timezone;
          } else {
            throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component");
          }
        },
        remove: function(tzid) {
          return delete zones[tzid];
        }
      };
      TimezoneService.reset();
      return TimezoneService;
    }();
    (function() {
      ICAL.Time = function icaltime(data, zone) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = 0;
        time.month = 1;
        time.day = 1;
        time.hour = 0;
        time.minute = 0;
        time.second = 0;
        time.isDate = false;
        this.fromData(data, zone);
      };
      ICAL.Time._dowCache = {};
      ICAL.Time._wnCache = {};
      ICAL.Time.prototype = {
        icalclass: "icaltime",
        _cachedUnixTime: null,
        get icaltype() {
          return this.isDate ? "date" : "date-time";
        },
        zone: null,
        _pendingNormalization: false,
        clone: function() {
          return new ICAL.Time(this._time, this.zone);
        },
        reset: function icaltime_reset() {
          this.fromData(ICAL.Time.epochTime);
          this.zone = ICAL.Timezone.utcTimezone;
        },
        resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {
          this.fromData({
            year,
            month,
            day,
            hour,
            minute,
            second,
            zone: timezone
          });
        },
        fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
          if (!aDate) {
            this.reset();
          } else {
            if (useUTC) {
              this.zone = ICAL.Timezone.utcTimezone;
              this.year = aDate.getUTCFullYear();
              this.month = aDate.getUTCMonth() + 1;
              this.day = aDate.getUTCDate();
              this.hour = aDate.getUTCHours();
              this.minute = aDate.getUTCMinutes();
              this.second = aDate.getUTCSeconds();
            } else {
              this.zone = ICAL.Timezone.localTimezone;
              this.year = aDate.getFullYear();
              this.month = aDate.getMonth() + 1;
              this.day = aDate.getDate();
              this.hour = aDate.getHours();
              this.minute = aDate.getMinutes();
              this.second = aDate.getSeconds();
            }
          }
          this._cachedUnixTime = null;
          return this;
        },
        fromData: function fromData(aData, aZone) {
          if (aData) {
            for (var key in aData) {
              if (Object.prototype.hasOwnProperty.call(aData, key)) {
                if (key === "icaltype")
                  continue;
                this[key] = aData[key];
              }
            }
          }
          if (aZone) {
            this.zone = aZone;
          }
          if (aData && !("isDate" in aData)) {
            this.isDate = !("hour" in aData);
          } else if (aData && "isDate" in aData) {
            this.isDate = aData.isDate;
          }
          if (aData && "timezone" in aData) {
            var zone = ICAL.TimezoneService.get(
              aData.timezone
            );
            this.zone = zone || ICAL.Timezone.localTimezone;
          }
          if (aData && "zone" in aData) {
            this.zone = aData.zone;
          }
          if (!this.zone) {
            this.zone = ICAL.Timezone.localTimezone;
          }
          this._cachedUnixTime = null;
          return this;
        },
        dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL.Time.SUNDAY;
          var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
          if (dowCacheKey in ICAL.Time._dowCache) {
            return ICAL.Time._dowCache[dowCacheKey];
          }
          var q = this.day;
          var m = this.month + (this.month < 3 ? 12 : 0);
          var Y = this.year - (this.month < 3 ? 1 : 0);
          var h = q + Y + ICAL.helpers.trunc((m + 1) * 26 / 10) + ICAL.helpers.trunc(Y / 4);
          if (true) {
            h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);
          } else {
            h += 5;
          }
          h = (h + 7 - firstDow) % 7 + 1;
          ICAL.Time._dowCache[dowCacheKey] = h;
          return h;
        },
        dayOfYear: function dayOfYear() {
          var is_leap = ICAL.Time.isLeapYear(this.year) ? 1 : 0;
          var diypm = ICAL.Time.daysInYearPassedMonth;
          return diypm[is_leap][this.month - 1] + this.day;
        },
        startOfWeek: function startOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL.Time.SUNDAY;
          var result = this.clone();
          result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        endOfWeek: function endOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL.Time.SUNDAY;
          var result = this.clone();
          result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        startOfMonth: function startOfMonth() {
          var result = this.clone();
          result.day = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        endOfMonth: function endOfMonth() {
          var result = this.clone();
          result.day = ICAL.Time.daysInMonth(result.month, result.year);
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        startOfYear: function startOfYear() {
          var result = this.clone();
          result.day = 1;
          result.month = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        endOfYear: function endOfYear() {
          var result = this.clone();
          result.day = 31;
          result.month = 12;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
          var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;
          var delta = this.dayOfWeek() - firstDow;
          if (delta < 0)
            delta += 7;
          return this.dayOfYear() - delta;
        },
        getDominicalLetter: function() {
          return ICAL.Time.getDominicalLetter(this.year);
        },
        nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
          var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);
          var weekday;
          var pos = aPos;
          var start = 0;
          var otherDay = this.clone();
          if (pos >= 0) {
            otherDay.day = 1;
            if (pos != 0) {
              pos--;
            }
            start = otherDay.day;
            var startDow = otherDay.dayOfWeek();
            var offset = aDayOfWeek - startDow;
            if (offset < 0)
              offset += 7;
            start += offset;
            start -= aDayOfWeek;
            weekday = aDayOfWeek;
          } else {
            otherDay.day = daysInMonth;
            var endDow = otherDay.dayOfWeek();
            pos++;
            weekday = endDow - aDayOfWeek;
            if (weekday < 0) {
              weekday += 7;
            }
            weekday = daysInMonth - weekday;
          }
          weekday += pos * 7;
          return start + weekday;
        },
        isNthWeekDay: function(aDayOfWeek, aPos) {
          var dow = this.dayOfWeek();
          if (aPos === 0 && dow === aDayOfWeek) {
            return true;
          }
          var day = this.nthWeekDay(aDayOfWeek, aPos);
          if (day === this.day) {
            return true;
          }
          return false;
        },
        weekNumber: function weekNumber(aWeekStart) {
          var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
          if (wnCacheKey in ICAL.Time._wnCache) {
            return ICAL.Time._wnCache[wnCacheKey];
          }
          var week1;
          var dt = this.clone();
          dt.isDate = true;
          var isoyear = this.year;
          if (dt.month == 12 && dt.day > 25) {
            week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
            } else {
              isoyear++;
            }
          } else {
            week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);
            }
          }
          var daysBetween = dt.subtractDate(week1).toSeconds() / 86400;
          var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;
          ICAL.Time._wnCache[wnCacheKey] = answer;
          return answer;
        },
        addDuration: function icaltime_add(aDuration) {
          var mult = aDuration.isNegative ? -1 : 1;
          var second = this.second;
          var minute = this.minute;
          var hour = this.hour;
          var day = this.day;
          second += mult * aDuration.seconds;
          minute += mult * aDuration.minutes;
          hour += mult * aDuration.hours;
          day += mult * aDuration.days;
          day += mult * 7 * aDuration.weeks;
          this.second = second;
          this.minute = minute;
          this.hour = hour;
          this.day = day;
          this._cachedUnixTime = null;
        },
        subtractDate: function icaltime_subtract(aDate) {
          var unixTime = this.toUnixTime() + this.utcOffset();
          var other = aDate.toUnixTime() + aDate.utcOffset();
          return ICAL.Duration.fromSeconds(unixTime - other);
        },
        subtractDateTz: function icaltime_subtract_abs(aDate) {
          var unixTime = this.toUnixTime();
          var other = aDate.toUnixTime();
          return ICAL.Duration.fromSeconds(unixTime - other);
        },
        compare: function icaltime_compare(other) {
          var a = this.toUnixTime();
          var b = other.toUnixTime();
          if (a > b)
            return 1;
          if (b > a)
            return -1;
          return 0;
        },
        compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
          function cmp(attr) {
            return ICAL.Time._cmp_attr(a, b, attr);
          }
          var a = this.convertToZone(tz);
          var b = other.convertToZone(tz);
          var rc = 0;
          if ((rc = cmp("year")) != 0)
            return rc;
          if ((rc = cmp("month")) != 0)
            return rc;
          if ((rc = cmp("day")) != 0)
            return rc;
          return rc;
        },
        convertToZone: function convertToZone(zone) {
          var copy = this.clone();
          var zone_equals = this.zone.tzid == zone.tzid;
          if (!this.isDate && !zone_equals) {
            ICAL.Timezone.convert_time(copy, this.zone, zone);
          }
          copy.zone = zone;
          return copy;
        },
        utcOffset: function utc_offset() {
          if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) {
            return 0;
          } else {
            return this.zone.utcOffset(this);
          }
        },
        toICALString: function() {
          var string = this.toString();
          if (string.length > 10) {
            return ICAL.design.icalendar.value["date-time"].toICAL(string);
          } else {
            return ICAL.design.icalendar.value.date.toICAL(string);
          }
        },
        toString: function toString() {
          var result = this.year + "-" + ICAL.helpers.pad2(this.month) + "-" + ICAL.helpers.pad2(this.day);
          if (!this.isDate) {
            result += "T" + ICAL.helpers.pad2(this.hour) + ":" + ICAL.helpers.pad2(this.minute) + ":" + ICAL.helpers.pad2(this.second);
            if (this.zone === ICAL.Timezone.utcTimezone) {
              result += "Z";
            }
          }
          return result;
        },
        toJSDate: function toJSDate() {
          if (this.zone == ICAL.Timezone.localTimezone) {
            if (this.isDate) {
              return new Date(this.year, this.month - 1, this.day);
            } else {
              return new Date(
                this.year,
                this.month - 1,
                this.day,
                this.hour,
                this.minute,
                this.second,
                0
              );
            }
          } else {
            return new Date(this.toUnixTime() * 1e3);
          }
        },
        _normalize: function icaltime_normalize() {
          var isDate = this._time.isDate;
          if (this._time.isDate) {
            this._time.hour = 0;
            this._time.minute = 0;
            this._time.second = 0;
          }
          this.adjust(0, 0, 0, 0);
          return this;
        },
        adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {
          var minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;
          var second, minute, hour, day;
          var daysInMonth;
          var time = aTime || this._time;
          if (!time.isDate) {
            second = time.second + aExtraSeconds;
            time.second = second % 60;
            minutesOverflow = ICAL.helpers.trunc(second / 60);
            if (time.second < 0) {
              time.second += 60;
              minutesOverflow--;
            }
            minute = time.minute + aExtraMinutes + minutesOverflow;
            time.minute = minute % 60;
            hoursOverflow = ICAL.helpers.trunc(minute / 60);
            if (time.minute < 0) {
              time.minute += 60;
              hoursOverflow--;
            }
            hour = time.hour + aExtraHours + hoursOverflow;
            time.hour = hour % 24;
            daysOverflow = ICAL.helpers.trunc(hour / 24);
            if (time.hour < 0) {
              time.hour += 24;
              daysOverflow--;
            }
          }
          if (time.month > 12) {
            yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);
          } else if (time.month < 1) {
            yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;
          }
          time.year += yearsOverflow;
          time.month -= 12 * yearsOverflow;
          day = time.day + aExtraDays + daysOverflow;
          if (day > 0) {
            for (; ; ) {
              daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);
              if (day <= daysInMonth) {
                break;
              }
              time.month++;
              if (time.month > 12) {
                time.year++;
                time.month = 1;
              }
              day -= daysInMonth;
            }
          } else {
            while (day <= 0) {
              if (time.month == 1) {
                time.year--;
                time.month = 12;
              } else {
                time.month--;
              }
              day += ICAL.Time.daysInMonth(time.month, time.year);
            }
          }
          time.day = day;
          this._cachedUnixTime = null;
          return this;
        },
        fromUnixTime: function fromUnixTime(seconds) {
          this.zone = ICAL.Timezone.utcTimezone;
          var epoch = ICAL.Time.epochTime.clone();
          epoch.adjust(0, 0, 0, seconds);
          this.year = epoch.year;
          this.month = epoch.month;
          this.day = epoch.day;
          this.hour = epoch.hour;
          this.minute = epoch.minute;
          this.second = Math.floor(epoch.second);
          this._cachedUnixTime = null;
        },
        toUnixTime: function toUnixTime() {
          if (this._cachedUnixTime !== null) {
            return this._cachedUnixTime;
          }
          var offset = this.utcOffset();
          var ms = Date.UTC(
            this.year,
            this.month - 1,
            this.day,
            this.hour,
            this.minute,
            this.second - offset
          );
          this._cachedUnixTime = ms / 1e3;
          return this._cachedUnixTime;
        },
        toJSON: function() {
          var copy = [
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "isDate"
          ];
          var result = /* @__PURE__ */ Object.create(null);
          var i = 0;
          var len = copy.length;
          var prop;
          for (; i < len; i++) {
            prop = copy[i];
            result[prop] = this[prop];
          }
          if (this.zone) {
            result.timezone = this.zone.tzid;
          }
          return result;
        }
      };
      (function setupNormalizeAttributes() {
        function defineAttr(attr) {
          Object.defineProperty(ICAL.Time.prototype, attr, {
            get: function getTimeAttr() {
              if (this._pendingNormalization) {
                this._normalize();
                this._pendingNormalization = false;
              }
              return this._time[attr];
            },
            set: function setTimeAttr(val) {
              if (attr === "isDate" && val && !this._time.isDate) {
                this.adjust(0, 0, 0, 0);
              }
              this._cachedUnixTime = null;
              this._pendingNormalization = true;
              this._time[attr] = val;
              return val;
            }
          });
        }
        if ("defineProperty" in Object) {
          defineAttr("year");
          defineAttr("month");
          defineAttr("day");
          defineAttr("hour");
          defineAttr("minute");
          defineAttr("second");
          defineAttr("isDate");
        }
      })();
      ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
        var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var days = 30;
        if (month < 1 || month > 12)
          return days;
        days = _daysInMonth[month];
        if (month == 2) {
          days += ICAL.Time.isLeapYear(year);
        }
        return days;
      };
      ICAL.Time.isLeapYear = function isLeapYear(year) {
        if (year <= 1752) {
          return year % 4 == 0;
        } else {
          return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
        }
      };
      ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
        var year = aYear;
        var doy = aDayOfYear;
        var tt = new ICAL.Time();
        tt.auto_normalize = false;
        var is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;
        if (doy < 1) {
          year--;
          is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;
          doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];
          return ICAL.Time.fromDayOfYear(doy, year);
        } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {
          is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;
          doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];
          year++;
          return ICAL.Time.fromDayOfYear(doy, year);
        }
        tt.year = year;
        tt.isDate = true;
        for (var month = 11; month >= 0; month--) {
          if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {
            tt.month = month + 1;
            tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];
            break;
          }
        }
        tt.auto_normalize = true;
        return tt;
      };
      ICAL.Time.fromStringv2 = function fromString(str) {
        return new ICAL.Time({
          year: parseInt(str.substr(0, 4), 10),
          month: parseInt(str.substr(5, 2), 10),
          day: parseInt(str.substr(8, 2), 10),
          isDate: true
        });
      };
      ICAL.Time.fromDateString = function(aValue) {
        return new ICAL.Time({
          year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
          isDate: true
        });
      };
      ICAL.Time.fromDateTimeString = function(aValue, prop) {
        if (aValue.length < 19) {
          throw new Error(
            'invalid date-time value: "' + aValue + '"'
          );
        }
        var zone;
        if (aValue[19] && aValue[19] === "Z") {
          zone = "Z";
        } else if (prop) {
          zone = prop.getParameter("tzid");
        }
        var time = new ICAL.Time({
          year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
          hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),
          minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),
          second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),
          timezone: zone
        });
        return time;
      };
      ICAL.Time.fromString = function fromString(aValue, aProperty) {
        if (aValue.length > 10) {
          return ICAL.Time.fromDateTimeString(aValue, aProperty);
        } else {
          return ICAL.Time.fromDateString(aValue);
        }
      };
      ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
        var tt = new ICAL.Time();
        return tt.fromJSDate(aDate, useUTC);
      };
      ICAL.Time.fromData = function fromData(aData, aZone) {
        var t = new ICAL.Time();
        return t.fromData(aData, aZone);
      };
      ICAL.Time.now = function icaltime_now() {
        return ICAL.Time.fromJSDate(new Date(), false);
      };
      ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
        var t = ICAL.Time.fromData({
          year: aYear,
          month: 1,
          day: 1,
          isDate: true
        });
        var dow = t.dayOfWeek();
        var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;
        if (dow > ICAL.Time.THURSDAY) {
          t.day += 7;
        }
        if (wkst > ICAL.Time.THURSDAY) {
          t.day -= 7;
        }
        t.day -= dow - wkst;
        return t;
      };
      ICAL.Time.getDominicalLetter = function(yr) {
        var LTRS = "GFEDCBA";
        var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
        var isLeap = ICAL.Time.isLeapYear(yr);
        if (isLeap) {
          return LTRS[(dom + 6) % 7] + LTRS[dom];
        } else {
          return LTRS[dom];
        }
      };
      ICAL.Time.epochTime = ICAL.Time.fromData({
        year: 1970,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        isDate: false,
        timezone: "Z"
      });
      ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {
        if (a[attr] > b[attr])
          return 1;
        if (a[attr] < b[attr])
          return -1;
        return 0;
      };
      ICAL.Time.daysInYearPassedMonth = [
        [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
        [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
      ];
      ICAL.Time.SUNDAY = 1;
      ICAL.Time.MONDAY = 2;
      ICAL.Time.TUESDAY = 3;
      ICAL.Time.WEDNESDAY = 4;
      ICAL.Time.THURSDAY = 5;
      ICAL.Time.FRIDAY = 6;
      ICAL.Time.SATURDAY = 7;
      ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;
    })();
    (function() {
      ICAL.VCardTime = function(data, zone, icaltype) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = null;
        time.month = null;
        time.day = null;
        time.hour = null;
        time.minute = null;
        time.second = null;
        this.icaltype = icaltype || "date-and-or-time";
        this.fromData(data, zone);
      };
      ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, {
        icalclass: "vcardtime",
        icaltype: "date-and-or-time",
        zone: null,
        clone: function() {
          return new ICAL.VCardTime(this._time, this.zone, this.icaltype);
        },
        _normalize: function() {
          return this;
        },
        utcOffset: function() {
          if (this.zone instanceof ICAL.UtcOffset) {
            return this.zone.toSeconds();
          } else {
            return ICAL.Time.prototype.utcOffset.apply(this, arguments);
          }
        },
        toICALString: function() {
          return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());
        },
        toString: function toString() {
          var p2 = ICAL.helpers.pad2;
          var y = this.year, m = this.month, d = this.day;
          var h = this.hour, mm = this.minute, s = this.second;
          var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;
          var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;
          var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? "-" : "") : hasMonth || hasDay ? "--" : "") + (hasMonth ? p2(m) : "") + (hasDay ? "-" + p2(d) : "");
          var timepart = (hasHour ? p2(h) : "-") + (hasHour && hasMinute ? ":" : "") + (hasMinute ? p2(mm) : "") + (!hasHour && !hasMinute ? "-" : "") + (hasMinute && hasSecond ? ":" : "") + (hasSecond ? p2(s) : "");
          var zone;
          if (this.zone === ICAL.Timezone.utcTimezone) {
            zone = "Z";
          } else if (this.zone instanceof ICAL.UtcOffset) {
            zone = this.zone.toString();
          } else if (this.zone === ICAL.Timezone.localTimezone) {
            zone = "";
          } else if (this.zone instanceof ICAL.Timezone) {
            var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));
            zone = offset.toString();
          } else {
            zone = "";
          }
          switch (this.icaltype) {
            case "time":
              return timepart + zone;
            case "date-and-or-time":
            case "date-time":
              return datepart + (timepart == "--" ? "" : "T" + timepart + zone);
            case "date":
              return datepart;
          }
          return null;
        }
      });
      ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
        function part(v, s, e) {
          return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;
        }
        var parts = aValue.split("T");
        var dt = parts[0], tmz = parts[1];
        var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];
        var zone = splitzone[0], tm = splitzone[1];
        var stoi = ICAL.helpers.strictParseInt;
        var dtlen = dt ? dt.length : 0;
        var tmlen = tm ? tm.length : 0;
        var hasDashDate = dt && dt[0] == "-" && dt[1] == "-";
        var hasDashTime = tm && tm[0] == "-";
        var o = {
          year: hasDashDate ? null : part(dt, 0, 4),
          month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
          day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,
          hour: hasDashTime ? null : part(tm, 0, 2),
          minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
          second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
        };
        if (zone == "Z") {
          zone = ICAL.Timezone.utcTimezone;
        } else if (zone && zone[3] == ":") {
          zone = ICAL.UtcOffset.fromString(zone);
        } else {
          zone = null;
        }
        return new ICAL.VCardTime(o, zone, aIcalType);
      };
    })();
    (function() {
      var DOW_MAP = {
        SU: ICAL.Time.SUNDAY,
        MO: ICAL.Time.MONDAY,
        TU: ICAL.Time.TUESDAY,
        WE: ICAL.Time.WEDNESDAY,
        TH: ICAL.Time.THURSDAY,
        FR: ICAL.Time.FRIDAY,
        SA: ICAL.Time.SATURDAY
      };
      var REVERSE_DOW_MAP = {};
      for (var key in DOW_MAP) {
        if (DOW_MAP.hasOwnProperty(key)) {
          REVERSE_DOW_MAP[DOW_MAP[key]] = key;
        }
      }
      var COPY_PARTS = [
        "BYSECOND",
        "BYMINUTE",
        "BYHOUR",
        "BYDAY",
        "BYMONTHDAY",
        "BYYEARDAY",
        "BYWEEKNO",
        "BYMONTH",
        "BYSETPOS"
      ];
      ICAL.Recur = function icalrecur(data) {
        this.wrappedJSObject = this;
        this.parts = {};
        if (data && typeof data === "object") {
          this.fromData(data);
        }
      };
      ICAL.Recur.prototype = {
        parts: null,
        interval: 1,
        wkst: ICAL.Time.MONDAY,
        until: null,
        count: null,
        freq: null,
        icalclass: "icalrecur",
        icaltype: "recur",
        iterator: function(aStart) {
          return new ICAL.RecurIterator({
            rule: this,
            dtstart: aStart
          });
        },
        clone: function clone() {
          return new ICAL.Recur(this.toJSON());
        },
        isFinite: function isfinite() {
          return !!(this.count || this.until);
        },
        isByCount: function isbycount() {
          return !!(this.count && !this.until);
        },
        addComponent: function addPart(aType, aValue) {
          var ucname = aType.toUpperCase();
          if (ucname in this.parts) {
            this.parts[ucname].push(aValue);
          } else {
            this.parts[ucname] = [aValue];
          }
        },
        setComponent: function setComponent(aType, aValues) {
          this.parts[aType.toUpperCase()] = aValues.slice();
        },
        getComponent: function getComponent(aType) {
          var ucname = aType.toUpperCase();
          return ucname in this.parts ? this.parts[ucname].slice() : [];
        },
        getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
          var iter = this.iterator(aStartTime);
          var next, cdt;
          do {
            next = iter.next();
          } while (next && next.compare(aRecurrenceId) <= 0);
          if (next && aRecurrenceId.zone) {
            next.zone = aRecurrenceId.zone;
          }
          return next;
        },
        fromData: function(data) {
          for (var key2 in data) {
            var uckey = key2.toUpperCase();
            if (uckey in partDesign) {
              if (Array.isArray(data[key2])) {
                this.parts[uckey] = data[key2];
              } else {
                this.parts[uckey] = [data[key2]];
              }
            } else {
              this[key2] = data[key2];
            }
          }
          if (this.interval && typeof this.interval != "number") {
            optionDesign.INTERVAL(this.interval, this);
          }
          if (this.wkst && typeof this.wkst != "number") {
            this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);
          }
          if (this.until && !(this.until instanceof ICAL.Time)) {
            this.until = ICAL.Time.fromString(this.until);
          }
        },
        toJSON: function() {
          var res = /* @__PURE__ */ Object.create(null);
          res.freq = this.freq;
          if (this.count) {
            res.count = this.count;
          }
          if (this.interval > 1) {
            res.interval = this.interval;
          }
          for (var k in this.parts) {
            if (!this.parts.hasOwnProperty(k)) {
              continue;
            }
            var kparts = this.parts[k];
            if (Array.isArray(kparts) && kparts.length == 1) {
              res[k.toLowerCase()] = kparts[0];
            } else {
              res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);
            }
          }
          if (this.until) {
            res.until = this.until.toString();
          }
          if ("wkst" in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
            res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);
          }
          return res;
        },
        toString: function icalrecur_toString() {
          var str = "FREQ=" + this.freq;
          if (this.count) {
            str += ";COUNT=" + this.count;
          }
          if (this.interval > 1) {
            str += ";INTERVAL=" + this.interval;
          }
          for (var k in this.parts) {
            if (this.parts.hasOwnProperty(k)) {
              str += ";" + k + "=" + this.parts[k];
            }
          }
          if (this.until) {
            str += ";UNTIL=" + this.until.toICALString();
          }
          if ("wkst" in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
            str += ";WKST=" + ICAL.Recur.numericDayToIcalDay(this.wkst);
          }
          return str;
        }
      };
      function parseNumericValue(type, min, max, value) {
        var result = value;
        if (value[0] === "+") {
          result = value.substr(1);
        }
        result = ICAL.helpers.strictParseInt(result);
        if (min !== void 0 && value < min) {
          throw new Error(
            type + ': invalid value "' + value + '" must be > ' + min
          );
        }
        if (max !== void 0 && value > max) {
          throw new Error(
            type + ': invalid value "' + value + '" must be < ' + min
          );
        }
        return result;
      }
      ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
        var firstDow = aWeekStart || ICAL.Time.SUNDAY;
        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;
      };
      ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
        var firstDow = aWeekStart || ICAL.Time.SUNDAY;
        var dow = num + firstDow - ICAL.Time.SUNDAY;
        if (dow > 7) {
          dow -= 7;
        }
        return REVERSE_DOW_MAP[dow];
      };
      var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
      var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
      var ALLOWED_FREQ = [
        "SECONDLY",
        "MINUTELY",
        "HOURLY",
        "DAILY",
        "WEEKLY",
        "MONTHLY",
        "YEARLY"
      ];
      var optionDesign = {
        FREQ: function(value, dict, fmtIcal) {
          if (ALLOWED_FREQ.indexOf(value) !== -1) {
            dict.freq = value;
          } else {
            throw new Error(
              'invalid frequency "' + value + '" expected: "' + ALLOWED_FREQ.join(", ") + '"'
            );
          }
        },
        COUNT: function(value, dict, fmtIcal) {
          dict.count = ICAL.helpers.strictParseInt(value);
        },
        INTERVAL: function(value, dict, fmtIcal) {
          dict.interval = ICAL.helpers.strictParseInt(value);
          if (dict.interval < 1) {
            dict.interval = 1;
          }
        },
        UNTIL: function(value, dict, fmtIcal) {
          if (value.length > 10) {
            dict.until = ICAL.design.icalendar.value["date-time"].fromICAL(value);
          } else {
            dict.until = ICAL.design.icalendar.value.date.fromICAL(value);
          }
          if (!fmtIcal) {
            dict.until = ICAL.Time.fromString(dict.until);
          }
        },
        WKST: function(value, dict, fmtIcal) {
          if (VALID_DAY_NAMES.test(value)) {
            dict.wkst = ICAL.Recur.icalDayToNumericDay(value);
          } else {
            throw new Error('invalid WKST value "' + value + '"');
          }
        }
      };
      var partDesign = {
        BYSECOND: parseNumericValue.bind(this, "BYSECOND", 0, 60),
        BYMINUTE: parseNumericValue.bind(this, "BYMINUTE", 0, 59),
        BYHOUR: parseNumericValue.bind(this, "BYHOUR", 0, 23),
        BYDAY: function(value) {
          if (VALID_BYDAY_PART.test(value)) {
            return value;
          } else {
            throw new Error('invalid BYDAY value "' + value + '"');
          }
        },
        BYMONTHDAY: parseNumericValue.bind(this, "BYMONTHDAY", -31, 31),
        BYYEARDAY: parseNumericValue.bind(this, "BYYEARDAY", -366, 366),
        BYWEEKNO: parseNumericValue.bind(this, "BYWEEKNO", -53, 53),
        BYMONTH: parseNumericValue.bind(this, "BYMONTH", 1, 12),
        BYSETPOS: parseNumericValue.bind(this, "BYSETPOS", -366, 366)
      };
      ICAL.Recur.fromString = function(string) {
        var data = ICAL.Recur._stringToData(string, false);
        return new ICAL.Recur(data);
      };
      ICAL.Recur.fromData = function(aData) {
        return new ICAL.Recur(aData);
      };
      ICAL.Recur._stringToData = function(string, fmtIcal) {
        var dict = /* @__PURE__ */ Object.create(null);
        var values = string.split(";");
        var len = values.length;
        for (var i = 0; i < len; i++) {
          var parts = values[i].split("=");
          var ucname = parts[0].toUpperCase();
          var lcname = parts[0].toLowerCase();
          var name = fmtIcal ? lcname : ucname;
          var value = parts[1];
          if (ucname in partDesign) {
            var partArr = value.split(",");
            var partArrIdx = 0;
            var partArrLen = partArr.length;
            for (; partArrIdx < partArrLen; partArrIdx++) {
              partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
            }
            dict[name] = partArr.length == 1 ? partArr[0] : partArr;
          } else if (ucname in optionDesign) {
            optionDesign[ucname](value, dict, fmtIcal);
          } else {
            dict[lcname] = value;
          }
        }
        return dict;
      };
    })();
    ICAL.RecurIterator = function() {
      function icalrecur_iterator(options) {
        this.fromData(options);
      }
      icalrecur_iterator.prototype = {
        completed: false,
        rule: null,
        dtstart: null,
        last: null,
        occurrence_number: 0,
        by_indices: null,
        initialized: false,
        by_data: null,
        days: null,
        days_index: 0,
        fromData: function(options) {
          this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);
          if (!this.rule) {
            throw new Error("iterator requires a (ICAL.Recur) rule");
          }
          this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);
          if (!this.dtstart) {
            throw new Error("iterator requires a (ICAL.Time) dtstart");
          }
          if (options.by_data) {
            this.by_data = options.by_data;
          } else {
            this.by_data = ICAL.helpers.clone(this.rule.parts, true);
          }
          if (options.occurrence_number)
            this.occurrence_number = options.occurrence_number;
          this.days = options.days || [];
          if (options.last) {
            this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);
          }
          this.by_indices = options.by_indices;
          if (!this.by_indices) {
            this.by_indices = {
              "BYSECOND": 0,
              "BYMINUTE": 0,
              "BYHOUR": 0,
              "BYDAY": 0,
              "BYMONTH": 0,
              "BYWEEKNO": 0,
              "BYMONTHDAY": 0
            };
          }
          this.initialized = options.initialized || false;
          if (!this.initialized) {
            this.init();
          }
        },
        init: function icalrecur_iterator_init() {
          this.initialized = true;
          this.last = this.dtstart.clone();
          var parts = this.by_data;
          if ("BYDAY" in parts) {
            this.sort_byday_rules(parts.BYDAY);
          }
          if ("BYYEARDAY" in parts) {
            if ("BYMONTH" in parts || "BYWEEKNO" in parts || "BYMONTHDAY" in parts || "BYDAY" in parts) {
              throw new Error("Invalid BYYEARDAY rule");
            }
          }
          if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
            throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
          }
          if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
            throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
          }
          if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
            throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
          }
          if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
            throw new Error("BYYEARDAY may only appear in YEARLY rules");
          }
          this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
          this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
          this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
          this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
          this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);
          if (this.rule.freq == "WEEKLY") {
            if ("BYDAY" in parts) {
              var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
              if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {
                this.last.day += wkdy;
              }
            } else {
              var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
              parts.BYDAY = [dayName];
            }
          }
          if (this.rule.freq == "YEARLY") {
            for (; ; ) {
              this.expand_year_days(this.last.year);
              if (this.days.length > 0) {
                break;
              }
              this.increment_year(this.rule.interval);
            }
            this._nextByYearDay();
          }
          if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
            var tempLast = null;
            var initLast = this.last.clone();
            var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
            for (var i in this.by_data.BYDAY) {
              if (!this.by_data.BYDAY.hasOwnProperty(i)) {
                continue;
              }
              this.last = initLast.clone();
              var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var dayOfMonth = this.last.nthWeekDay(dow, pos);
              if (pos >= 6 || pos <= -6) {
                throw new Error("Malformed values in BYDAY part");
              }
              if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                if (tempLast && tempLast.month == initLast.month) {
                  continue;
                }
                while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                  this.increment_month();
                  daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
                  dayOfMonth = this.last.nthWeekDay(dow, pos);
                }
              }
              this.last.day = dayOfMonth;
              if (!tempLast || this.last.compare(tempLast) < 0) {
                tempLast = this.last.clone();
              }
            }
            this.last = tempLast.clone();
            if (this.has_by_data("BYMONTHDAY")) {
              this._byDayAndMonthDay(true);
            }
            if (this.last.day > daysInMonth || this.last.day == 0) {
              throw new Error("Malformed values in BYDAY part");
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            if (this.last.day < 0) {
              var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
              this.last.day = daysInMonth + this.last.day + 1;
            }
          }
        },
        next: function icalrecur_iterator_next() {
          var before = this.last ? this.last.clone() : null;
          if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          }
          if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
            this.occurrence_number++;
            return this.last;
          }
          var valid;
          do {
            valid = 1;
            switch (this.rule.freq) {
              case "SECONDLY":
                this.next_second();
                break;
              case "MINUTELY":
                this.next_minute();
                break;
              case "HOURLY":
                this.next_hour();
                break;
              case "DAILY":
                this.next_day();
                break;
              case "WEEKLY":
                this.next_week();
                break;
              case "MONTHLY":
                valid = this.next_month();
                break;
              case "YEARLY":
                this.next_year();
                break;
              default:
                return null;
            }
          } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);
          if (this.last.compare(before) == 0) {
            throw new Error("Same occurrence found twice, protecting you from death by recursion");
          }
          if (this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          } else {
            this.occurrence_number++;
            return this.last;
          }
        },
        next_second: function next_second() {
          return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
        },
        increment_second: function increment_second(inc) {
          return this.increment_generic(inc, "second", 60, "minute");
        },
        next_minute: function next_minute() {
          return this.next_generic(
            "BYMINUTE",
            "MINUTELY",
            "minute",
            "hour",
            "next_second"
          );
        },
        increment_minute: function increment_minute(inc) {
          return this.increment_generic(inc, "minute", 60, "hour");
        },
        next_hour: function next_hour() {
          return this.next_generic(
            "BYHOUR",
            "HOURLY",
            "hour",
            "monthday",
            "next_minute"
          );
        },
        increment_hour: function increment_hour(inc) {
          this.increment_generic(inc, "hour", 24, "monthday");
        },
        next_day: function next_day() {
          var has_by_day = "BYDAY" in this.by_data;
          var this_freq = this.rule.freq == "DAILY";
          if (this.next_hour() == 0) {
            return 0;
          }
          if (this_freq) {
            this.increment_monthday(this.rule.interval);
          } else {
            this.increment_monthday(1);
          }
          return 0;
        },
        next_week: function next_week() {
          var end_of_data = 0;
          if (this.next_weekday_by_week() == 0) {
            return end_of_data;
          }
          if (this.has_by_data("BYWEEKNO")) {
            var idx = ++this.by_indices.BYWEEKNO;
            if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
              this.by_indices.BYWEEKNO = 0;
              end_of_data = 1;
            }
            this.last.month = 1;
            this.last.day = 1;
            var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];
            this.last.day += 7 * week_no;
            if (end_of_data) {
              this.increment_year(1);
            }
          } else {
            this.increment_monthday(7 * this.rule.interval);
          }
          return end_of_data;
        },
        normalizeByMonthDayRules: function(year, month, rules) {
          var daysInMonth = ICAL.Time.daysInMonth(month, year);
          var newRules = [];
          var ruleIdx = 0;
          var len = rules.length;
          var rule;
          for (; ruleIdx < len; ruleIdx++) {
            rule = rules[ruleIdx];
            if (Math.abs(rule) > daysInMonth) {
              continue;
            }
            if (rule < 0) {
              rule = daysInMonth + (rule + 1);
            } else if (rule === 0) {
              continue;
            }
            if (newRules.indexOf(rule) === -1) {
              newRules.push(rule);
            }
          }
          return newRules.sort(function(a, b) {
            return a - b;
          });
        },
        _byDayAndMonthDay: function(isInit) {
          var byMonthDay;
          var byDay = this.by_data.BYDAY;
          var date;
          var dateIdx = 0;
          var dateLen;
          var dayLen = byDay.length;
          var dataIsValid = 0;
          var daysInMonth;
          var self2 = this;
          var lastDay = this.last.day;
          function initMonth() {
            daysInMonth = ICAL.Time.daysInMonth(
              self2.last.month,
              self2.last.year
            );
            byMonthDay = self2.normalizeByMonthDayRules(
              self2.last.year,
              self2.last.month,
              self2.by_data.BYMONTHDAY
            );
            dateLen = byMonthDay.length;
            while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {
              dateIdx++;
            }
          }
          function nextMonth() {
            lastDay = 0;
            self2.increment_month();
            dateIdx = 0;
            initMonth();
          }
          initMonth();
          if (isInit) {
            lastDay -= 1;
          }
          var monthsCounter = 48;
          while (!dataIsValid && monthsCounter) {
            monthsCounter--;
            date = lastDay + 1;
            if (date > daysInMonth) {
              nextMonth();
              continue;
            }
            var next = byMonthDay[dateIdx++];
            if (next >= date) {
              lastDay = next;
            } else {
              nextMonth();
              continue;
            }
            for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
              var parts = this.ruleDayOfWeek(byDay[dayIdx]);
              var pos = parts[0];
              var dow = parts[1];
              this.last.day = lastDay;
              if (this.last.isNthWeekDay(dow, pos)) {
                dataIsValid = 1;
                break;
              }
            }
            if (!dataIsValid && dateIdx === dateLen) {
              nextMonth();
              continue;
            }
          }
          if (monthsCounter <= 0) {
            throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
          }
          return dataIsValid;
        },
        next_month: function next_month() {
          var this_freq = this.rule.freq == "MONTHLY";
          var data_valid = 1;
          if (this.next_hour() == 0) {
            return data_valid;
          }
          if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
            data_valid = this._byDayAndMonthDay();
          } else if (this.has_by_data("BYDAY")) {
            var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
            var setpos = 0;
            var setpos_total = 0;
            if (this.has_by_data("BYSETPOS")) {
              var last_day = this.last.day;
              for (var day = 1; day <= daysInMonth; day++) {
                this.last.day = day;
                if (this.is_day_in_byday(this.last)) {
                  setpos_total++;
                  if (day <= last_day) {
                    setpos++;
                  }
                }
              }
              this.last.day = last_day;
            }
            data_valid = 0;
            for (var day = this.last.day + 1; day <= daysInMonth; day++) {
              this.last.day = day;
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {
                  data_valid = 1;
                  break;
                }
              }
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              this.increment_month();
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
                  data_valid = 1;
                }
              } else {
                data_valid = 0;
              }
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            this.by_indices.BYMONTHDAY++;
            if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
              this.by_indices.BYMONTHDAY = 0;
              this.increment_month();
            }
            var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
            var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];
            if (day < 0) {
              day = daysInMonth + day + 1;
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              data_valid = this.is_day_in_byday(this.last);
            } else {
              this.last.day = day;
            }
          } else {
            this.increment_month();
            var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
            if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
              data_valid = 0;
            } else {
              this.last.day = this.by_data.BYMONTHDAY[0];
            }
          }
          return data_valid;
        },
        next_weekday_by_week: function next_weekday_by_week() {
          var end_of_data = 0;
          if (this.next_hour() == 0) {
            return end_of_data;
          }
          if (!this.has_by_data("BYDAY")) {
            return 1;
          }
          for (; ; ) {
            var tt = new ICAL.Time();
            this.by_indices.BYDAY++;
            if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
              this.by_indices.BYDAY = 0;
              end_of_data = 1;
            }
            var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
            var parts = this.ruleDayOfWeek(coded_day);
            var dow = parts[1];
            dow -= this.rule.wkst;
            if (dow < 0) {
              dow += 7;
            }
            tt.year = this.last.year;
            tt.month = this.last.month;
            tt.day = this.last.day;
            var startOfWeek = tt.startDoyWeek(this.rule.wkst);
            if (dow + startOfWeek < 1) {
              if (!end_of_data) {
                continue;
              }
            }
            var next = ICAL.Time.fromDayOfYear(
              startOfWeek + dow,
              this.last.year
            );
            this.last.year = next.year;
            this.last.month = next.month;
            this.last.day = next.day;
            return end_of_data;
          }
        },
        next_year: function next_year() {
          if (this.next_hour() == 0) {
            return 0;
          }
          if (++this.days_index == this.days.length) {
            this.days_index = 0;
            do {
              this.increment_year(this.rule.interval);
              this.expand_year_days(this.last.year);
            } while (this.days.length == 0);
          }
          this._nextByYearDay();
          return 1;
        },
        _nextByYearDay: function _nextByYearDay() {
          var doy = this.days[this.days_index];
          var year = this.last.year;
          if (doy < 1) {
            doy += 1;
            year += 1;
          }
          var next = ICAL.Time.fromDayOfYear(doy, year);
          this.last.day = next.day;
          this.last.month = next.month;
        },
        ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
          var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
          if (matches) {
            var pos = parseInt(matches[1] || 0, 10);
            dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);
            return [pos, dow];
          } else {
            return [0, 0];
          }
        },
        next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {
          var has_by_rule = aRuleType in this.by_data;
          var this_freq = this.rule.freq == aInterval;
          var end_of_data = 0;
          if (aPreviousIncr && this[aPreviousIncr]() == 0) {
            return end_of_data;
          }
          if (has_by_rule) {
            this.by_indices[aRuleType]++;
            var idx = this.by_indices[aRuleType];
            var dta = this.by_data[aRuleType];
            if (this.by_indices[aRuleType] == dta.length) {
              this.by_indices[aRuleType] = 0;
              end_of_data = 1;
            }
            this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
          } else if (this_freq) {
            this["increment_" + aDateAttr](this.rule.interval);
          }
          if (has_by_rule && end_of_data && this_freq) {
            this["increment_" + aFollowingAttr](1);
          }
          return end_of_data;
        },
        increment_monthday: function increment_monthday(inc) {
          for (var i = 0; i < inc; i++) {
            var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
            this.last.day++;
            if (this.last.day > daysInMonth) {
              this.last.day -= daysInMonth;
              this.increment_month();
            }
          }
        },
        increment_month: function increment_month() {
          this.last.day = 1;
          if (this.has_by_data("BYMONTH")) {
            this.by_indices.BYMONTH++;
            if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
              this.by_indices.BYMONTH = 0;
              this.increment_year(1);
            }
            this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
          } else {
            if (this.rule.freq == "MONTHLY") {
              this.last.month += this.rule.interval;
            } else {
              this.last.month++;
            }
            this.last.month--;
            var years = ICAL.helpers.trunc(this.last.month / 12);
            this.last.month %= 12;
            this.last.month++;
            if (years != 0) {
              this.increment_year(years);
            }
          }
        },
        increment_year: function increment_year(inc) {
          this.last.year += inc;
        },
        increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {
          this.last[aDateAttr] += inc;
          var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);
          this.last[aDateAttr] %= aFactor;
          if (nextunit != 0) {
            this["increment_" + aNextIncrement](nextunit);
          }
        },
        has_by_data: function has_by_data(aRuleType) {
          return aRuleType in this.rule.parts;
        },
        expand_year_days: function expand_year_days(aYear) {
          var t = new ICAL.Time();
          this.days = [];
          var parts = {};
          var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
          for (var p in rules) {
            if (rules.hasOwnProperty(p)) {
              var part = rules[p];
              if (part in this.rule.parts) {
                parts[part] = this.rule.parts[part];
              }
            }
          }
          if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
            var valid = 1;
            var validWeeks = {};
            t.year = aYear;
            t.isDate = true;
            for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
              var month = this.by_data.BYMONTH[monthIdx];
              t.month = month;
              t.day = 1;
              var first_week = t.weekNumber(this.rule.wkst);
              t.day = ICAL.Time.daysInMonth(month, aYear);
              var last_week = t.weekNumber(this.rule.wkst);
              for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
                validWeeks[monthIdx] = 1;
              }
            }
            for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
              var weekno = this.by_data.BYWEEKNO[weekIdx];
              if (weekno < 52) {
                valid &= validWeeks[weekIdx];
              } else {
                valid = 0;
              }
            }
            if (valid) {
              delete parts.BYMONTH;
            } else {
              delete parts.BYWEEKNO;
            }
          }
          var partCount = Object.keys(parts).length;
          if (partCount == 0) {
            var t1 = this.dtstart.clone();
            t1.year = this.last.year;
            this.days.push(t1.dayOfYear());
          } else if (partCount == 1 && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var t2 = this.dtstart.clone();
              t2.year = aYear;
              t2.month = this.by_data.BYMONTH[monthkey];
              t2.isDate = true;
              this.days.push(t2.dayOfYear());
            }
          } else if (partCount == 1 && "BYMONTHDAY" in parts) {
            for (var monthdaykey in this.by_data.BYMONTHDAY) {
              if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                continue;
              }
              var t3 = this.dtstart.clone();
              var day_ = this.by_data.BYMONTHDAY[monthdaykey];
              if (day_ < 0) {
                var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);
                day_ = day_ + daysInMonth + 1;
              }
              t3.day = day_;
              t3.year = aYear;
              t3.isDate = true;
              this.days.push(t3.dayOfYear());
            }
          } else if (partCount == 2 && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month_ = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);
              for (var monthdaykey in this.by_data.BYMONTHDAY) {
                if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                  continue;
                }
                var day_ = this.by_data.BYMONTHDAY[monthdaykey];
                if (day_ < 0) {
                  day_ = day_ + daysInMonth + 1;
                }
                t.day = day_;
                t.month = month_;
                t.year = aYear;
                t.isDate = true;
                this.days.push(t.dayOfYear());
              }
            }
          } else if (partCount == 1 && "BYWEEKNO" in parts) {
          } else if (partCount == 2 && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYDAY" in parts) {
            this.days = this.days.concat(this.expand_by_day(aYear));
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL.Time.daysInMonth(month, aYear);
              t.year = aYear;
              t.month = this.by_data.BYMONTH[monthkey];
              t.day = 1;
              t.isDate = true;
              var first_dow = t.dayOfWeek();
              var doy_offset = t.dayOfYear() - 1;
              t.day = daysInMonth;
              var last_dow = t.dayOfWeek();
              if (this.has_by_data("BYSETPOS")) {
                var set_pos_counter = 0;
                var by_month_day = [];
                for (var day = 1; day <= daysInMonth; day++) {
                  t.day = day;
                  if (this.is_day_in_byday(t)) {
                    by_month_day.push(day);
                  }
                }
                for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
                  if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {
                    this.days.push(doy_offset + by_month_day[spIndex]);
                  }
                }
              } else {
                for (var daycodedkey in this.by_data.BYDAY) {
                  if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                    continue;
                  }
                  var coded_day = this.by_data.BYDAY[daycodedkey];
                  var bydayParts = this.ruleDayOfWeek(coded_day);
                  var pos = bydayParts[0];
                  var dow = bydayParts[1];
                  var month_day;
                  var first_matching_day = (dow + 7 - first_dow) % 7 + 1;
                  var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;
                  if (pos == 0) {
                    for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                      this.days.push(doy_offset + day);
                    }
                  } else if (pos > 0) {
                    month_day = first_matching_day + (pos - 1) * 7;
                    if (month_day <= daysInMonth) {
                      this.days.push(doy_offset + month_day);
                    }
                  } else {
                    month_day = last_matching_day + (pos + 1) * 7;
                    if (month_day > 0) {
                      this.days.push(doy_offset + month_day);
                    }
                  }
                }
              }
            }
            this.days.sort(function(a, b) {
              return a - b;
            });
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL.Time.fromDayOfYear(day, aYear);
              var weekno = tt.weekNumber(this.rule.wkst);
              if (this.by_data.BYWEEKNO.indexOf(weekno)) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYYEARDAY" in parts) {
            this.days = this.days.concat(this.by_data.BYYEARDAY);
          } else {
            this.days = [];
          }
          return 0;
        },
        expand_by_day: function expand_by_day(aYear) {
          var days_list = [];
          var tmp = this.last.clone();
          tmp.year = aYear;
          tmp.month = 1;
          tmp.day = 1;
          tmp.isDate = true;
          var start_dow = tmp.dayOfWeek();
          tmp.month = 12;
          tmp.day = 31;
          tmp.isDate = true;
          var end_dow = tmp.dayOfWeek();
          var end_year_day = tmp.dayOfYear();
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            if (pos == 0) {
              var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;
              for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
                days_list.push(doy);
              }
            } else if (pos > 0) {
              var first;
              if (dow >= start_dow) {
                first = dow - start_dow + 1;
              } else {
                first = dow - start_dow + 8;
              }
              days_list.push(first + (pos - 1) * 7);
            } else {
              var last;
              pos = -pos;
              if (dow <= end_dow) {
                last = end_year_day - end_dow + dow;
              } else {
                last = end_year_day - end_dow + dow - 7;
              }
              days_list.push(last - (pos - 1) * 7);
            }
          }
          return days_list;
        },
        is_day_in_byday: function is_day_in_byday(tt) {
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            var this_dow = tt.dayOfWeek();
            if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {
              return 1;
            }
          }
          return 0;
        },
        check_set_position: function check_set_position(aPos) {
          if (this.has_by_data("BYSETPOS")) {
            var idx = this.by_data.BYSETPOS.indexOf(aPos);
            return idx !== -1;
          }
          return false;
        },
        sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
          for (var i = 0; i < aRules.length; i++) {
            for (var j = 0; j < i; j++) {
              var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];
              var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];
              if (one > two) {
                var tmp = aRules[i];
                aRules[i] = aRules[j];
                aRules[j] = tmp;
              }
            }
          }
        },
        check_contract_restriction: function check_contract_restriction(aRuleType, v) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          var pass = false;
          if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {
            var ruleType = this.by_data[aRuleType];
            for (var bydatakey in ruleType) {
              if (ruleType.hasOwnProperty(bydatakey)) {
                if (ruleType[bydatakey] == v) {
                  pass = true;
                  break;
                }
              }
            }
          } else {
            pass = true;
          }
          return pass;
        },
        check_contracting_rules: function check_contracting_rules() {
          var dow = this.last.dayOfWeek();
          var weekNo = this.last.weekNumber(this.rule.wkst);
          var doy = this.last.dayOfYear();
          return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", ICAL.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction("BYWEEKNO", weekNo) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", doy);
        },
        setup_defaults: function setup_defaults(aRuleType, req, deftime) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          if (ruleMapValue != icalrecur_iterator.CONTRACT) {
            if (!(aRuleType in this.by_data)) {
              this.by_data[aRuleType] = [deftime];
            }
            if (this.rule.freq != req) {
              return this.by_data[aRuleType][0];
            }
          }
          return deftime;
        },
        toJSON: function() {
          var result = /* @__PURE__ */ Object.create(null);
          result.initialized = this.initialized;
          result.rule = this.rule.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.by_data = this.by_data;
          result.days = this.days;
          result.last = this.last.toJSON();
          result.by_indices = this.by_indices;
          result.occurrence_number = this.occurrence_number;
          return result;
        }
      };
      icalrecur_iterator._indexMap = {
        "BYSECOND": 0,
        "BYMINUTE": 1,
        "BYHOUR": 2,
        "BYDAY": 3,
        "BYMONTHDAY": 4,
        "BYYEARDAY": 5,
        "BYWEEKNO": 6,
        "BYMONTH": 7,
        "BYSETPOS": 8
      };
      icalrecur_iterator._expandMap = {
        "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
        "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
        "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
        "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
        "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
        "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
        "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
      };
      icalrecur_iterator.UNKNOWN = 0;
      icalrecur_iterator.CONTRACT = 1;
      icalrecur_iterator.EXPAND = 2;
      icalrecur_iterator.ILLEGAL = 3;
      return icalrecur_iterator;
    }();
    ICAL.RecurExpansion = function() {
      function formatTime2(item2) {
        return ICAL.helpers.formatClassType(item2, ICAL.Time);
      }
      function compareTime(a, b) {
        return a.compare(b);
      }
      function isRecurringComponent(comp) {
        return comp.hasProperty("rdate") || comp.hasProperty("rrule") || comp.hasProperty("recurrence-id");
      }
      function RecurExpansion(options) {
        this.ruleDates = [];
        this.exDates = [];
        this.fromData(options);
      }
      RecurExpansion.prototype = {
        complete: false,
        ruleIterators: null,
        ruleDates: null,
        exDates: null,
        ruleDateInc: 0,
        exDateInc: 0,
        exDate: null,
        ruleDate: null,
        dtstart: null,
        last: null,
        fromData: function(options) {
          var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);
          if (!start) {
            throw new Error(".dtstart (ICAL.Time) must be given");
          } else {
            this.dtstart = start;
          }
          if (options.component) {
            this._init(options.component);
          } else {
            this.last = formatTime2(options.last) || start.clone();
            if (!options.ruleIterators) {
              throw new Error(".ruleIterators or .component must be given");
            }
            this.ruleIterators = options.ruleIterators.map(function(item2) {
              return ICAL.helpers.formatClassType(item2, ICAL.RecurIterator);
            });
            this.ruleDateInc = options.ruleDateInc;
            this.exDateInc = options.exDateInc;
            if (options.ruleDates) {
              this.ruleDates = options.ruleDates.map(formatTime2);
              this.ruleDate = this.ruleDates[this.ruleDateInc];
            }
            if (options.exDates) {
              this.exDates = options.exDates.map(formatTime2);
              this.exDate = this.exDates[this.exDateInc];
            }
            if (typeof options.complete !== "undefined") {
              this.complete = options.complete;
            }
          }
        },
        next: function() {
          var iter;
          var ruleOfDay;
          var next;
          var compare;
          var maxTries = 500;
          var currentTry = 0;
          while (true) {
            if (currentTry++ > maxTries) {
              throw new Error(
                "max tries have occured, rule may be impossible to forfill."
              );
            }
            next = this.ruleDate;
            iter = this._nextRecurrenceIter(this.last);
            if (!next && !iter) {
              this.complete = true;
              break;
            }
            if (!next || iter && next.compare(iter.last) > 0) {
              next = iter.last.clone();
              iter.next();
            }
            if (this.ruleDate === next) {
              this._nextRuleDay();
            }
            this.last = next;
            if (this.exDate) {
              compare = this.exDate.compare(this.last);
              if (compare < 0) {
                this._nextExDay();
              }
              if (compare === 0) {
                this._nextExDay();
                continue;
              }
            }
            return this.last;
          }
        },
        toJSON: function() {
          function toJSON(item2) {
            return item2.toJSON();
          }
          var result = /* @__PURE__ */ Object.create(null);
          result.ruleIterators = this.ruleIterators.map(toJSON);
          if (this.ruleDates) {
            result.ruleDates = this.ruleDates.map(toJSON);
          }
          if (this.exDates) {
            result.exDates = this.exDates.map(toJSON);
          }
          result.ruleDateInc = this.ruleDateInc;
          result.exDateInc = this.exDateInc;
          result.last = this.last.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.complete = this.complete;
          return result;
        },
        _extractDates: function(component, propertyName) {
          function handleProp(prop2) {
            idx = ICAL.helpers.binsearchInsert(
              result,
              prop2,
              compareTime
            );
            result.splice(idx, 0, prop2);
          }
          var result = [];
          var props = component.getAllProperties(propertyName);
          var len = props.length;
          var i = 0;
          var prop;
          var idx;
          for (; i < len; i++) {
            props[i].getValues().forEach(handleProp);
          }
          return result;
        },
        _init: function(component) {
          this.ruleIterators = [];
          this.last = this.dtstart.clone();
          if (!isRecurringComponent(component)) {
            this.ruleDate = this.last.clone();
            this.complete = true;
            return;
          }
          if (component.hasProperty("rdate")) {
            this.ruleDates = this._extractDates(component, "rdate");
            if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {
              this.ruleDateInc = 0;
              this.last = this.ruleDates[0].clone();
            } else {
              this.ruleDateInc = ICAL.helpers.binsearchInsert(
                this.ruleDates,
                this.last,
                compareTime
              );
            }
            this.ruleDate = this.ruleDates[this.ruleDateInc];
          }
          if (component.hasProperty("rrule")) {
            var rules = component.getAllProperties("rrule");
            var i = 0;
            var len = rules.length;
            var rule;
            var iter;
            for (; i < len; i++) {
              rule = rules[i].getFirstValue();
              iter = rule.iterator(this.dtstart);
              this.ruleIterators.push(iter);
              iter.next();
            }
          }
          if (component.hasProperty("exdate")) {
            this.exDates = this._extractDates(component, "exdate");
            this.exDateInc = ICAL.helpers.binsearchInsert(
              this.exDates,
              this.last,
              compareTime
            );
            this.exDate = this.exDates[this.exDateInc];
          }
        },
        _nextExDay: function() {
          this.exDate = this.exDates[++this.exDateInc];
        },
        _nextRuleDay: function() {
          this.ruleDate = this.ruleDates[++this.ruleDateInc];
        },
        _nextRecurrenceIter: function() {
          var iters = this.ruleIterators;
          if (iters.length === 0) {
            return null;
          }
          var len = iters.length;
          var iter;
          var iterTime;
          var iterIdx = 0;
          var chosenIter;
          for (; iterIdx < len; iterIdx++) {
            iter = iters[iterIdx];
            iterTime = iter.last;
            if (iter.completed) {
              len--;
              if (iterIdx !== 0) {
                iterIdx--;
              }
              iters.splice(iterIdx, 1);
              continue;
            }
            if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
              chosenIter = iter;
            }
          }
          return chosenIter;
        }
      };
      return RecurExpansion;
    }();
    ICAL.Event = function() {
      function Event(component, options) {
        if (!(component instanceof ICAL.Component)) {
          options = component;
          component = null;
        }
        if (component) {
          this.component = component;
        } else {
          this.component = new ICAL.Component("vevent");
        }
        this._rangeExceptionCache = /* @__PURE__ */ Object.create(null);
        this.exceptions = /* @__PURE__ */ Object.create(null);
        this.rangeExceptions = [];
        if (options && options.strictExceptions) {
          this.strictExceptions = options.strictExceptions;
        }
        if (options && options.exceptions) {
          options.exceptions.forEach(this.relateException, this);
        } else if (this.component.parent && !this.isRecurrenceException()) {
          this.component.parent.getAllSubcomponents("vevent").forEach(function(event) {
            if (event.hasProperty("recurrence-id")) {
              this.relateException(event);
            }
          }, this);
        }
      }
      Event.prototype = {
        THISANDFUTURE: "THISANDFUTURE",
        exceptions: null,
        strictExceptions: false,
        relateException: function(obj) {
          if (this.isRecurrenceException()) {
            throw new Error("cannot relate exception to exceptions");
          }
          if (obj instanceof ICAL.Component) {
            obj = new ICAL.Event(obj);
          }
          if (this.strictExceptions && obj.uid !== this.uid) {
            throw new Error("attempted to relate unrelated exception");
          }
          var id = obj.recurrenceId.toString();
          this.exceptions[id] = obj;
          if (obj.modifiesFuture()) {
            var item2 = [
              obj.recurrenceId.toUnixTime(),
              id
            ];
            var idx = ICAL.helpers.binsearchInsert(
              this.rangeExceptions,
              item2,
              compareRangeException
            );
            this.rangeExceptions.splice(idx, 0, item2);
          }
        },
        modifiesFuture: function() {
          if (!this.component.hasProperty("recurrence-id")) {
            return false;
          }
          var range = this.component.getFirstProperty("recurrence-id").getParameter("range");
          return range === this.THISANDFUTURE;
        },
        findRangeException: function(time) {
          if (!this.rangeExceptions.length) {
            return null;
          }
          var utc = time.toUnixTime();
          var idx = ICAL.helpers.binsearchInsert(
            this.rangeExceptions,
            [utc],
            compareRangeException
          );
          idx -= 1;
          if (idx < 0) {
            return null;
          }
          var rangeItem = this.rangeExceptions[idx];
          if (utc < rangeItem[0]) {
            return null;
          }
          return rangeItem[1];
        },
        getOccurrenceDetails: function(occurrence) {
          var id = occurrence.toString();
          var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();
          var item2;
          var result = {
            recurrenceId: occurrence
          };
          if (id in this.exceptions) {
            item2 = result.item = this.exceptions[id];
            result.startDate = item2.startDate;
            result.endDate = item2.endDate;
            result.item = item2;
          } else if (utcId in this.exceptions) {
            item2 = this.exceptions[utcId];
            result.startDate = item2.startDate;
            result.endDate = item2.endDate;
            result.item = item2;
          } else {
            var rangeExceptionId = this.findRangeException(
              occurrence
            );
            var end;
            if (rangeExceptionId) {
              var exception = this.exceptions[rangeExceptionId];
              result.item = exception;
              var startDiff = this._rangeExceptionCache[rangeExceptionId];
              if (!startDiff) {
                var original = exception.recurrenceId.clone();
                var newStart = exception.startDate.clone();
                original.zone = newStart.zone;
                startDiff = newStart.subtractDate(original);
                this._rangeExceptionCache[rangeExceptionId] = startDiff;
              }
              var start = occurrence.clone();
              start.zone = exception.startDate.zone;
              start.addDuration(startDiff);
              end = start.clone();
              end.addDuration(exception.duration);
              result.startDate = start;
              result.endDate = end;
            } else {
              end = occurrence.clone();
              end.addDuration(this.duration);
              result.endDate = end;
              result.startDate = occurrence;
              result.item = this;
            }
          }
          return result;
        },
        iterator: function(startTime) {
          return new ICAL.RecurExpansion({
            component: this.component,
            dtstart: startTime || this.startDate
          });
        },
        isRecurring: function() {
          var comp = this.component;
          return comp.hasProperty("rrule") || comp.hasProperty("rdate");
        },
        isRecurrenceException: function() {
          return this.component.hasProperty("recurrence-id");
        },
        getRecurrenceTypes: function() {
          var rules = this.component.getAllProperties("rrule");
          var i = 0;
          var len = rules.length;
          var result = /* @__PURE__ */ Object.create(null);
          for (; i < len; i++) {
            var value = rules[i].getFirstValue();
            result[value.freq] = true;
          }
          return result;
        },
        get uid() {
          return this._firstProp("uid");
        },
        set uid(value) {
          this._setProp("uid", value);
        },
        get startDate() {
          return this._firstProp("dtstart");
        },
        set startDate(value) {
          this._setTime("dtstart", value);
        },
        get endDate() {
          var endDate = this._firstProp("dtend");
          if (!endDate) {
            var duration = this._firstProp("duration");
            endDate = this.startDate.clone();
            if (duration) {
              endDate.addDuration(duration);
            } else if (endDate.isDate) {
              endDate.day += 1;
            }
          }
          return endDate;
        },
        set endDate(value) {
          if (this.component.hasProperty("duration")) {
            this.component.removeProperty("duration");
          }
          this._setTime("dtend", value);
        },
        get duration() {
          var duration = this._firstProp("duration");
          if (!duration) {
            return this.endDate.subtractDateTz(this.startDate);
          }
          return duration;
        },
        set duration(value) {
          if (this.component.hasProperty("dtend")) {
            this.component.removeProperty("dtend");
          }
          this._setProp("duration", value);
        },
        get location() {
          return this._firstProp("location");
        },
        set location(value) {
          return this._setProp("location", value);
        },
        get attendees() {
          return this.component.getAllProperties("attendee");
        },
        get summary() {
          return this._firstProp("summary");
        },
        set summary(value) {
          this._setProp("summary", value);
        },
        get description() {
          return this._firstProp("description");
        },
        set description(value) {
          this._setProp("description", value);
        },
        get color() {
          return this._firstProp("color");
        },
        set color(value) {
          this._setProp("color", value);
        },
        get organizer() {
          return this._firstProp("organizer");
        },
        set organizer(value) {
          this._setProp("organizer", value);
        },
        get sequence() {
          return this._firstProp("sequence");
        },
        set sequence(value) {
          this._setProp("sequence", value);
        },
        get recurrenceId() {
          return this._firstProp("recurrence-id");
        },
        set recurrenceId(value) {
          this._setTime("recurrence-id", value);
        },
        _setTime: function(propName, time) {
          var prop = this.component.getFirstProperty(propName);
          if (!prop) {
            prop = new ICAL.Property(propName);
            this.component.addProperty(prop);
          }
          if (time.zone === ICAL.Timezone.localTimezone || time.zone === ICAL.Timezone.utcTimezone) {
            prop.removeParameter("tzid");
          } else {
            prop.setParameter("tzid", time.zone.tzid);
          }
          prop.setValue(time);
        },
        _setProp: function(name, value) {
          this.component.updatePropertyWithValue(name, value);
        },
        _firstProp: function(name) {
          return this.component.getFirstPropertyValue(name);
        },
        toString: function() {
          return this.component.toString();
        }
      };
      function compareRangeException(a, b) {
        if (a[0] > b[0])
          return 1;
        if (b[0] > a[0])
          return -1;
        return 0;
      }
      return Event;
    }();
    ICAL.ComponentParser = function() {
      function ComponentParser(options) {
        if (typeof options === "undefined") {
          options = {};
        }
        var key;
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }
      }
      ComponentParser.prototype = {
        parseEvent: true,
        parseTimezone: true,
        oncomplete: function() {
        },
        onerror: function(err) {
        },
        ontimezone: function(component) {
        },
        onevent: function(component) {
        },
        process: function(ical) {
          if (typeof ical === "string") {
            ical = ICAL.parse(ical);
          }
          if (!(ical instanceof ICAL.Component)) {
            ical = new ICAL.Component(ical);
          }
          var components = ical.getAllSubcomponents();
          var i = 0;
          var len = components.length;
          var component;
          for (; i < len; i++) {
            component = components[i];
            switch (component.name) {
              case "vtimezone":
                if (this.parseTimezone) {
                  var tzid = component.getFirstPropertyValue("tzid");
                  if (tzid) {
                    this.ontimezone(new ICAL.Timezone({
                      tzid,
                      component
                    }));
                  }
                }
                break;
              case "vevent":
                if (this.parseEvent) {
                  this.onevent(new ICAL.Event(component));
                }
                break;
              default:
                continue;
            }
          }
          this.oncomplete();
        }
      };
      return ComponentParser;
    }();
  }
});

// node_modules/ical-expander/zones-compiled.json
var require_zones_compiled = __commonJS({
  "node_modules/ical-expander/zones-compiled.json"(exports, module) {
    module.exports = { "Africa/Abidjan": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Accra": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Addis_Ababa": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Algiers": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Asmara": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Bamako": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Bangui": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Banjul": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Bissau": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Blantyre": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Brazzaville": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Bujumbura": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Cairo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Casablanca": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20180325T020000\r\nRDATE:20180325T020000\r\nRDATE:20180617T020000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:20180513T030000\r\nRDATE:20180513T030000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20190609T020000\r\nRDATE:20190609T020000\r\nRDATE:20200531T020000\r\nRDATE:20210516T020000\r\nRDATE:20220508T020000\r\nRDATE:20230430T020000\r\nRDATE:20240414T020000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20181028T030000\r\nRDATE:20181028T030000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:20190505T030000\r\nRDATE:20190505T030000\r\nRDATE:20200419T030000\r\nRDATE:20210411T030000\r\nRDATE:20220327T030000\r\nRDATE:20230319T030000\r\nRDATE:20240310T030000\r\nEND:DAYLIGHT", "Africa/Ceuta": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Africa/Conakry": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Dakar": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Dar_es_Salaam": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Djibouti": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Douala": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/El_Aaiun": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20180325T020000\r\nRDATE:20180325T020000\r\nRDATE:20180617T020000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:20180513T030000\r\nRDATE:20180513T030000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20181028T030000\r\nRDATE:20181028T030000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:20190505T030000\r\nRDATE:20190505T030000\r\nRDATE:20200419T030000\r\nRDATE:20210411T030000\r\nRDATE:20220327T030000\r\nRDATE:20230319T030000\r\nRDATE:20240310T030000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20190609T020000\r\nRDATE:20190609T020000\r\nRDATE:20200531T020000\r\nRDATE:20210516T020000\r\nRDATE:20220508T020000\r\nRDATE:20230430T020000\r\nRDATE:20240414T020000\r\nEND:STANDARD", "Africa/Freetown": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Gaborone": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Harare": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Johannesburg": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Juba": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Kampala": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Khartoum": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Kigali": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Kinshasa": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Lagos": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Libreville": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Lome": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Luanda": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Lubumbashi": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Lusaka": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Malabo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Maputo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Maseru": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Mbabane": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Mogadishu": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Monrovia": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Nairobi": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Ndjamena": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Niamey": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Nouakchott": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Ouagadougou": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Porto-Novo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Sao_Tome": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:20180101T010000\r\nRDATE:20180101T010000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:20190101T020000\r\nRDATE:20190101T020000\r\nEND:STANDARD", "Africa/Tripoli": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Tunis": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Windhoek": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Adak": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Anchorage": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Anguilla": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Antigua": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Araguaina": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Buenos_Aires": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Catamarca": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Cordoba": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Jujuy": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/La_Rioja": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Mendoza": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Rio_Gallegos": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Salta": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/San_Juan": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/San_Luis": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Tucuman": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Argentina/Ushuaia": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Aruba": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Asuncion": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701004T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700322T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=4SU\r\nEND:STANDARD", "America/Atikokan": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Bahia": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Bahia_Banderas": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT", "America/Barbados": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Belem": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Belize": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Blanc-Sablon": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Boa_Vista": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Bogota": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Boise": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Cambridge_Bay": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Campo_Grande": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20181104T000000\r\nRDATE:20181104T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:20180218T000000\r\nRDATE:20180218T000000\r\nRDATE:20190217T000000\r\nEND:STANDARD", "America/Cancun": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Caracas": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Cayenne": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Cayman": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Chicago": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Chihuahua": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "America/Costa_Rica": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Creston": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Cuiaba": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20181104T000000\r\nRDATE:20181104T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:20180218T000000\r\nRDATE:20180218T000000\r\nRDATE:20190217T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Curacao": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Danmarkshavn": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Dawson": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:20180311T020000\r\nRDATE:20180311T020000\r\nRDATE:20190310T020000\r\nRDATE:20200308T020000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:20181104T020000\r\nRDATE:20181104T020000\r\nRDATE:20191103T020000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:20201101T000000\r\nRDATE:20201101T000000\r\nEND:STANDARD", "America/Dawson_Creek": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Denver": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Detroit": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Dominica": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Edmonton": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Eirunepe": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/El_Salvador": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Fort_Nelson": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Fortaleza": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Glace_Bay": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Goose_Bay": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT", "America/Grand_Turk": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:20181104T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:20190310T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:20180311T020000\r\nRDATE:20180311T020000\r\nEND:DAYLIGHT", "America/Grenada": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Guadeloupe": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Guatemala": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Guayaquil": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Guyana": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Halifax": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Havana": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:CST\r\nDTSTART:19701101T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:CDT\r\nDTSTART:19700308T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT", "America/Hermosillo": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Indiana/Indianapolis": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Indiana/Knox": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Indiana/Marengo": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Indiana/Petersburg": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Indiana/Tell_City": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Indiana/Vevay": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Indiana/Vincennes": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Indiana/Winamac": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT", "America/Inuvik": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Iqaluit": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Jamaica": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Juneau": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Kentucky/Louisville": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Kentucky/Monticello": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Kralendijk": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/La_Paz": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Lima": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Los_Angeles": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Lower_Princes": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Maceio": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Managua": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Manaus": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Marigot": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Martinique": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Matamoros": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Mazatlan": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "America/Menominee": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Merida": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "America/Metlakatla": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:20191103T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:20181104T020000\r\nRDATE:20181104T020000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:20190120T020000\r\nRDATE:20190120T020000\r\nEND:STANDARD", "America/Mexico_City": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "America/Miquelon": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Moncton": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Monterrey": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "America/Montevideo": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Montserrat": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Nassau": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/New_York": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Nipigon": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Nome": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Noronha": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/North_Dakota/Beulah": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/North_Dakota/Center": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/North_Dakota/New_Salem": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Nuuk": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700328T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701024T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:STANDARD", "America/Ojinaga": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Panama": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Pangnirtung": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Paramaribo": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Phoenix": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Port-au-Prince": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Port_of_Spain": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Porto_Velho": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Puerto_Rico": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Punta_Arenas": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Rainy_River": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Rankin_Inlet": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Recife": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Regina": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Resolute": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT", "America/Rio_Branco": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Santarem": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Santiago": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:20190407T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYMONTHDAY=2,3,4,5,6,7,8;BYDAY=SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20190908T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYMONTHDAY=2,3,4,5,6,7,8;BYDAY=SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20180812T000000\r\nRDATE:20180812T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:20180513T000000\r\nRDATE:20180513T000000\r\nEND:STANDARD", "America/Santo_Domingo": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Sao_Paulo": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:20181104T000000\r\nRDATE:20181104T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20180218T000000\r\nRDATE:20180218T000000\r\nRDATE:20190217T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:DAYLIGHT", "America/Scoresbysund": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "America/Sitka": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/St_Barthelemy": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/St_Johns": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT", "America/St_Kitts": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/St_Lucia": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/St_Thomas": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/St_Vincent": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Swift_Current": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Tegucigalpa": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Thule": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Thunder_Bay": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Tijuana": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Toronto": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Tortola": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Vancouver": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Whitehorse": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:20180311T020000\r\nRDATE:20180311T020000\r\nRDATE:20190310T020000\r\nRDATE:20200308T020000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:20181104T020000\r\nRDATE:20181104T020000\r\nRDATE:20191103T020000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:20201101T000000\r\nRDATE:20201101T000000\r\nEND:STANDARD", "America/Winnipeg": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Yakutat": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Yellowknife": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Antarctica/Casey": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:20181007T040000\r\nRDATE:20181007T040000\r\nRDATE:20191004T030000\r\nRDATE:20201004T000100\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:20180311T040000\r\nRDATE:20180311T040000\r\nRDATE:20190317T030000\r\nRDATE:20200308T030000\r\nEND:STANDARD", "Antarctica/Davis": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Antarctica/DumontDUrville": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Antarctica/Macquarie": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Antarctica/Mawson": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Antarctica/McMurdo": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD", "Antarctica/Palmer": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Antarctica/Rothera": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Antarctica/Syowa": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Antarctica/Troll": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0200\r\nTZNAME:+02\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Antarctica/Vostok": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Arctic/Longyearbyen": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Asia/Aden": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Almaty": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Amman": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700326T235959\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1TH\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701030T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\r\nEND:STANDARD", "Asia/Anadyr": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Aqtau": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Aqtobe": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Ashgabat": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Atyrau": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Baghdad": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Bahrain": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Baku": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Bangkok": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Barnaul": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Beirut": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Asia/Bishkek": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Brunei": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Chita": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Choibalsan": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Colombo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:+0530\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Damascus": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701030T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700327T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT", "Asia/Dhaka": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Dili": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Dubai": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Dushanbe": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Famagusta": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:20180325T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT", "Asia/Gaza": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:20200328T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:20201024T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:20180324T010000\r\nRDATE:20180324T010000\r\nRDATE:20190329T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:20181027T010000\r\nRDATE:20181027T010000\r\nRDATE:20191026T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Hebron": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:20200328T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:20201024T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:20180324T010000\r\nRDATE:20180324T010000\r\nRDATE:20190329T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:20181027T010000\r\nRDATE:20181027T010000\r\nRDATE:20191026T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Ho_Chi_Minh": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Hong_Kong": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:HKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Hovd": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Irkutsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Istanbul": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Jakarta": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Jayapura": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:WIT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Jerusalem": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYMONTHDAY=23,24,25,26,27,28,29;BYDAY=FR\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Asia/Kabul": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0430\r\nTZOFFSETTO:+0430\r\nTZNAME:+0430\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Kamchatka": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Karachi": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:PKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Kathmandu": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Khandyga": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Kolkata": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Krasnoyarsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Kuala_Lumpur": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Kuching": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Kuwait": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Macau": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Magadan": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Makassar": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:WITA\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Manila": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:PST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Muscat": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Nicosia": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT", "Asia/Novokuznetsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Novosibirsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Omsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Oral": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Phnom_Penh": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Pontianak": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Pyongyang": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0830\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0830\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:20180504T233000\r\nRDATE:20180504T233000\r\nEND:STANDARD", "Asia/Qatar": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Qostanay": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Qyzylorda": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:20181221T000000\r\nRDATE:20181221T000000\r\nEND:STANDARD", "Asia/Riyadh": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Sakhalin": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Samarkand": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Seoul": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Shanghai": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Singapore": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Srednekolymsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Taipei": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Tashkent": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Tbilisi": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Tehran": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0330\r\nTZNAME:+0330\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0330\r\nTZOFFSETTO:+0430\r\nTZNAME:+0430\r\nDTSTART:20180321T235959\r\nRDATE:20180321T235959\r\nRDATE:20190321T235959\r\nRDATE:20200320T235959\r\nRDATE:20210321T235959\r\nRDATE:20220321T235959\r\nRDATE:20230321T235959\r\nRDATE:20240320T235959\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0430\r\nTZOFFSETTO:+0330\r\nTZNAME:+0330\r\nDTSTART:20180921T235959\r\nRDATE:20180921T235959\r\nRDATE:20190921T235959\r\nRDATE:20200920T235959\r\nRDATE:20210921T235959\r\nRDATE:20220921T235959\r\nRDATE:20230921T235959\r\nRDATE:20240920T235959\r\nEND:STANDARD", "Asia/Thimphu": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Tokyo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:JST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Tomsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Ulaanbaatar": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Urumqi": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Ust-Nera": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Vientiane": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Vladivostok": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Yakutsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Yangon": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Yekaterinburg": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Yerevan": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Atlantic/Azores": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Atlantic/Bermuda": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Atlantic/Canary": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Atlantic/Cape_Verde": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Atlantic/Faroe": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Atlantic/Madeira": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Atlantic/Reykjavik": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Atlantic/South_Georgia": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Atlantic/St_Helena": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Atlantic/Stanley": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Australia/Adelaide": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Australia/Brisbane": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Australia/Broken_Hill": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Australia/Currie": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD", "Australia/Darwin": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Australia/Eucla": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0845\r\nTZOFFSETTO:+0845\r\nTZNAME:+0845\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Australia/Hobart": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD", "Australia/Lindeman": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Australia/Lord_Howe": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1030\r\nTZNAME:+1030\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Australia/Melbourne": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Australia/Perth": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Australia/Sydney": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Europe/Amsterdam": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Andorra": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Astrakhan": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Athens": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Belgrade": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Berlin": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Bratislava": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Brussels": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Bucharest": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Budapest": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Busingen": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Chisinau": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Copenhagen": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Dublin": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:IST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:DAYLIGHT", "Europe/Gibraltar": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Guernsey": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Helsinki": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Isle_of_Man": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Istanbul": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Jersey": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Kaliningrad": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Kiev": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Kirov": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Lisbon": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT", "Europe/Ljubljana": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/London": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Luxembourg": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Madrid": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Malta": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Mariehamn": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Minsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Monaco": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Moscow": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Nicosia": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT", "Europe/Oslo": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Paris": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Podgorica": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Prague": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Riga": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Rome": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Samara": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/San_Marino": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Sarajevo": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Saratov": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Simferopol": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Skopje": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Sofia": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Stockholm": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Tallinn": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Tirane": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Ulyanovsk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Uzhgorod": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Vaduz": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Vatican": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Vienna": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Vilnius": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Volgograd": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:20181028T020000\r\nRDATE:20181028T020000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Warsaw": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Zagreb": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Zaporozhye": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Europe/Zurich": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Indian/Antananarivo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Chagos": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Christmas": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Cocos": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Comoro": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Kerguelen": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Mahe": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Maldives": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Mauritius": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Mayotte": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Indian/Reunion": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Apia": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1400\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700405T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1400\r\nTZNAME:+14\r\nDTSTART:19700927T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT", "Pacific/Auckland": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD", "Pacific/Bougainville": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Chatham": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1245\r\nTZOFFSETTO:+1345\r\nTZNAME:+1345\r\nDTSTART:19700927T024500\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1345\r\nTZOFFSETTO:+1245\r\nTZNAME:+1245\r\nDTSTART:19700405T034500\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD", "Pacific/Chuuk": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Easter": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:20190406T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SA\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:20190907T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SA\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:20180811T220000\r\nRDATE:20180811T220000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:20180512T220000\r\nRDATE:20180512T220000\r\nEND:STANDARD", "Pacific/Efate": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Enderbury": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Fakaofo": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Fiji": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700118T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=1;BYMONTHDAY=12,13,14,15,16,17,18;BYDAY=SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:20211114T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:20181104T020000\r\nRDATE:20181104T020000\r\nRDATE:20191110T020000\r\nRDATE:20201220T020000\r\nEND:DAYLIGHT", "Pacific/Funafuti": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Galapagos": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Gambier": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0900\r\nTZNAME:-09\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Guadalcanal": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Guam": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Honolulu": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Kiritimati": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1400\r\nTZOFFSETTO:+1400\r\nTZNAME:+14\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Kosrae": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Kwajalein": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Majuro": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Marquesas": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0930\r\nTZOFFSETTO:-0930\r\nTZNAME:-0930\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Midway": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Nauru": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Niue": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:-11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Norfolk": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:20191006T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:20200405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1130\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:20190701T000000\r\nRDATE:20190701T000000\r\nEND:STANDARD", "Pacific/Noumea": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Pago_Pago": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Palau": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Pitcairn": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0800\r\nTZNAME:-08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Pohnpei": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Port_Moresby": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Rarotonga": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Saipan": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Tahiti": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Tarawa": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Tongatapu": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Wake": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific/Wallis": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "AUS Central Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "AUS Eastern Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Afghanistan Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0430\r\nTZOFFSETTO:+0430\r\nTZNAME:+0430\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Asmera": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Africa/Timbuktu": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Alaskan Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Argentina/ComodRivadavia": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Buenos_Aires": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "America/Godthab": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700328T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701024T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYMONTHDAY=24,25,26,27,28,29,30;BYDAY=SA\r\nEND:STANDARD", "America/Louisville": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Montreal": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "America/Santa_Isabel": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Arab Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Arabian Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Arabic Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Argentina Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Calcutta": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Katmandu": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Rangoon": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Asia/Saigon": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Atlantic Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Atlantic/Faeroe": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Atlantic/Jan_Mayen": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Azerbaijan Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Azores Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Bahia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Bangladesh Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Belarus Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Canada Central Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Cape Verde Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Caucasus Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Cen. Australia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT", "Central America Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Central Asia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Central Brazilian Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20181104T000000\r\nRDATE:20181104T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:20180218T000000\r\nRDATE:20180218T000000\r\nRDATE:20190217T000000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Central Europe Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Central European Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Central Pacific Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Central Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Central Standard Time (Mexico)": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "China Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "E. Africa Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "E. Australia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "E. South America Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:20181104T000000\r\nRDATE:20181104T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20180218T000000\r\nRDATE:20180218T000000\r\nRDATE:20190217T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:DAYLIGHT", "Eastern Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Egypt Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Ekaterinburg Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Europe/Belfast": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "FLE Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Fiji Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700118T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=1;BYMONTHDAY=12,13,14,15,16,17,18;BYDAY=SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:20211114T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:20181104T020000\r\nRDATE:20181104T020000\r\nRDATE:20191110T020000\r\nRDATE:20201220T020000\r\nEND:DAYLIGHT", "GMT Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "GTB Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Georgian Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Greenwich Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Hawaiian Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Iran Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0330\r\nTZNAME:+0330\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0330\r\nTZOFFSETTO:+0430\r\nTZNAME:+0430\r\nDTSTART:20180321T235959\r\nRDATE:20180321T235959\r\nRDATE:20190321T235959\r\nRDATE:20200320T235959\r\nRDATE:20210321T235959\r\nRDATE:20220321T235959\r\nRDATE:20230321T235959\r\nRDATE:20240320T235959\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0430\r\nTZOFFSETTO:+0330\r\nTZNAME:+0330\r\nDTSTART:20180921T235959\r\nRDATE:20180921T235959\r\nRDATE:20190921T235959\r\nRDATE:20200920T235959\r\nRDATE:20210921T235959\r\nRDATE:20220921T235959\r\nRDATE:20230921T235959\r\nRDATE:20240920T235959\r\nEND:STANDARD", "Israel Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYMONTHDAY=23,24,25,26,27,28,29;BYDAY=FR\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Jordan Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700326T235959\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1TH\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701030T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\r\nEND:STANDARD", "Kaliningrad Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Korea Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Libya Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Line Islands Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1400\r\nTZOFFSETTO:+1400\r\nTZNAME:+14\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Magadan Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Mauritius Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Middle East Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Montevideo Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Morocco Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20180325T020000\r\nRDATE:20180325T020000\r\nRDATE:20180617T020000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:20180513T030000\r\nRDATE:20180513T030000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20190609T020000\r\nRDATE:20190609T020000\r\nRDATE:20200531T020000\r\nRDATE:20210516T020000\r\nRDATE:20220508T020000\r\nRDATE:20230430T020000\r\nRDATE:20240414T020000\r\nEND:STANDARD\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:20181028T030000\r\nRDATE:20181028T030000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:20190505T030000\r\nRDATE:20190505T030000\r\nRDATE:20200419T030000\r\nRDATE:20210411T030000\r\nRDATE:20220327T030000\r\nRDATE:20230319T030000\r\nRDATE:20240310T030000\r\nEND:DAYLIGHT", "Mountain Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Mountain Standard Time (Mexico)": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "N. Central Asia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Namibia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "New Zealand Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD", "Newfoundland Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT", "North Asia East Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "North Asia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pacific SA Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:20190407T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYMONTHDAY=2,3,4,5,6,7,8;BYDAY=SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20190908T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYMONTHDAY=2,3,4,5,6,7,8;BYDAY=SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:20180812T000000\r\nRDATE:20180812T000000\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:20180513T000000\r\nRDATE:20180513T000000\r\nEND:STANDARD", "Pacific Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Pacific/Johnston": "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Pakistan Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:PKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Paraguay Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701004T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700322T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=4SU\r\nEND:STANDARD", "Romance Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "Russia Time Zone 10": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Russia Time Zone 11": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Russia Time Zone 3": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Russian Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "SA Eastern Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "SA Pacific Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "SA Western Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "SE Asia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Samoa Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1400\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700405T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1400\r\nTZNAME:+14\r\nDTSTART:19700927T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT", "Singapore Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "South Africa Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Sri Lanka Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:+0530\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Syria Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701030T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\r\nEND:STANDARD\r\nBEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700327T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT", "Taipei Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Tasmania Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD", "Tokyo Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:JST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Tonga Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Turkey Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "US Eastern Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "US Mountain Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "US/Central": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "US/Eastern": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "US/Mountain": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "US/Pacific": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "US/Pacific-New": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD", "Ulaanbaatar Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Venezuela Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Vladivostok Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "W. Australia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "W. Central Africa Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "W. Europe Standard Time": "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT\r\nBEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD", "West Asia Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "West Pacific Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD", "Yakutsk Standard Time": "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD" };
  }
});

// node_modules/ical-expander/index.js
var require_ical_expander = __commonJS({
  "node_modules/ical-expander/index.js"(exports, module) {
    "use strict";
    var ICAL = require_ical();
    var timezones = require_zones_compiled();
    var IcalExpander2 = class {
      constructor(opts) {
        this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1e3;
        this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;
        this.jCalData = ICAL.parse(opts.ics);
        this.component = new ICAL.Component(this.jCalData);
        this.events = this.component.getAllSubcomponents("vevent").map((vevent) => new ICAL.Event(vevent));
        if (this.skipInvalidDates) {
          this.events = this.events.filter((evt) => {
            try {
              evt.startDate.toJSDate();
              evt.endDate.toJSDate();
              return true;
            } catch (err) {
              return false;
            }
          });
        }
      }
      between(after, before) {
        function isEventWithinRange(startTime, endTime) {
          return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());
        }
        function getTimes(eventOrOccurrence) {
          const startTime = eventOrOccurrence.startDate.toJSDate().getTime();
          let endTime = eventOrOccurrence.endDate.toJSDate().getTime();
          if (eventOrOccurrence.endDate.isDate && endTime > startTime) {
            endTime -= 1;
          }
          return { startTime, endTime };
        }
        const exceptions = [];
        this.events.forEach((event) => {
          if (event.isRecurrenceException())
            exceptions.push(event);
        });
        const ret = {
          events: [],
          occurrences: []
        };
        this.events.filter((e) => !e.isRecurrenceException()).forEach((event) => {
          const exdates = [];
          event.component.getAllProperties("exdate").forEach((exdateProp) => {
            const exdate = exdateProp.getFirstValue();
            exdates.push(exdate.toJSDate().getTime());
          });
          if (event.isRecurring()) {
            const iterator = event.iterator();
            let next;
            let i = 0;
            do {
              i += 1;
              next = iterator.next();
              if (next) {
                const occurrence = event.getOccurrenceDetails(next);
                const { startTime: startTime2, endTime: endTime2 } = getTimes(occurrence);
                const isOccurrenceExcluded = exdates.indexOf(startTime2) !== -1;
                const exception = exceptions.find((ex) => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());
                if (before && startTime2 > before.getTime())
                  break;
                if (isEventWithinRange(startTime2, endTime2)) {
                  if (exception) {
                    ret.events.push(exception);
                  } else if (!isOccurrenceExcluded) {
                    ret.occurrences.push(occurrence);
                  }
                }
              }
            } while (next && (!this.maxIterations || i < this.maxIterations));
            return;
          }
          const { startTime, endTime } = getTimes(event);
          if (isEventWithinRange(startTime, endTime))
            ret.events.push(event);
        });
        return ret;
      }
      before(before) {
        return this.between(void 0, before);
      }
      after(after) {
        return this.between(after);
      }
      all() {
        return this.between();
      }
    };
    function registerTimezones() {
      Object.keys(timezones).forEach((key) => {
        const icsData = timezones[key];
        const icsTimezone = `BEGIN:VTIMEZONE\r
TZID:${key}\r
${icsData}\r
END:VTIMEZONE`;
        const parsed = ICAL.parse(`BEGIN:VCALENDAR
PRODID:-//tzurl.org//NONSGML Olson 2012h//EN
VERSION:2.0
${icsTimezone}
END:VCALENDAR`);
        const comp = new ICAL.Component(parsed);
        const vtimezone = comp.getFirstSubcomponent("vtimezone");
        ICAL.TimezoneService.register(key, new ICAL.Timezone(vtimezone));
      });
    }
    registerTimezones();
    module.exports = IcalExpander2;
  }
});

// node_modules/dayjs/plugin/isBetween.js
var require_isBetween = __commonJS({
  "node_modules/dayjs/plugin/isBetween.js"(exports, module) {
    !function(e, i) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isBetween = i();
    }(exports, function() {
      "use strict";
      return function(e, i, t) {
        i.prototype.isBetween = function(e2, i2, s, f) {
          var n = t(e2), o = t(i2), r = "(" === (f = f || "()")[0], u = ")" === f[1];
          return (r ? this.isAfter(n, s) : !this.isBefore(n, s)) && (u ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r ? this.isBefore(n, s) : !this.isAfter(n, s)) && (u ? this.isAfter(o, s) : !this.isBefore(o, s));
        };
      };
    });
  }
});

// node_modules/mml-react/dist/mml-react.esm.js
var import_react = __toESM(require_react());
var import_parse_xml = __toESM(require_src());
var import_dayjs = __toESM(require_dayjs_min());
var import_sanitize_url = __toESM(require_dist());
var import_react_markdown = __toESM(require_react_markdown());
var import_linkifyjs = __toESM(require_linkifyjs());
var import_ical_expander = __toESM(require_ical_expander());
var import_isBetween = __toESM(require_isBetween());
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var runtime_1 = createCommonjsModule(function(module) {
  var runtime = function(exports) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define2(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define2({}, "");
    } catch (err) {
      define2 = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self2, context);
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function() {
      return this;
    };
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define2(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define2(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define2(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function() {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self2, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context);
          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method"
          );
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define2(Gp, toStringTagSymbol, "Generator");
    Gp[iteratorSymbol] = function() {
      return this;
    };
    Gp.toString = function() {
      return "[object Generator]";
    };
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key2 = keys.pop();
          if (key2 in object) {
            next.value = key2;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next2.value = iterable[i];
                next2.done = false;
                return next2;
              }
            }
            next2.value = undefined$1;
            next2.done = true;
            return next2;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
    module.exports
  );
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});
function isXmlElement(node) {
  return !!node.children;
}
var MMLTag = function() {
  function MMLTag2(name, node, children) {
    this.name = name;
    this.node = node;
    this.attributes = this.node.attributes || {};
    this.children = children;
  }
  var _proto = MMLTag2.prototype;
  _proto.getText = function getText() {
    if (this.node.type === "text")
      return this.node.text;
    else if (isXmlElement(this.node) && this.node.children.length)
      return this.node.children[0].text;
    return "";
  };
  _proto.initialState = function initialState() {
    var _ref;
    var _this$attributes = this.attributes, name = _this$attributes.name, value = _this$attributes.value;
    if (name)
      return _ref = {}, _ref[name] = value, _ref;
    return {};
  };
  return MMLTag2;
}();
var Card = function Card2(_ref) {
  var _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, children = _ref.children;
  return import_react.default.createElement("div", {
    className: "mml-card " + className
  }, children);
};
var Icon = function Icon2(_ref) {
  var name = _ref.name;
  return import_react.default.createElement("i", {
    className: "mml-icon material-icons"
  }, name);
};
var CardHeader = function CardHeader2(_ref) {
  var text2 = _ref.text, _ref$icon = _ref.icon, icon2 = _ref$icon === void 0 ? "" : _ref$icon, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  return import_react.default.createElement("div", {
    className: "mml-card-header " + className
  }, icon2 && import_react.default.createElement(Icon, {
    name: icon2
  }), import_react.default.createElement("span", {
    className: "mml-card-header__text"
  }, text2));
};
var CardBody = function CardBody2(_ref) {
  var _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, children = _ref.children;
  return import_react.default.createElement("div", {
    className: "mml-card-body " + className
  }, children);
};
var ButtonList = function ButtonList2(_ref) {
  var children = _ref.children, _ref$variant = _ref.variant, variant = _ref$variant === void 0 ? "" : _ref$variant;
  return import_react.default.createElement("div", {
    className: "mml-btnlist " + (variant === "floating" ? " mml-btnlist--floating" : "mml-btnlist--grounded")
  }, children);
};
var SvgIcon = function SvgIcon2(_ref) {
  var path = _ref.path;
  return import_react.default.createElement("i", {
    className: "mml-icon"
  }, import_react.default.createElement("svg", {
    className: "mml-icon__svg",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, import_react.default.createElement("path", {
    d: path
  })));
};
var IconGoogle = import_react.default.createElement(SvgIcon, {
  path: "M21.35 11.1h-9.17v2.73h6.5c-.33 3.8-3.5 5.44-6.5 5.44C8.36 19.27 5 16.25 5 12c0-4.1 3.2-7.27 7.2-7.27 3.1 0 4.9 1.97 4.9 1.97L19 4.72S16.56 2 12.1 2C6.42 2 2.03 6.8 2.03 12c0 5.05 4.13 10 10.22 10 5.35 0 9.25-3.67 9.25-9.1 0-1.15-.15-1.8-.15-1.8h0z"
});
var IconMicrosoft = import_react.default.createElement(SvgIcon, {
  path: "M3 12V6.75l6-1.32v6.48L3 12m17-9v8.75l-10 .15V5.2L20 3M3 13l6 .1v6.8l-6-1.15V13m17 .25V22l-10-1.9v-7l10 .15z"
});
var IconApple = import_react.default.createElement(SvgIcon, {
  path: "M18.7 19.5c-.83 1.24-1.7 2.45-3.05 2.47-1.34.03-1.77-.8-3.3-.8-1.53 0-2 .77-3.27.82-1.3.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.4c.87-1.52 2.43-2.48 4.12-2.5 1.28-.02 2.5.87 3.3.87.78 0 2.26-1.07 3.8-.9.65.03 2.47.26 3.64 1.98-.1.06-2.17 1.28-2.15 3.8.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.2-.7.85-1.83 1.5-2.95 1.42-.15-1.15.4-2.35 1.05-3.1z"
});
function isMobile() {
  var ua = typeof navigator !== "undefined" ? navigator.userAgent : "";
  if (!ua)
    return false;
  var mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
  if (mobileRE.test(ua))
    return true;
  if (typeof navigator !== "undefined" && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1)
    return true;
  return false;
}
var isIE = typeof window !== "undefined" && window.navigator.msSaveOrOpenBlob && window.Blob;
var getCurrentURL = function getCurrentURL2() {
  if (typeof window !== "undefined")
    return window.location.href;
  return "";
};
var CALENDAR_SERVICES = [{
  id: "google",
  label: "Google",
  Icon: IconGoogle
}, {
  id: "apple",
  label: "Apple Calendar",
  Icon: IconApple
}, {
  id: "outlook",
  label: "Outlook",
  Icon: IconMicrosoft
}, {
  id: "outlookcom",
  label: "Outlook.com",
  Icon: IconMicrosoft
}];
function formatTime(date, id) {
  return (0, import_dayjs.default)(date).format(id === "outlookcom" ? "YYYY-MM-DDTHH:mm:ss" : "YYYYMMDDTHHmmss") + "Z";
}
function createQueryString(params) {
  if (params === void 0) {
    params = {};
  }
  return Object.keys(params).reduce(function(acc, key) {
    var value = params[key];
    if (value)
      acc += "&" + key + "=" + encodeURIComponent(value);
    return acc;
  }, "");
}
function buildUrl(event, id) {
  var start = event.start, end = event.end, title = event.title, location = event.location, description = event.description;
  var startFormatted = formatTime(start, id);
  var endFormatted = formatTime(end, id);
  if (id === "google")
    return "https://calendar.google.com/calendar/render?action=TEMPLATE&dates=" + startFormatted + "/" + endFormatted + createQueryString({
      location,
      text: title,
      details: description
    });
  if (id === "outlookcom")
    return "https://outlook.live.com/owa/?rru=addevent" + createQueryString({
      startdt: startFormatted,
      enddt: endFormatted,
      subject: title,
      location,
      body: description,
      allday: "false"
    }) + "&path=/calendar/view/Month";
  var url = ["BEGIN:VCALENDAR", "VERSION:2.0", "BEGIN:VEVENT", "URL:" + getCurrentURL(), "DTSTART:" + startFormatted, "DTEND:" + endFormatted, "SUMMARY:" + title, "DESCRIPTION:" + description, "LOCATION:" + location, "END:VEVENT", "END:VCALENDAR"].join("\n");
  if (!isIE && isMobile())
    url = encodeURI("data:text/calendar;charset=utf8," + url);
  return url;
}
var AddToCalendar = function AddToCalendar2(_ref2) {
  var title = _ref2.title, start = _ref2.start, end = _ref2.end, _ref2$className = _ref2.className, className = _ref2$className === void 0 ? "" : _ref2$className, _ref2$location = _ref2.location, location = _ref2$location === void 0 ? "" : _ref2$location, _ref2$description = _ref2.description, description = _ref2$description === void 0 ? "" : _ref2$description;
  var event = {
    start,
    end,
    title,
    location,
    description
  };
  function handleLinkClick(event2) {
    event2.preventDefault();
    var url = event2.currentTarget.getAttribute("href");
    if (!isMobile() && (url.startsWith("data") || url.startsWith("BEGIN"))) {
      var filename = "download.ics";
      var blob = new Blob([url], {
        type: "text/calendar;charset=utf-8"
      });
      if (isIE) {
        window.navigator.msSaveOrOpenBlob(blob, filename);
      } else {
        var link = document.createElement("a");
        link.href = window.URL.createObjectURL(blob);
        link.setAttribute("download", filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    } else {
      window.open(url, "_blank");
    }
  }
  return import_react.default.createElement(Card, {
    className: "mml-add-to-calendar " + className
  }, import_react.default.createElement(CardHeader, {
    icon: "date_range",
    text: "Add to My Calendar"
  }), import_react.default.createElement(CardBody, null, import_react.default.createElement(ButtonList, null, CALENDAR_SERVICES.map(function(_ref3) {
    var id = _ref3.id, label = _ref3.label, Icon3 = _ref3.Icon;
    return import_react.default.createElement("a", {
      key: id,
      className: "mml-btn " + (Icon3 ? "mml-btn--with-icon" : ""),
      onClick: handleLinkClick,
      href: buildUrl(event, id),
      target: "_blank",
      rel: "nofollow noreferrer noopener"
    }, Icon3, " ", label);
  }))));
};
var Button = function Button2(_ref) {
  var _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, text2 = _ref.text, name = _ref.name, value = _ref.value, _ref$url = _ref.url, url = _ref$url === void 0 ? "" : _ref$url, variant = _ref.variant, icon2 = _ref.icon;
  if (icon2) {
    className += text2 ? " mml-btn--with-icon" : " mml-btn--icon";
  } else {
    className += " mml-btn--text";
  }
  className += variant === "floating" ? " mml-btn--floating" : " mml-btn--grounded";
  if (url)
    return import_react.default.createElement("a", {
      className: "mml-btn " + className,
      href: (0, import_sanitize_url.sanitizeUrl)(url),
      target: "_blank",
      rel: "nofollow noreferrer noopener"
    }, icon2 && import_react.default.createElement(Icon, {
      name: icon2
    }), text2);
  return import_react.default.createElement("button", {
    className: "mml-btn " + className,
    type: "submit",
    name,
    value,
    onClick: function onClick(event) {
      var _event$currentTarget, _event$currentTarget$;
      var input2 = document.createElement("input");
      input2.type = "hidden";
      input2.name = name || "";
      input2.value = value || "";
      (_event$currentTarget = event.currentTarget) == null ? void 0 : (_event$currentTarget$ = _event$currentTarget.closest("form")) == null ? void 0 : _event$currentTarget$.appendChild(input2);
    }
  }, icon2 && import_react.default.createElement(Icon, {
    name: icon2
  }), text2);
};
var Carousel = function Carousel2(_ref) {
  var children = _ref.children, _ref$slideWidth = _ref.slideWidth, slideWidth = _ref$slideWidth === void 0 ? "120px" : _ref$slideWidth, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  return import_react.default.createElement("div", {
    className: "mml-carousel " + className
  }, import_react.default.createElement("div", {
    className: "mml-carousel__track"
  }, import_react.default.createElement("div", {
    className: "mml-carousel__slides"
  }, import_react.Children.map(children, function(child) {
    return (0, import_react.cloneElement)(child, {
      className: "mml-carousel__slide",
      slideWidth
    });
  }))));
};
var CarouselItem = function CarouselItem2(_ref) {
  var children = _ref.children, slideWidth = _ref.slideWidth, _ref$width = _ref.width, width = _ref$width === void 0 ? "" : _ref$width, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var finalWidth = width || slideWidth;
  return import_react.default.createElement("div", {
    className: "mml-carousel-item " + className,
    style: {
      flex: "0 0 " + finalWidth,
      minWidth: finalWidth
    }
  }, children);
};
var Col = function Col2(_ref) {
  var children = _ref.children, _ref$width = _ref.width, width = _ref$width === void 0 ? 12 : _ref$width, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? 0 : _ref$offset, _ref$align = _ref.align, align = _ref$align === void 0 ? "left" : _ref$align;
  var classNames = "mml-col-" + width;
  if (offset)
    classNames = classNames + (" mml-offset-" + offset);
  classNames = classNames + (" mml-align-" + align);
  return import_react.default.createElement("div", {
    className: classNames
  }, children);
};
var Error$1 = function Error2(_ref) {
  var _ref$error = _ref.error, error = _ref$error === void 0 ? "" : _ref$error;
  if (!error)
    return null;
  return import_react.default.createElement("span", {
    className: "mml-error"
  }, error);
};
var Image = function Image2(_ref) {
  var src = _ref.src, _ref$alt = _ref.alt, alt = _ref$alt === void 0 ? "" : _ref$alt, _ref$title = _ref.title, title = _ref$title === void 0 ? "" : _ref$title, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  return import_react.default.createElement("img", {
    className: ("mml-image " + className).trim(),
    src,
    alt,
    title
  });
};
var Input = function Input2(_ref) {
  var name = _ref.name, label = _ref.label, _ref$value = _ref.value, value = _ref$value === void 0 ? "" : _ref$value, _ref$type = _ref.type, type = _ref$type === void 0 ? "text" : _ref$type, _ref$placeholder = _ref.placeholder, placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder;
  var _useState = (0, import_react.useState)(value), state = _useState[0], setState = _useState[1];
  var id = "mml-" + name;
  return import_react.default.createElement(import_react.default.Fragment, null, label && import_react.default.createElement("label", {
    className: "mml-card-header",
    htmlFor: id
  }, import_react.default.createElement("span", {
    className: "mml-card-header__text"
  }, label)), import_react.default.createElement("input", {
    id,
    className: "mml-input",
    name,
    value: state,
    type,
    placeholder,
    onChange: function onChange(event) {
      return setState(event.target.value);
    }
  }));
};
var SIZE = 44;
var Progress = function Progress2(_ref) {
  var size = _ref.size, _ref$thickness = _ref.thickness, thickness = _ref$thickness === void 0 ? 3.6 : _ref$thickness, color = _ref.color;
  thickness = typeof thickness === "string" ? parseFloat(thickness) : thickness;
  size = typeof size === "string" && /^\d+$/.test(size) || typeof size === "number" ? size + "px" : size;
  return import_react.default.createElement("span", {
    className: "mml-progress",
    role: "progressbar",
    style: {
      width: size,
      height: size,
      color
    }
  }, import_react.default.createElement("svg", {
    className: "mml-progress__svg",
    viewBox: SIZE / 2 + " " + SIZE / 2 + " " + SIZE + " " + SIZE
  }, import_react.default.createElement("circle", {
    className: "mml-progress__circle",
    cx: SIZE,
    cy: SIZE,
    r: (SIZE - thickness) / 2,
    fill: "none",
    strokeWidth: thickness
  })));
};
var Loading = function Loading2(_ref) {
  var _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$loading = _ref.loading, loading = _ref$loading === void 0 ? false : _ref$loading, text2 = _ref.text, size = _ref.size, thickness = _ref.thickness, color = _ref.color;
  if (!loading)
    return null;
  return import_react.default.createElement("div", {
    className: "mml-loading " + className
  }, import_react.default.createElement(Progress, Object.assign({}, {
    size,
    thickness,
    color
  })), text2 && import_react.default.createElement("div", {
    className: "mml-loading__text"
  }, text2));
};
var truncate = function truncate2(input2, length, end) {
  if (end === void 0) {
    end = "...";
  }
  if (input2.length > length)
    return "" + input2.substring(0, length - end.length) + end;
  return input2;
};
var matchMarkdownLinks = function matchMarkdownLinks2(message) {
  var regexMdLinks = /\[([^[]+)\](\(.*\))/gm;
  var matches = message.match(regexMdLinks);
  var singleMatch = /\[([^[]+)\]\((.*)\)/;
  var links = matches ? matches.map(function(match) {
    var i = singleMatch.exec(match);
    return i && i[2];
  }) : [];
  return links;
};
var MDLinkRender = function MDLinkRender2(props) {
  if (!props.href || !props.href.startsWith("http") && !props.href.startsWith("mailto:"))
    return props.children;
  return import_react.default.createElement("a", {
    href: props.href,
    target: "_blank",
    rel: "nofollow noreferrer noopener"
  }, props.children);
};
var markDownRenderers = {
  link: MDLinkRender
};
var allowedMarkups = [
  "html",
  "root",
  "text",
  "break",
  "paragraph",
  "emphasis",
  "strong",
  "link",
  "list",
  "listItem",
  "code",
  "inlineCode",
  "blockquote"
];
var MD = function MD2(_ref) {
  var text2 = _ref.text;
  if (!text2)
    return null;
  var newText = text2;
  var markdownLinks = matchMarkdownLinks(newText);
  (0, import_linkifyjs.find)(newText).forEach(function(_ref2) {
    var type = _ref2.type, href = _ref2.href, value = _ref2.value;
    var noParsingNeeded = markdownLinks && markdownLinks.filter(function(text3) {
      return (text3 == null ? void 0 : text3.indexOf(href)) !== -1;
    });
    if (noParsingNeeded.length > 0)
      return;
    var displayLink = type === "email" ? value : truncate(value.replace(/(http(s?):\/\/)?(www\.)?/, ""), 20);
    newText = newText.replace(value, "[" + displayLink + "](" + encodeURI(href) + ")");
  });
  return import_react.default.createElement("div", {
    className: "mml-md"
  }, import_react.default.createElement(import_react_markdown.default, {
    allowedTypes: allowedMarkups,
    renderers: markDownRenderers,
    source: newText,
    escapeHtml: true,
    unwrapDisallowed: true,
    transformLinkUri: function transformLinkUri(uri) {
      return uri.startsWith("app://") ? uri : import_react_markdown.default.uriTransformer(uri);
    }
  }));
};
var Number = function Number2(_ref) {
  var name = _ref.name, value = _ref.value;
  var _useState = (0, import_react.useState)(parseInt("" + value, 10) || 0), state = _useState[0], setState = _useState[1];
  return import_react.default.createElement("div", {
    className: "mml-number"
  }, import_react.default.createElement("input", {
    name,
    value: state,
    type: "hidden"
  }), import_react.default.createElement("span", {
    className: "mml-btn mml-btn--floating mml-btn--icon mml-number__dec",
    onClick: function onClick() {
      return setState(state - 1);
    }
  }, import_react.default.createElement(Icon, {
    name: "remove"
  })), import_react.default.createElement("span", {
    className: "mml-number__count"
  }, state), import_react.default.createElement("span", {
    className: "mml-btn mml-btn--floating mml-btn--icon mml-number__inc",
    onClick: function onClick() {
      return setState(state + 1);
    }
  }, import_react.default.createElement(Icon, {
    name: "add"
  })));
};
var Row = function Row2(_ref) {
  var children = _ref.children;
  return import_react.default.createElement("div", {
    className: "mml-row"
  }, children);
};
var ITEMS_PER_PAGE = 40;
var VERTICAL_COMPENSATION = 3;
var INITIAL_INDEX = ITEMS_PER_PAGE;
var VIRTUOSO_START_INDEX = 1e4;
var DatePickerSelect = function DatePickerSelect2(props) {
  var onChange = props.onChange, icalFilter = props.icalFilter, getItemData4 = props.getItemData, itemClassName = props.itemClassName, interval = props.interval, format = props.format, value = props.value;
  var generateItems = (0, import_react.useCallback)(function(quantity, firstIdx) {
    return Array(quantity).fill(true).map(function(_, idx) {
      return getItemData4({
        interval,
        format,
        value,
        idx: firstIdx + idx
      });
    }).filter(function(newItem) {
      return !icalFilter || icalFilter && icalFilter(newItem.value);
    });
  }, [interval, format, value, icalFilter, getItemData4]);
  var _useState = (0, import_react.useState)(generateItems(ITEMS_PER_PAGE * 2, -ITEMS_PER_PAGE)), items = _useState[0], setItems = _useState[1];
  var _useState2 = (0, import_react.useState)(VIRTUOSO_START_INDEX), firstItemIndex = _useState2[0], setFirstItemIndex = _useState2[1];
  var initialIndexOffset = (0, import_react.useRef)(INITIAL_INDEX);
  var _useState3 = (0, import_react.useState)(null), selectedIdx = _useState3[0], setSelectedIdx = _useState3[1];
  var handleClick = (0, import_react.useCallback)(function(item2) {
    onChange(item2.value);
    var firstItemIndex2 = initialIndexOffset.current || 0;
    var nextFirstItemIdx = firstItemIndex2 - INITIAL_INDEX - ITEMS_PER_PAGE;
    var missingTopItems = nextFirstItemIdx - item2.idx + VERTICAL_COMPENSATION;
    if (missingTopItems >= 0) {
      nextFirstItemIdx -= missingTopItems;
      initialIndexOffset.current -= firstItemIndex2 - missingTopItems;
      setItems(function(items2) {
        return [].concat(generateItems(missingTopItems, nextFirstItemIdx), items2);
      });
    }
    setSelectedIdx(item2.idx);
  }, [setItems, generateItems, initialIndexOffset, onChange]);
  var appendItems = (0, import_react.useCallback)(function(lastItemIndex) {
    setItems(function(items2) {
      return [].concat(items2, generateItems(ITEMS_PER_PAGE, lastItemIndex));
    });
  }, [setItems, generateItems]);
  var prependItems = (0, import_react.useCallback)(function() {
    var firstItemIndex2 = initialIndexOffset.current || 0;
    var nextFirstItemIdx = firstItemIndex2 - INITIAL_INDEX - ITEMS_PER_PAGE;
    if (initialIndexOffset) {
      initialIndexOffset.current -= ITEMS_PER_PAGE;
    }
    setItems(function(items2) {
      return [].concat(generateItems(ITEMS_PER_PAGE, nextFirstItemIdx), items2);
    });
    setFirstItemIndex(firstItemIndex2 - ITEMS_PER_PAGE);
    return false;
  }, [setItems, generateItems, initialIndexOffset]);
  (0, import_react.useEffect)(function() {
    if (value) {
      var initialSelectedIdx = null;
      for (var i = 0; i < items.length; i++) {
        if (items[i].isSelected(value)) {
          initialSelectedIdx = items[i].idx;
          break;
        }
      }
      setSelectedIdx(initialSelectedIdx);
    }
  }, []);
  return import_react.default.createElement(on, {
    data: items,
    firstItemIndex,
    itemContent: function itemContent(_, item2) {
      return import_react.default.createElement("div", {
        className: itemClassName + (" mml-datepicker__item " + (item2.idx === selectedIdx ? "mml-datepicker__item--selected" : "")),
        onClick: function onClick() {
          return handleClick(item2);
        }
      }, item2.displayValue);
    },
    endReached: appendItems,
    startReached: prependItems
  });
};
var getItemData = function getItemData2(props) {
  var idx = props.idx, interval = props.interval, value = props.value, format = props.format;
  var newValue = idx >= 0 ? (0, import_dayjs.default)(value).add(idx * (interval * 24), "hour") : (0, import_dayjs.default)(value).subtract(idx * (interval * 24) * -1, "hour");
  return {
    idx,
    value: newValue,
    displayValue: (0, import_dayjs.default)(newValue).format(format),
    isSelected: function isSelected(currentValue) {
      return (0, import_dayjs.default)(newValue).isSame(interval === 1 ? (0, import_dayjs.default)(currentValue) : (0, import_dayjs.default)(currentValue).add(interval, "day"), "date");
    }
  };
};
var DatePickerDate = function DatePickerDate2(props) {
  return import_react.default.createElement("div", {
    className: "mml-datepicker__select mml-datepicker__date"
  }, import_react.default.createElement(DatePickerSelect, Object.assign({}, props, {
    itemClassName: "mml-datepicker__item--day",
    getItemData
  })));
};
import_dayjs.default.extend(import_isBetween.default);
var getItemData$1 = function getItemData3(props) {
  var idx = props.idx, interval = props.interval, value = props.value, format = props.format;
  var newValue = idx >= 0 ? (0, import_dayjs.default)(value).add(idx * interval, "minute") : (0, import_dayjs.default)(value).subtract(idx * -1 * interval, "minute");
  return {
    idx,
    value: newValue,
    displayValue: (0, import_dayjs.default)(newValue).format(format),
    isSelected: function isSelected(currentValue) {
      return (0, import_dayjs.default)(newValue).isBetween(currentValue, (0, import_dayjs.default)(currentValue).add(interval - 1, "minute"), "minute", "[]");
    }
  };
};
var DatePickerTime = function DatePickerTime2(props) {
  return import_react.default.createElement("div", {
    className: "mml-datepicker__select mml-datepicker__time"
  }, import_react.default.createElement(DatePickerSelect, Object.assign({}, props, {
    itemClassName: "mml-datepicker__item--time",
    getItemData: getItemData$1
  })));
};
var DatePicker = function DatePicker2(_ref) {
  var name = _ref.name, selected = _ref.selected, dateInterval = _ref.dateInterval, timeInterval = _ref.timeInterval, dateFormat = _ref.dateFormat, timeFormat = _ref.timeFormat, fullDay = _ref.fullDay, icalFilter = _ref.icalFilter;
  var _useState = (0, import_react.useState)(selected), date = _useState[0], setDate = _useState[1];
  var handleChangeDate = function handleChangeDate2(value) {
    setDate(function(prevDate) {
      return prevDate.set("date", value.get("date")).set("month", value.get("month")).set("year", value.get("year"));
    });
  };
  var handleChangeTime = function handleChangeTime2(value) {
    setDate(function(prevDate) {
      return prevDate.set("minute", value.get("minute")).set("hour", value.get("hour"));
    });
  };
  return import_react.default.createElement("div", {
    className: "mml-datepicker mml-datepicker--" + (fullDay ? "single" : "double")
  }, import_react.default.createElement("input", {
    name,
    value: date.toISOString(),
    type: "hidden"
  }), import_react.default.createElement(DatePickerDate, {
    icalFilter,
    format: dateFormat,
    value: date,
    onChange: handleChangeDate,
    interval: dateInterval
  }), !fullDay && import_react.default.createElement(DatePickerTime, {
    icalFilter,
    format: timeFormat,
    value: date,
    onChange: handleChangeTime,
    interval: timeInterval
  }));
};
var setupIcalFilter = function() {
  var _ref = _asyncToGenerator(runtime_1.mark(function _callee(icalURL, duration) {
    var response, body, icalExpander;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch(icalURL, {
              method: "GET",
              redirect: "follow",
              credentials: "same-origin"
            });
          case 2:
            response = _context.sent;
            _context.next = 5;
            return response.text();
          case 5:
            body = _context.sent;
            if (response.ok) {
              _context.next = 8;
              break;
            }
            throw new Error(body);
          case 8:
            icalExpander = new import_ical_expander.default({
              ics: body,
              maxIterations: 10
            });
            return _context.abrupt("return", function() {
              return function(start) {
                if (!start)
                  return true;
                var _icalExpander$between = icalExpander.between(start.toDate(), start.add(duration, "minute").toDate()), events = _icalExpander$between.events;
                return !events.length;
              };
            });
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return function setupIcalFilter2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var Scheduler = function Scheduler2(_ref2) {
  var name = _ref2.name, selected = _ref2.selected, icalAvailability = _ref2.icalAvailability, _ref2$duration = _ref2.duration, duration = _ref2$duration === void 0 ? 30 : _ref2$duration, _ref2$dateInterval = _ref2.dateInterval, dateInterval = _ref2$dateInterval === void 0 ? 1 : _ref2$dateInterval, _ref2$timeInterval = _ref2.timeInterval, timeInterval = _ref2$timeInterval === void 0 ? 30 : _ref2$timeInterval, _ref2$dateFormat = _ref2.dateFormat, dateFormat = _ref2$dateFormat === void 0 ? "ddd MMM DD" : _ref2$dateFormat, _ref2$timeFormat = _ref2.timeFormat, timeFormat = _ref2$timeFormat === void 0 ? "hh:mm A" : _ref2$timeFormat, _ref2$fullDay = _ref2.fullDay, fullDay = _ref2$fullDay === void 0 ? false : _ref2$fullDay;
  var _useState = (0, import_react.useState)(false), loading = _useState[0], setLoading = _useState[1];
  var _useState2 = (0, import_react.useState)(""), error = _useState2[0], setError = _useState2[1];
  var _useState3 = (0, import_react.useState)(function() {
    return function() {
      return true;
    };
  }), icalFilter = _useState3[0], setIcalFilter = _useState3[1];
  (0, import_react.useEffect)(function() {
    if (!icalAvailability)
      return;
    setLoading(true);
    setupIcalFilter(icalAvailability, duration).then(setIcalFilter)["catch"](function(err) {
      console.warn("loading ical failed", {
        icalAvailability,
        err
      });
      setError("iCal availability could not be loaded");
    })["finally"](function() {
      return setLoading(false);
    });
  }, [icalAvailability, duration]);
  return import_react.default.createElement(Card, {
    className: "mml-scheduler"
  }, import_react.default.createElement(CardHeader, {
    icon: "date_range",
    text: "Scheduler"
  }), import_react.default.createElement(CardBody, null, error && !loading && import_react.default.createElement(Error$1, {
    error: "Failed, error: " + error
  }), !error && loading && import_react.default.createElement(Loading, {
    loading: true,
    text: "Loading availability"
  }), !error && !loading && import_react.default.createElement(DatePicker, {
    name,
    selected: selected ? (0, import_dayjs.default)(selected) : (0, import_dayjs.default)().startOf("hour"),
    dateInterval,
    timeInterval,
    dateFormat,
    timeFormat,
    fullDay,
    icalFilter
  })));
};
var Success = function Success2(_ref) {
  var success = _ref.success;
  if (success)
    return import_react.default.createElement("div", {
      className: "mml-success"
    }, success);
  return null;
};
var Text = function Text2(_ref) {
  var text2 = _ref.text, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  return import_react.default.createElement("div", {
    className: ("mml-text " + className).trim()
  }, text2);
};
var converters = {
  button: function button(tag) {
    return import_react.default.createElement(Button, Object.assign({}, tag.attributes, {
      key: tag.key,
      text: tag.getText(),
      name: tag.attributes.name,
      value: tag.attributes.value
    }));
  },
  button_list: function button_list(tag, children) {
    return import_react.default.createElement(ButtonList, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  input: function input(tag) {
    return import_react.default.createElement(Input, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name,
      value: tag.attributes.value
    }));
  },
  add_to_calendar: function add_to_calendar(tag) {
    return import_react.default.createElement(AddToCalendar, Object.assign({}, tag.attributes, {
      key: tag.key,
      title: tag.attributes.title,
      start: tag.attributes.start,
      end: tag.attributes.end
    }));
  },
  col: function col(tag, children) {
    return import_react.default.createElement(Col, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  row: function row(tag, children) {
    return import_react.default.createElement(Row, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  icon: function icon(tag) {
    return import_react.default.createElement(Icon, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name
    }));
  },
  image: function image(tag) {
    return import_react.default.createElement(Image, Object.assign({}, tag.attributes, {
      key: tag.key,
      src: tag.attributes.src
    }));
  },
  md: function md(tag) {
    return import_react.default.createElement(MD, Object.assign({}, tag.attributes, {
      key: tag.key,
      text: tag.getText()
    }));
  },
  text: function text(tag) {
    return import_react.default.createElement(Text, Object.assign({}, tag.attributes, {
      key: tag.key,
      text: tag.getText()
    }));
  },
  scheduler: function scheduler(tag) {
    return import_react.default.createElement(Scheduler, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name,
      dateInterval: parseInt(tag.attributes.dateInterval, 10) || 1,
      timeInterval: parseInt(tag.attributes.timeInterval, 10) || 30,
      duration: parseInt(tag.attributes.duration, 10) || 30,
      selected: tag.attributes.selected,
      fullDay: tag.attributes.fullDay === "true",
      icalAvailability: tag.attributes.icalAvailability
    }));
  },
  carousel: function carousel(tag, children) {
    return import_react.default.createElement(Carousel, Object.assign({
      slideWidth: tag.attributes.slideWidth
    }, tag.attributes, {
      key: tag.key
    }), children);
  },
  item: function item(tag, children) {
    return import_react.default.createElement(CarouselItem, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  number: function number(tag) {
    return import_react.default.createElement(Number, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name,
      value: tag.attributes.value
    }));
  }
};
var Tree = function() {
  function Tree2(node, children, customConvertors) {
    this.converters = _extends({}, converters, customConvertors);
    this.node = node;
    this.children = children;
    this.reactElements = this.toReact();
    this.name = node.attributes.name;
    this.type = node.attributes.type;
  }
  var _proto = Tree2.prototype;
  _proto.toReact = function toReact(parent) {
    var _this = this;
    if (parent === void 0) {
      parent = this;
    }
    var reactNodes = [];
    (parent.children || []).forEach(function(child, i) {
      var converter = _this.converters[child.name];
      if (!converter || !Object.hasOwnProperty.call(_this.converters, child.name)) {
        throw Error("Converter not found for tag " + child.name + ", Available converters are " + Object.keys(_this.converters));
      }
      var children = _this.toReact(child);
      child.key = "tag-" + child.name + "-position-" + i;
      reactNodes.push(converter(child, children));
    });
    return reactNodes;
  };
  return Tree2;
}();
function SourceToXML(source) {
  var src = source.trim();
  if (!src.startsWith("<mml"))
    src = "<mml>" + source + "</mml>";
  var unescapedAmps = /&(?!amp;|lt;|gt;)/g;
  src = src.replace(unescapedAmps, "&amp;");
  return (0, import_parse_xml.default)(src);
}
function convertNodes(nodes) {
  return nodes.reduce(function(acc, node) {
    var element = node;
    var children;
    if (element.children)
      children = convertNodes(element.children);
    var name = element.name;
    if (node.type === "text") {
      if (node.text.trim().length)
        name = "text";
      else
        return acc;
    }
    acc.push(new MMLTag(name, node, children));
    return acc;
  }, []);
}
function XMLtoMMLTree(document2, customConvertors) {
  if (!document2 || !document2.children || !document2.children.length)
    throw new Error("bad input");
  var mmlNode = document2.children[0];
  if (mmlNode.name !== "mml")
    throw new Error("missing mml tag");
  return new Tree(mmlNode, convertNodes(mmlNode.children), customConvertors);
}
function Parse(source, customConvertors) {
  var XMLNodes = SourceToXML(source);
  return XMLtoMMLTree(XMLNodes, customConvertors);
}
var MML = function MML2(_ref) {
  var source = _ref.source, onSubmit = _ref.onSubmit, converters2 = _ref.converters, _ref$theme = _ref.theme, theme = _ref$theme === void 0 ? "" : _ref$theme, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$Loading = _ref.Loading, Loading$1 = _ref$Loading === void 0 ? Loading : _ref$Loading, _ref$Error = _ref.Error, Error3 = _ref$Error === void 0 ? Error$1 : _ref$Error, _ref$Success = _ref.Success, Success$1 = _ref$Success === void 0 ? Success : _ref$Success;
  var _useState = (0, import_react.useState)(""), error = _useState[0], setError = _useState[1];
  var _useState2 = (0, import_react.useState)({
    loading: false,
    error: "",
    success: ""
  }), submitState = _useState2[0], setSubmitState = _useState2[1];
  var tree = (0, import_react.useMemo)(function() {
    try {
      return Parse(source, converters2);
    } catch (e) {
      console.warn("mml parsing error: ", source, e);
      setError("This chat message has invalid formatting and can't be shown");
      return null;
    }
  }, [source, converters2]);
  var handleSubmit = (0, import_react.useCallback)(function() {
    var _ref2 = _asyncToGenerator(runtime_1.mark(function _callee(event) {
      var state;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              event.preventDefault();
              state = {};
              if (tree != null && tree.name)
                state.mml_name = tree.name;
              new FormData(event.currentTarget).forEach(function(value, key) {
                state[key] = value;
              });
              if (onSubmit) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", console.warn("Forgot to pass onSubmit prop to <MML/>? payload:", state));
            case 6:
              _context.prev = 6;
              setSubmitState({
                loading: true,
                error: "",
                success: ""
              });
              _context.next = 10;
              return onSubmit(state);
            case 10:
              setSubmitState({
                loading: false,
                error: "",
                success: "submitted"
              });
              _context.next = 16;
              break;
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](6);
              setSubmitState({
                loading: false,
                error: "Failed to send the request. Please try again.",
                success: ""
              });
            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[6, 13]]);
    }));
    return function(_x) {
      return _ref2.apply(this, arguments);
    };
  }(), [onSubmit, tree]);
  return import_react.default.createElement("div", {
    className: "mml-container " + theme + " " + className,
    "data-testid": "mml-container"
  }, error ? import_react.default.createElement("div", {
    className: "mml-wrap"
  }, Error3 && import_react.default.createElement(Error3, {
    error
  })) : import_react.default.createElement("form", {
    onSubmit: handleSubmit,
    className: "mml-wrap",
    "data-testid": "mml-form"
  }, tree != null && tree.type ? import_react.default.createElement("div", {
    className: "mml-card"
  }, tree == null ? void 0 : tree.reactElements) : tree == null ? void 0 : tree.reactElements, submitState.loading && Loading$1 && import_react.default.createElement(Loading$1, {
    loading: submitState.loading
  }), submitState.success && Success$1 && import_react.default.createElement(Success$1, {
    success: submitState.success
  }), submitState.error && Error3 && import_react.default.createElement(Error3, {
    error: submitState.error
  })));
};
export {
  AddToCalendar,
  Button,
  ButtonList,
  Card,
  CardBody,
  CardHeader,
  Carousel,
  CarouselItem,
  Col,
  Error$1 as Error,
  Icon,
  Image,
  Input,
  Loading,
  MD,
  MML,
  MMLTag,
  Number,
  Parse,
  Row,
  Scheduler,
  SourceToXML,
  Success,
  Text,
  Tree,
  XMLtoMMLTree,
  converters,
  truncate
};
//# sourceMappingURL=mml-react.esm-7MXNI2VB.js.map
