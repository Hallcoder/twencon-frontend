import {
  require_typeof
} from "./chunk-3FFQX3XX.js";
import {
  __commonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime2() {
      "use strict";
      module.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
        return exports2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return generator._invoke = function(innerFn2, self3, context2) {
          var state = "suspendedStart";
          return function(method, arg) {
            if ("executing" === state)
              throw new Error("Generator is already running");
            if ("completed" === state) {
              if ("throw" === method)
                throw arg;
              return doneResult();
            }
            for (context2.method = method, context2.arg = arg; ; ) {
              var delegate = context2.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context2);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if ("next" === context2.method)
                context2.sent = context2._sent = context2.arg;
              else if ("throw" === context2.method) {
                if ("suspendedStart" === state)
                  throw state = "completed", context2.arg;
                context2.dispatchException(context2.arg);
              } else
                "return" === context2.method && context2.abrupt("return", context2.arg);
              state = "executing";
              var record = tryCatch(innerFn2, self3, context2);
              if ("normal" === record.type) {
                if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                  continue;
                return {
                  value: record.arg,
                  done: context2.done
                };
              }
              "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
            }
          };
        }(innerFn, self2, context), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        this._invoke = function(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (void 0 === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method))
              return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; ) {
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              }
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this) {
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
            }
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    module.exports = _regeneratorRuntime2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer2(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction2(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction2(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.22.0"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    module.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports, module) {
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/isomorphic-ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/isomorphic-ws/browser.js"(exports, module) {
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws;
  }
});

// node_modules/stream-chat/dist/browser.es.js
var import_base64_js = __toESM(require_base64_js());

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/stream-chat/dist/browser.es.js
var import_regenerator = __toESM(require_regenerator());
var import_axios = __toESM(require_axios2());

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

// node_modules/stream-chat/dist/browser.es.js
var import_form_data = __toESM(require_browser());
var import_isomorphic_ws = __toESM(require_browser2());

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}

// node_modules/stream-chat/dist/browser.es.js
function isString$1(arrayOrString) {
  return typeof arrayOrString === "string";
}
function isMapStringCallback(arrayOrString, callback) {
  return !!callback && isString$1(arrayOrString);
}
function map(arrayOrString, callback) {
  var res = [];
  if (isString$1(arrayOrString) && isMapStringCallback(arrayOrString, callback)) {
    for (var k = 0, len = arrayOrString.length; k < len; k++) {
      if (arrayOrString.charAt(k)) {
        var kValue = arrayOrString.charAt(k);
        var mappedValue = callback(kValue, k, arrayOrString);
        res[k] = mappedValue;
      }
    }
  } else if (!isString$1(arrayOrString) && !isMapStringCallback(arrayOrString, callback)) {
    for (var _k = 0, _len = arrayOrString.length; _k < _len; _k++) {
      if (_k in arrayOrString) {
        var _kValue = arrayOrString[_k];
        var _mappedValue = callback(_kValue, _k, arrayOrString);
        res[_k] = _mappedValue;
      }
    }
  }
  return res;
}
var encodeBase64 = function encodeBase642(data) {
  return (0, import_base64_js.fromByteArray)(new Uint8Array(map(data, function(char) {
    return char.charCodeAt(0);
  })));
};
var decodeBase64 = function decodeBase642(s) {
  var e = {}, w = String.fromCharCode, L = s.length;
  var i, b = 0, c, x, l = 0, a, r = "";
  var A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0; i < 64; i++) {
    e[A.charAt(i)] = i;
  }
  for (x = 0; x < L; x++) {
    c = e[s.charAt(x)];
    b = (b << 6) + c;
    l += 6;
    while (l >= 8) {
      ((a = b >>> (l -= 8) & 255) || x < L - 2) && (r += w(a));
    }
  }
  return r;
};
var https = null;
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var ChannelState = function() {
  function ChannelState2(channel) {
    var _this = this, _channel$state;
    _classCallCheck(this, ChannelState2);
    _defineProperty(this, "_channel", void 0);
    _defineProperty(this, "watcher_count", void 0);
    _defineProperty(this, "typing", void 0);
    _defineProperty(this, "read", void 0);
    _defineProperty(this, "pinnedMessages", void 0);
    _defineProperty(this, "pending_messages", void 0);
    _defineProperty(this, "threads", void 0);
    _defineProperty(this, "mutedUsers", void 0);
    _defineProperty(this, "watchers", void 0);
    _defineProperty(this, "members", void 0);
    _defineProperty(this, "unreadCount", void 0);
    _defineProperty(this, "membership", void 0);
    _defineProperty(this, "last_message_at", void 0);
    _defineProperty(this, "isUpToDate", void 0);
    _defineProperty(this, "messageSets", []);
    _defineProperty(this, "setIsUpToDate", function(isUpToDate) {
      _this.isUpToDate = isUpToDate;
    });
    _defineProperty(this, "removeMessageFromArray", function(msgArray, msg) {
      var result = msgArray.filter(function(message) {
        return !(!!message.id && !!msg.id && message.id === msg.id);
      });
      return {
        removed: result.length < msgArray.length,
        result
      };
    });
    _defineProperty(this, "updateUserMessages", function(user) {
      var _updateUserMessages = function _updateUserMessages2(messages, user2) {
        for (var i = 0; i < messages.length; i++) {
          var _m$user;
          var m = messages[i];
          if (((_m$user = m.user) === null || _m$user === void 0 ? void 0 : _m$user.id) === user2.id) {
            messages[i] = _objectSpread$7(_objectSpread$7({}, m), {}, {
              user: user2
            });
          }
        }
      };
      _this.messageSets.forEach(function(set) {
        return _updateUserMessages(set.messages, user);
      });
      for (var parentId in _this.threads) {
        _updateUserMessages(_this.threads[parentId], user);
      }
      _updateUserMessages(_this.pinnedMessages, user);
    });
    _defineProperty(this, "deleteUserMessages", function(user) {
      var hardDelete = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _deleteUserMessages = function _deleteUserMessages2(messages, user2) {
        var hardDelete2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        for (var i = 0; i < messages.length; i++) {
          var _m$user2;
          var m = messages[i];
          if (((_m$user2 = m.user) === null || _m$user2 === void 0 ? void 0 : _m$user2.id) !== user2.id) {
            continue;
          }
          if (hardDelete2) {
            messages[i] = {
              cid: m.cid,
              created_at: m.created_at,
              deleted_at: user2.deleted_at,
              id: m.id,
              latest_reactions: [],
              mentioned_users: [],
              own_reactions: [],
              parent_id: m.parent_id,
              reply_count: m.reply_count,
              status: m.status,
              thread_participants: m.thread_participants,
              type: "deleted",
              updated_at: m.updated_at,
              user: m.user
            };
          } else {
            messages[i] = _objectSpread$7(_objectSpread$7({}, m), {}, {
              type: "deleted",
              deleted_at: user2.deleted_at
            });
          }
        }
      };
      _this.messageSets.forEach(function(set) {
        return _deleteUserMessages(set.messages, user, hardDelete);
      });
      for (var parentId in _this.threads) {
        _deleteUserMessages(_this.threads[parentId], user, hardDelete);
      }
      _deleteUserMessages(_this.pinnedMessages, user, hardDelete);
    });
    this._channel = channel;
    this.watcher_count = 0;
    this.typing = {};
    this.read = {};
    this.initMessages();
    this.pinnedMessages = [];
    this.pending_messages = [];
    this.threads = {};
    this.mutedUsers = [];
    this.watchers = {};
    this.members = {};
    this.membership = {};
    this.unreadCount = 0;
    this.isUpToDate = true;
    this.last_message_at = (channel === null || channel === void 0 ? void 0 : (_channel$state = channel.state) === null || _channel$state === void 0 ? void 0 : _channel$state.last_message_at) != null ? new Date(channel.state.last_message_at) : null;
  }
  _createClass(ChannelState2, [{
    key: "messages",
    get: function get() {
      var _this$messageSets$fin;
      return ((_this$messageSets$fin = this.messageSets.find(function(s) {
        return s.isCurrent;
      })) === null || _this$messageSets$fin === void 0 ? void 0 : _this$messageSets$fin.messages) || [];
    },
    set: function set(messages) {
      var index = this.messageSets.findIndex(function(s) {
        return s.isCurrent;
      });
      this.messageSets[index].messages = messages;
    }
  }, {
    key: "latestMessages",
    get: function get() {
      var _this$messageSets$fin2;
      return ((_this$messageSets$fin2 = this.messageSets.find(function(s) {
        return s.isLatest;
      })) === null || _this$messageSets$fin2 === void 0 ? void 0 : _this$messageSets$fin2.messages) || [];
    },
    set: function set(messages) {
      var index = this.messageSets.findIndex(function(s) {
        return s.isLatest;
      });
      this.messageSets[index].messages = messages;
    }
  }, {
    key: "addMessageSorted",
    value: function addMessageSorted(newMessage) {
      var timestampChanged = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var addIfDoesNotExist = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var messageSetToAddToIfDoesNotExist = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
      return this.addMessagesSorted([newMessage], timestampChanged, false, addIfDoesNotExist, messageSetToAddToIfDoesNotExist);
    }
  }, {
    key: "formatMessage",
    value: function formatMessage(message) {
      return _objectSpread$7(_objectSpread$7({}, message), {}, {
        __html: message.html,
        pinned_at: message.pinned_at ? new Date(message.pinned_at) : null,
        created_at: message.created_at ? new Date(message.created_at) : new Date(),
        updated_at: message.updated_at ? new Date(message.updated_at) : new Date(),
        status: message.status || "received"
      });
    }
  }, {
    key: "addMessagesSorted",
    value: function addMessagesSorted(newMessages) {
      var timestampChanged = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var initializing = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var addIfDoesNotExist = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var messageSetToAddToIfDoesNotExist = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "current";
      var _this$findTargetMessa = this.findTargetMessageSet(newMessages, addIfDoesNotExist, messageSetToAddToIfDoesNotExist), messagesToAdd = _this$findTargetMessa.messagesToAdd, targetMessageSetIndex = _this$findTargetMessa.targetMessageSetIndex;
      for (var i = 0; i < messagesToAdd.length; i += 1) {
        var isFromShadowBannedUser = messagesToAdd[i].shadowed;
        if (isFromShadowBannedUser) {
          continue;
        }
        var isMessageFormatted = messagesToAdd[i].created_at instanceof Date;
        var message = void 0;
        if (isMessageFormatted) {
          message = messagesToAdd[i];
        } else {
          var _this$_channel;
          message = this.formatMessage(messagesToAdd[i]);
          if (message.user && (_this$_channel = this._channel) !== null && _this$_channel !== void 0 && _this$_channel.cid) {
            this._channel.getClient().state.updateUserReference(message.user, this._channel.cid);
          }
          if (initializing && message.id && this.threads[message.id]) {
            delete this.threads[message.id];
          }
          if (!this.last_message_at) {
            this.last_message_at = new Date(message.created_at.getTime());
          }
          if (message.created_at.getTime() > this.last_message_at.getTime()) {
            this.last_message_at = new Date(message.created_at.getTime());
          }
        }
        var parentID = message.parent_id;
        if ((!parentID || message.show_in_channel) && targetMessageSetIndex !== -1) {
          this.messageSets[targetMessageSetIndex].messages = this._addToMessageList(this.messageSets[targetMessageSetIndex].messages, message, timestampChanged, "created_at", addIfDoesNotExist);
        }
        if (parentID && !initializing) {
          var thread = this.threads[parentID] || [];
          var threadMessages = this._addToMessageList(thread, message, timestampChanged, "created_at", addIfDoesNotExist);
          this.threads[parentID] = threadMessages;
        }
      }
    }
  }, {
    key: "addPinnedMessages",
    value: function addPinnedMessages(pinnedMessages) {
      for (var i = 0; i < pinnedMessages.length; i += 1) {
        this.addPinnedMessage(pinnedMessages[i]);
      }
    }
  }, {
    key: "addPinnedMessage",
    value: function addPinnedMessage(pinnedMessage) {
      this.pinnedMessages = this._addToMessageList(this.pinnedMessages, this.formatMessage(pinnedMessage), false, "pinned_at");
    }
  }, {
    key: "removePinnedMessage",
    value: function removePinnedMessage(message) {
      var _this$removeMessageFr = this.removeMessageFromArray(this.pinnedMessages, message), result = _this$removeMessageFr.result;
      this.pinnedMessages = result;
    }
  }, {
    key: "addReaction",
    value: function addReaction(reaction, message, enforce_unique) {
      var _this2 = this;
      if (!message)
        return;
      var messageWithReaction = message;
      this._updateMessage(message, function(msg) {
        messageWithReaction.own_reactions = _this2._addOwnReactionToMessage(msg.own_reactions, reaction, enforce_unique);
        return _this2.formatMessage(messageWithReaction);
      });
      return messageWithReaction;
    }
  }, {
    key: "_addOwnReactionToMessage",
    value: function _addOwnReactionToMessage(ownReactions, reaction, enforce_unique) {
      if (enforce_unique) {
        ownReactions = [];
      } else {
        ownReactions = this._removeOwnReactionFromMessage(ownReactions, reaction);
      }
      ownReactions = ownReactions || [];
      if (this._channel.getClient().userID === reaction.user_id) {
        ownReactions.push(reaction);
      }
      return ownReactions;
    }
  }, {
    key: "_removeOwnReactionFromMessage",
    value: function _removeOwnReactionFromMessage(ownReactions, reaction) {
      if (ownReactions) {
        return ownReactions.filter(function(item) {
          return item.user_id !== reaction.user_id || item.type !== reaction.type;
        });
      }
      return ownReactions;
    }
  }, {
    key: "removeReaction",
    value: function removeReaction(reaction, message) {
      var _this3 = this;
      if (!message)
        return;
      var messageWithReaction = message;
      this._updateMessage(message, function(msg) {
        messageWithReaction.own_reactions = _this3._removeOwnReactionFromMessage(msg.own_reactions, reaction);
        return _this3.formatMessage(messageWithReaction);
      });
      return messageWithReaction;
    }
  }, {
    key: "removeQuotedMessageReferences",
    value: function removeQuotedMessageReferences(message) {
      var _this4 = this;
      var parseMessage = function parseMessage2(m) {
        var _m$pinned_at, _m$updated_at;
        return _objectSpread$7(_objectSpread$7({}, m), {}, {
          created_at: m.created_at.toString(),
          pinned_at: (_m$pinned_at = m.pinned_at) === null || _m$pinned_at === void 0 ? void 0 : _m$pinned_at.toString(),
          updated_at: (_m$updated_at = m.updated_at) === null || _m$updated_at === void 0 ? void 0 : _m$updated_at.toString()
        });
      };
      this.messageSets.forEach(function(set) {
        var updatedMessages = set.messages.filter(function(msg) {
          return msg.quoted_message_id === message.id;
        }).map(parseMessage).map(function(msg) {
          return _objectSpread$7(_objectSpread$7({}, msg), {}, {
            quoted_message: _objectSpread$7(_objectSpread$7({}, message), {}, {
              attachments: []
            })
          });
        });
        _this4.addMessagesSorted(updatedMessages, true);
      });
    }
  }, {
    key: "_updateMessage",
    value: function _updateMessage(message, updateFunc) {
      var parent_id = message.parent_id, show_in_channel = message.show_in_channel, pinned = message.pinned;
      if (parent_id && this.threads[parent_id]) {
        var thread = this.threads[parent_id];
        var msgIndex = thread.findIndex(function(msg) {
          return msg.id === message.id;
        });
        if (msgIndex !== -1) {
          thread[msgIndex] = updateFunc(thread[msgIndex]);
          this.threads[parent_id] = thread;
        }
      }
      if (!show_in_channel && !parent_id || show_in_channel) {
        var messageSetIndex = this.findMessageSetIndex(message);
        if (messageSetIndex !== -1) {
          var _msgIndex = this.messageSets[messageSetIndex].messages.findIndex(function(msg) {
            return msg.id === message.id;
          });
          if (_msgIndex !== -1) {
            this.messageSets[messageSetIndex].messages[_msgIndex] = updateFunc(this.messageSets[messageSetIndex].messages[_msgIndex]);
          }
        }
      }
      if (pinned) {
        var _msgIndex2 = this.pinnedMessages.findIndex(function(msg) {
          return msg.id === message.id;
        });
        if (_msgIndex2 !== -1) {
          this.pinnedMessages[_msgIndex2] = updateFunc(this.pinnedMessages[_msgIndex2]);
        }
      }
    }
  }, {
    key: "_addToMessageList",
    value: function _addToMessageList(messages, message) {
      var timestampChanged = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var sortBy = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "created_at";
      var addIfDoesNotExist = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      var addMessageToList = addIfDoesNotExist || timestampChanged;
      var messageArr = messages;
      if (timestampChanged) {
        messageArr = messageArr.filter(function(msg) {
          return !(msg.id && message.id === msg.id);
        });
      }
      var messageArrayLength = messageArr.length;
      if (messageArrayLength === 0 && addMessageToList) {
        return messageArr.concat(message);
      } else if (messageArrayLength === 0) {
        return _toConsumableArray(messageArr);
      }
      var messageTime = message[sortBy].getTime();
      var messageIsNewest = messageArr[messageArrayLength - 1][sortBy].getTime() < messageTime;
      if (messageIsNewest && addMessageToList) {
        return messageArr.concat(message);
      } else if (messageIsNewest) {
        return _toConsumableArray(messageArr);
      }
      var left = 0;
      var middle = 0;
      var right = messageArrayLength - 1;
      while (left <= right) {
        middle = Math.floor((right + left) / 2);
        if (messageArr[middle][sortBy].getTime() <= messageTime)
          left = middle + 1;
        else
          right = middle - 1;
      }
      if (!timestampChanged && message.id) {
        if (messageArr[left] && message.id === messageArr[left].id) {
          messageArr[left] = message;
          return _toConsumableArray(messageArr);
        }
        if (messageArr[left - 1] && message.id === messageArr[left - 1].id) {
          messageArr[left - 1] = message;
          return _toConsumableArray(messageArr);
        }
      }
      if (addMessageToList) {
        messageArr.splice(left, 0, message);
      }
      return _toConsumableArray(messageArr);
    }
  }, {
    key: "removeMessage",
    value: function removeMessage(messageToRemove) {
      var isRemoved = false;
      if (messageToRemove.parent_id && this.threads[messageToRemove.parent_id]) {
        var _this$removeMessageFr2 = this.removeMessageFromArray(this.threads[messageToRemove.parent_id], messageToRemove), removed = _this$removeMessageFr2.removed, threadMessages = _this$removeMessageFr2.result;
        this.threads[messageToRemove.parent_id] = threadMessages;
        isRemoved = removed;
      } else {
        var _messageToRemove$mess;
        var messageSetIndex = (_messageToRemove$mess = messageToRemove.messageSetIndex) !== null && _messageToRemove$mess !== void 0 ? _messageToRemove$mess : this.findMessageSetIndex(messageToRemove);
        if (messageSetIndex !== -1) {
          var _this$removeMessageFr3 = this.removeMessageFromArray(this.messageSets[messageSetIndex].messages, messageToRemove), _removed = _this$removeMessageFr3.removed, messages = _this$removeMessageFr3.result;
          this.messageSets[messageSetIndex].messages = messages;
          isRemoved = _removed;
        }
      }
      return isRemoved;
    }
  }, {
    key: "filterErrorMessages",
    value: function filterErrorMessages() {
      var filteredMessages = this.latestMessages.filter(function(message) {
        return message.type !== "error";
      });
      this.latestMessages = filteredMessages;
    }
  }, {
    key: "clean",
    value: function clean() {
      var now = new Date();
      for (var _i = 0, _Object$entries = Object.entries(this.typing); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), userID = _Object$entries$_i[0], lastEvent = _Object$entries$_i[1];
        var receivedAt = typeof lastEvent.received_at === "string" ? new Date(lastEvent.received_at) : lastEvent.received_at || new Date();
        if (now.getTime() - receivedAt.getTime() > 7e3) {
          delete this.typing[userID];
          this._channel.getClient().dispatchEvent({
            cid: this._channel.cid,
            type: "typing.stop",
            user: {
              id: userID
            }
          });
        }
      }
    }
  }, {
    key: "clearMessages",
    value: function clearMessages() {
      this.initMessages();
      this.pinnedMessages = [];
    }
  }, {
    key: "initMessages",
    value: function initMessages() {
      this.messageSets = [{
        messages: [],
        isLatest: true,
        isCurrent: true
      }];
    }
  }, {
    key: "loadMessageIntoState",
    value: function() {
      var _loadMessageIntoState = _asyncToGenerator(import_regenerator.default.mark(function _callee(messageId, parentMessageId) {
        var _this$threads$parentM;
        var limit, messageSetIndex, switchedToMessageSet, loadedMessageThread, messageIdToFind, _args = arguments;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                limit = _args.length > 2 && _args[2] !== void 0 ? _args[2] : 25;
                switchedToMessageSet = false;
                loadedMessageThread = false;
                messageIdToFind = parentMessageId || messageId;
                if (!(messageId === "latest")) {
                  _context.next = 10;
                  break;
                }
                if (!(this.messages === this.latestMessages)) {
                  _context.next = 7;
                  break;
                }
                return _context.abrupt("return");
              case 7:
                messageSetIndex = this.messageSets.findIndex(function(s) {
                  return s.isLatest;
                });
                _context.next = 11;
                break;
              case 10:
                messageSetIndex = this.findMessageSetIndex({
                  id: messageIdToFind
                });
              case 11:
                if (messageSetIndex !== -1) {
                  this.switchToMessageSet(messageSetIndex);
                  switchedToMessageSet = true;
                }
                loadedMessageThread = !parentMessageId || !!((_this$threads$parentM = this.threads[parentMessageId]) !== null && _this$threads$parentM !== void 0 && _this$threads$parentM.find(function(m) {
                  return m.id === messageId;
                }));
                if (!(switchedToMessageSet && loadedMessageThread)) {
                  _context.next = 15;
                  break;
                }
                return _context.abrupt("return");
              case 15:
                if (switchedToMessageSet) {
                  _context.next = 18;
                  break;
                }
                _context.next = 18;
                return this._channel.query({
                  messages: {
                    id_around: messageIdToFind,
                    limit
                  }
                }, "new");
              case 18:
                if (!(!loadedMessageThread && parentMessageId)) {
                  _context.next = 21;
                  break;
                }
                _context.next = 21;
                return this._channel.getReplies(parentMessageId, {
                  id_around: messageId,
                  limit
                });
              case 21:
                messageSetIndex = this.findMessageSetIndex({
                  id: messageIdToFind
                });
                if (messageSetIndex !== -1) {
                  this.switchToMessageSet(messageSetIndex);
                }
              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function loadMessageIntoState(_x, _x2) {
        return _loadMessageIntoState.apply(this, arguments);
      }
      return loadMessageIntoState;
    }()
  }, {
    key: "findMessage",
    value: function findMessage(messageId, parentMessageId) {
      if (parentMessageId) {
        var messages = this.threads[parentMessageId];
        if (!messages) {
          return void 0;
        }
        return messages.find(function(m) {
          return m.id === messageId;
        });
      }
      var messageSetIndex = this.findMessageSetIndex({
        id: messageId
      });
      if (messageSetIndex === -1) {
        return void 0;
      }
      return this.messageSets[messageSetIndex].messages.find(function(m) {
        return m.id === messageId;
      });
    }
  }, {
    key: "switchToMessageSet",
    value: function switchToMessageSet(index) {
      var currentMessages = this.messageSets.find(function(s) {
        return s.isCurrent;
      });
      if (!currentMessages) {
        return;
      }
      currentMessages.isCurrent = false;
      this.messageSets[index].isCurrent = true;
    }
  }, {
    key: "areMessageSetsOverlap",
    value: function areMessageSetsOverlap(messages1, messages2) {
      return messages1.some(function(m1) {
        return messages2.find(function(m2) {
          return m1.id === m2.id;
        });
      });
    }
  }, {
    key: "findMessageSetIndex",
    value: function findMessageSetIndex(message) {
      return this.messageSets.findIndex(function(set) {
        return !!set.messages.find(function(m) {
          return m.id === message.id;
        });
      });
    }
  }, {
    key: "findTargetMessageSet",
    value: function findTargetMessageSet(newMessages) {
      var _this5 = this;
      var addIfDoesNotExist = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var messageSetToAddToIfDoesNotExist = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "current";
      var messagesToAdd = newMessages;
      var targetMessageSetIndex;
      if (addIfDoesNotExist) {
        var overlappingMessageSetIndices = this.messageSets.map(function(_, i) {
          return i;
        }).filter(function(i) {
          return _this5.areMessageSetsOverlap(_this5.messageSets[i].messages, newMessages);
        });
        switch (messageSetToAddToIfDoesNotExist) {
          case "new":
            if (overlappingMessageSetIndices.length > 0) {
              targetMessageSetIndex = overlappingMessageSetIndices[0];
            } else if (newMessages.some(function(m) {
              return !m.parent_id;
            })) {
              this.messageSets.push({
                messages: [],
                isCurrent: false,
                isLatest: false
              });
              targetMessageSetIndex = this.messageSets.length - 1;
            }
            break;
          case "current":
            targetMessageSetIndex = this.messageSets.findIndex(function(s) {
              return s.isCurrent;
            });
            break;
          case "latest":
            targetMessageSetIndex = this.messageSets.findIndex(function(s) {
              return s.isLatest;
            });
            break;
          default:
            targetMessageSetIndex = -1;
        }
        var mergeTargetMessageSetIndex = overlappingMessageSetIndices.splice(0, 1)[0];
        var mergeSourceMessageSetIndices = _toConsumableArray(overlappingMessageSetIndices);
        if (mergeTargetMessageSetIndex !== void 0 && mergeTargetMessageSetIndex !== targetMessageSetIndex) {
          mergeSourceMessageSetIndices.push(targetMessageSetIndex);
        }
        if (mergeSourceMessageSetIndices.length > 0) {
          var target = this.messageSets[mergeTargetMessageSetIndex];
          var sources = this.messageSets.filter(function(_, i) {
            return mergeSourceMessageSetIndices.indexOf(i) !== -1;
          });
          sources.forEach(function(messageSet) {
            target.isLatest = target.isLatest || messageSet.isLatest;
            target.isCurrent = target.isCurrent || messageSet.isCurrent;
            messagesToAdd = [].concat(_toConsumableArray(messagesToAdd), _toConsumableArray(messageSet.messages));
          });
          sources.forEach(function(s) {
            return _this5.messageSets.splice(_this5.messageSets.indexOf(s), 1);
          });
          var overlappingMessageSetIndex = this.messageSets.findIndex(function(s) {
            return _this5.areMessageSetsOverlap(s.messages, newMessages);
          });
          targetMessageSetIndex = overlappingMessageSetIndex;
        }
      } else {
        targetMessageSetIndex = this.findMessageSetIndex(newMessages[0]);
      }
      return {
        targetMessageSetIndex,
        messagesToAdd
      };
    }
  }]);
  return ChannelState2;
}();
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var EVENT_MAP = {
  "channel.created": true,
  "channel.deleted": true,
  "channel.hidden": true,
  "channel.kicked": true,
  "channel.muted": true,
  "channel.truncated": true,
  "channel.unmuted": true,
  "channel.updated": true,
  "channel.visible": true,
  "health.check": true,
  "member.added": true,
  "member.removed": true,
  "member.updated": true,
  "message.deleted": true,
  "message.new": true,
  "message.read": true,
  "message.updated": true,
  "notification.added_to_channel": true,
  "notification.channel_deleted": true,
  "notification.channel_mutes_updated": true,
  "notification.channel_truncated": true,
  "notification.invite_accepted": true,
  "notification.invite_rejected": true,
  "notification.invited": true,
  "notification.mark_read": true,
  "notification.message_new": true,
  "notification.mutes_updated": true,
  "notification.removed_from_channel": true,
  "reaction.deleted": true,
  "reaction.new": true,
  "reaction.updated": true,
  "typing.start": true,
  "typing.stop": true,
  "user.banned": true,
  "user.deleted": true,
  "user.presence.changed": true,
  "user.unbanned": true,
  "user.unread_message_reminder": true,
  "user.updated": true,
  "user.watching.start": true,
  "user.watching.stop": true,
  "connection.changed": true,
  "connection.recovered": true,
  "transport.changed": true
};
var IS_VALID_EVENT_MAP_TYPE = _objectSpread$6(_objectSpread$6({}, EVENT_MAP), {}, {
  all: true
});
var isValidEventType = function isValidEventType2(eventType) {
  return IS_VALID_EVENT_MAP_TYPE[eventType] || false;
};
function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function(_e) {
        function e(_x) {
          return _e.apply(this, arguments);
        }
        e.toString = function() {
          return _e.toString();
        };
        return e;
      }(function(e) {
        throw e;
      }), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function(_e2) {
    function e(_x2) {
      return _e2.apply(this, arguments);
    }
    e.toString = function() {
      return _e2.toString();
    };
    return e;
  }(function(e) {
    didErr = true;
    err = e;
  }), f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function logChatPromiseExecution(promise, name) {
  promise.then().catch(function(error) {
    console.warn("failed to do ".concat(name, ", ran into error: "), error);
  });
}
var sleep = function sleep2(m) {
  return new Promise(function(r) {
    return setTimeout(r, m);
  });
};
function isFunction(value) {
  return value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);
}
var chatCodes = {
  TOKEN_EXPIRED: 40,
  WS_CLOSED_SUCCESS: 1e3
};
function isReadableStream(obj) {
  return obj !== null && _typeof(obj) === "object" && (obj.readable || typeof obj._read === "function");
}
function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isFileWebAPI(uri) {
  return typeof window !== "undefined" && "File" in window && uri instanceof File;
}
function isOwnUser(user) {
  return (user === null || user === void 0 ? void 0 : user.total_unread_count) !== void 0;
}
function isBlobWebAPI(uri) {
  return typeof window !== "undefined" && "Blob" in window && uri instanceof Blob;
}
function isOwnUserBaseProperty(property) {
  var ownUserBaseProperties = {
    channel_mutes: true,
    devices: true,
    mutes: true,
    total_unread_count: true,
    unread_channels: true,
    unread_count: true,
    invisible: true,
    roles: true
  };
  return ownUserBaseProperties[property];
}
function addFileToFormData(uri, name, contentType) {
  var data = new import_form_data.default();
  if (isReadableStream(uri) || isBuffer(uri) || isFileWebAPI(uri) || isBlobWebAPI(uri)) {
    if (name)
      data.append("file", uri, name);
    else
      data.append("file", uri);
  } else {
    data.append("file", {
      uri,
      name: name || uri.split("/").reverse()[0],
      contentType: contentType || void 0,
      type: contentType || void 0
    });
  }
  return data;
}
function normalizeQuerySort(sort) {
  var sortFields = [];
  var sortArr = Array.isArray(sort) ? sort : [sort];
  var _iterator = _createForOfIteratorHelper$3(sortArr), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var item = _step.value;
      var entries = Object.entries(item);
      if (entries.length > 1) {
        console.warn("client._buildSort() - multiple fields in a single sort object detected. Object's field order is not guaranteed");
      }
      for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
        var _entries$_i = _slicedToArray(_entries[_i], 2), field = _entries$_i[0], direction = _entries$_i[1];
        sortFields.push({
          field,
          direction
        });
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return sortFields;
}
function retryInterval(numberOfFailures) {
  var max = Math.min(500 + numberOfFailures * 2e3, 25e3);
  var min = Math.min(Math.max(250, (numberOfFailures - 1) * 2e3), 25e3);
  return Math.floor(Math.random() * (max - min) + min);
}
function randomId() {
  return generateUUIDv4();
}
function hex(bytes) {
  var s = "";
  for (var i = 0; i < bytes.length; i++) {
    s += bytes[i].toString(16).padStart(2, "0");
  }
  return s;
}
function generateUUIDv4() {
  var bytes = getRandomBytes(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 191 | 128;
  return hex(bytes.subarray(0, 4)) + "-" + hex(bytes.subarray(4, 6)) + "-" + hex(bytes.subarray(6, 8)) + "-" + hex(bytes.subarray(8, 10)) + "-" + hex(bytes.subarray(10, 16));
}
function getRandomValuesWithMathRandom(bytes) {
  var max = Math.pow(2, 8 * bytes.byteLength / bytes.length);
  for (var i = 0; i < bytes.length; i++) {
    bytes[i] = Math.random() * max;
  }
}
var getRandomValues = function() {
  if (typeof crypto !== "undefined") {
    return crypto.getRandomValues.bind(crypto);
  } else if (typeof msCrypto !== "undefined") {
    return msCrypto.getRandomValues.bind(msCrypto);
  } else {
    return getRandomValuesWithMathRandom;
  }
}();
function getRandomBytes(length) {
  var bytes = new Uint8Array(length);
  getRandomValues(bytes);
  return bytes;
}
function convertErrorToJson(err) {
  var jsonObj = {};
  if (!err)
    return jsonObj;
  try {
    Object.getOwnPropertyNames(err).forEach(function(key) {
      jsonObj[key] = Object.getOwnPropertyDescriptor(err, key);
    });
  } catch (_) {
    return {
      error: "failed to serialize the error"
    };
  }
  return jsonObj;
}
function isOnline() {
  var nav = typeof navigator !== "undefined" ? navigator : typeof window !== "undefined" && window.navigator ? window.navigator : void 0;
  if (!nav) {
    console.warn("isOnline failed to access window.navigator and assume browser is online");
    return true;
  }
  if (typeof nav.onLine !== "boolean") {
    return true;
  }
  return nav.onLine;
}
function addConnectionEventListeners(cb) {
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("offline", cb);
    window.addEventListener("online", cb);
  }
}
function removeConnectionEventListeners(cb) {
  if (typeof window !== "undefined" && window.removeEventListener) {
    window.removeEventListener("offline", cb);
    window.removeEventListener("online", cb);
  }
}
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Channel = function() {
  function Channel2(client, type, id, data) {
    var _this = this;
    _classCallCheck(this, Channel2);
    _defineProperty(this, "_client", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "_data", void 0);
    _defineProperty(this, "cid", void 0);
    _defineProperty(this, "listeners", void 0);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "initialized", void 0);
    _defineProperty(this, "lastKeyStroke", void 0);
    _defineProperty(this, "lastTypingEvent", void 0);
    _defineProperty(this, "isTyping", void 0);
    _defineProperty(this, "disconnected", void 0);
    _defineProperty(this, "create", _asyncToGenerator(import_regenerator.default.mark(function _callee() {
      var options;
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = {
                watch: false,
                state: false,
                presence: false
              };
              _context.next = 3;
              return _this.query(options, "latest");
            case 3:
              return _context.abrupt("return", _context.sent);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    _defineProperty(this, "_callChannelListeners", function(event) {
      var channel = _this;
      var listeners = [];
      if (channel.listeners.all) {
        listeners.push.apply(listeners, _toConsumableArray(channel.listeners.all));
      }
      if (channel.listeners[event.type]) {
        listeners.push.apply(listeners, _toConsumableArray(channel.listeners[event.type]));
      }
      for (var _i = 0, _listeners = listeners; _i < _listeners.length; _i++) {
        var listener = _listeners[_i];
        if (typeof listener !== "string") {
          listener(event);
        }
      }
    });
    _defineProperty(this, "_channelURL", function() {
      if (!_this.id) {
        throw new Error("channel id is not defined");
      }
      return "".concat(_this.getClient().baseURL, "/channels/").concat(_this.type, "/").concat(_this.id);
    });
    var validTypeRe = /^[\w_-]+$/;
    var validIDRe = /^[\w!_-]+$/;
    if (!validTypeRe.test(type)) {
      throw new Error("Invalid chat type ".concat(type, ', letters, numbers and "_-" are allowed'));
    }
    if (typeof id === "string" && !validIDRe.test(id)) {
      throw new Error("Invalid chat id ".concat(id, ', letters, numbers and "!-_" are allowed'));
    }
    this._client = client;
    this.type = type;
    this.id = id;
    this.data = data;
    this._data = _objectSpread$5({}, data);
    this.cid = "".concat(type, ":").concat(id);
    this.listeners = {};
    this.state = new ChannelState(this);
    this.initialized = false;
    this.lastTypingEvent = null;
    this.isTyping = false;
    this.disconnected = false;
  }
  _createClass(Channel2, [{
    key: "getClient",
    value: function getClient() {
      if (this.disconnected === true) {
        throw Error("You can't use a channel after client.disconnect() was called");
      }
      return this._client;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var client = this.getClient();
      return client.configs[this.type];
    }
  }, {
    key: "sendMessage",
    value: function() {
      var _sendMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee2(message, options) {
        var sendMessageResponse;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getClient().post(this._channelURL() + "/message", _objectSpread$5({
                  message
                }, options));
              case 2:
                sendMessageResponse = _context2.sent;
                this.state.unreadCount = 0;
                return _context2.abrupt("return", sendMessageResponse);
              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function sendMessage(_x, _x2) {
        return _sendMessage.apply(this, arguments);
      }
      return sendMessage;
    }()
  }, {
    key: "sendFile",
    value: function sendFile(uri, name, contentType, user) {
      return this.getClient().sendFile("".concat(this._channelURL(), "/file"), uri, name, contentType, user);
    }
  }, {
    key: "sendImage",
    value: function sendImage(uri, name, contentType, user) {
      return this.getClient().sendFile("".concat(this._channelURL(), "/image"), uri, name, contentType, user);
    }
  }, {
    key: "deleteFile",
    value: function deleteFile(url) {
      return this.getClient().delete("".concat(this._channelURL(), "/file"), {
        url
      });
    }
  }, {
    key: "deleteImage",
    value: function deleteImage(url) {
      return this.getClient().delete("".concat(this._channelURL(), "/image"), {
        url
      });
    }
  }, {
    key: "sendEvent",
    value: function() {
      var _sendEvent = _asyncToGenerator(import_regenerator.default.mark(function _callee3(event) {
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._checkInitialized();
                _context3.next = 3;
                return this.getClient().post(this._channelURL() + "/event", {
                  event
                });
              case 3:
                return _context3.abrupt("return", _context3.sent);
              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function sendEvent(_x3) {
        return _sendEvent.apply(this, arguments);
      }
      return sendEvent;
    }()
  }, {
    key: "search",
    value: function() {
      var _search = _asyncToGenerator(import_regenerator.default.mark(function _callee4(query) {
        var options, payload, _args4 = arguments;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 1 && _args4[1] !== void 0 ? _args4[1] : {};
                if (!(options.offset && (options.sort || options.next))) {
                  _context4.next = 3;
                  break;
                }
                throw Error("Cannot specify offset with sort or next parameters");
              case 3:
                payload = _objectSpread$5(_objectSpread$5({
                  filter_conditions: {
                    cid: this.cid
                  }
                }, options), {}, {
                  sort: options.sort ? normalizeQuerySort(options.sort) : void 0
                });
                if (!(typeof query === "string")) {
                  _context4.next = 8;
                  break;
                }
                payload.query = query;
                _context4.next = 13;
                break;
              case 8:
                if (!(_typeof(query) === "object")) {
                  _context4.next = 12;
                  break;
                }
                payload.message_filter_conditions = query;
                _context4.next = 13;
                break;
              case 12:
                throw Error("Invalid type ".concat(_typeof(query), " for query parameter"));
              case 13:
                _context4.next = 15;
                return this.getClient().wsPromise;
              case 15:
                _context4.next = 17;
                return this.getClient().get(this.getClient().baseURL + "/search", {
                  payload
                });
              case 17:
                return _context4.abrupt("return", _context4.sent);
              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
      function search(_x4) {
        return _search.apply(this, arguments);
      }
      return search;
    }()
  }, {
    key: "queryMembers",
    value: function() {
      var _queryMembers = _asyncToGenerator(import_regenerator.default.mark(function _callee5(filterConditions) {
        var _this$data;
        var sort, options, id, type, members, _args5 = arguments;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                sort = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : [];
                options = _args5.length > 2 && _args5[2] !== void 0 ? _args5[2] : {};
                type = this.type;
                if (this.id) {
                  id = this.id;
                } else if ((_this$data = this.data) !== null && _this$data !== void 0 && _this$data.members && Array.isArray(this.data.members)) {
                  members = this.data.members;
                }
                _context5.next = 6;
                return this.getClient().get(this.getClient().baseURL + "/members", {
                  payload: _objectSpread$5({
                    type,
                    id,
                    members,
                    sort: normalizeQuerySort(sort),
                    filter_conditions: filterConditions
                  }, options)
                });
              case 6:
                return _context5.abrupt("return", _context5.sent);
              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function queryMembers(_x5) {
        return _queryMembers.apply(this, arguments);
      }
      return queryMembers;
    }()
  }, {
    key: "sendReaction",
    value: function() {
      var _sendReaction = _asyncToGenerator(import_regenerator.default.mark(function _callee6(messageID, reaction, options) {
        return import_regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (messageID) {
                  _context6.next = 2;
                  break;
                }
                throw Error("Message id is missing");
              case 2:
                if (!(!reaction || Object.keys(reaction).length === 0)) {
                  _context6.next = 4;
                  break;
                }
                throw Error("Reaction object is missing");
              case 4:
                _context6.next = 6;
                return this.getClient().post(this.getClient().baseURL + "/messages/".concat(messageID, "/reaction"), _objectSpread$5({
                  reaction
                }, options));
              case 6:
                return _context6.abrupt("return", _context6.sent);
              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function sendReaction(_x6, _x7, _x8) {
        return _sendReaction.apply(this, arguments);
      }
      return sendReaction;
    }()
  }, {
    key: "deleteReaction",
    value: function deleteReaction(messageID, reactionType, user_id) {
      this._checkInitialized();
      if (!reactionType || !messageID) {
        throw Error("Deleting a reaction requires specifying both the message and reaction type");
      }
      var url = this.getClient().baseURL + "/messages/".concat(messageID, "/reaction/").concat(reactionType);
      if (user_id) {
        return this.getClient().delete(url, {
          user_id
        });
      }
      return this.getClient().delete(url, {});
    }
  }, {
    key: "update",
    value: function() {
      var _update2 = _asyncToGenerator(import_regenerator.default.mark(function _callee7() {
        var channelData, updateMessage, options, reserved, _args7 = arguments;
        return import_regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                channelData = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {};
                updateMessage = _args7.length > 1 ? _args7[1] : void 0;
                options = _args7.length > 2 ? _args7[2] : void 0;
                reserved = ["config", "cid", "created_by", "id", "member_count", "type", "created_at", "updated_at", "last_message_at", "own_capabilities"];
                reserved.forEach(function(key) {
                  delete channelData[key];
                });
                _context7.next = 7;
                return this._update(_objectSpread$5({
                  message: updateMessage,
                  data: channelData
                }, options));
              case 7:
                return _context7.abrupt("return", _context7.sent);
              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
      function update() {
        return _update2.apply(this, arguments);
      }
      return update;
    }()
  }, {
    key: "updatePartial",
    value: function() {
      var _updatePartial = _asyncToGenerator(import_regenerator.default.mark(function _callee8(update) {
        var data;
        return import_regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getClient().patch(this._channelURL(), update);
              case 2:
                data = _context8.sent;
                this.data = data.channel;
                return _context8.abrupt("return", data);
              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function updatePartial(_x9) {
        return _updatePartial.apply(this, arguments);
      }
      return updatePartial;
    }()
  }, {
    key: "enableSlowMode",
    value: function() {
      var _enableSlowMode = _asyncToGenerator(import_regenerator.default.mark(function _callee9(coolDownInterval) {
        var data;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getClient().post(this._channelURL(), {
                  cooldown: coolDownInterval
                });
              case 2:
                data = _context9.sent;
                this.data = data.channel;
                return _context9.abrupt("return", data);
              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));
      function enableSlowMode(_x10) {
        return _enableSlowMode.apply(this, arguments);
      }
      return enableSlowMode;
    }()
  }, {
    key: "disableSlowMode",
    value: function() {
      var _disableSlowMode = _asyncToGenerator(import_regenerator.default.mark(function _callee10() {
        var data;
        return import_regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getClient().post(this._channelURL(), {
                  cooldown: 0
                });
              case 2:
                data = _context10.sent;
                this.data = data.channel;
                return _context10.abrupt("return", data);
              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));
      function disableSlowMode() {
        return _disableSlowMode.apply(this, arguments);
      }
      return disableSlowMode;
    }()
  }, {
    key: "delete",
    value: function() {
      var _delete2 = _asyncToGenerator(import_regenerator.default.mark(function _callee11() {
        var options, _args11 = arguments;
        return import_regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                options = _args11.length > 0 && _args11[0] !== void 0 ? _args11[0] : {};
                _context11.next = 3;
                return this.getClient().delete(this._channelURL(), _objectSpread$5({}, options));
              case 3:
                return _context11.abrupt("return", _context11.sent);
              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));
      function _delete() {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
  }, {
    key: "truncate",
    value: function() {
      var _truncate = _asyncToGenerator(import_regenerator.default.mark(function _callee12() {
        var options, _args12 = arguments;
        return import_regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                options = _args12.length > 0 && _args12[0] !== void 0 ? _args12[0] : {};
                _context12.next = 3;
                return this.getClient().post(this._channelURL() + "/truncate", options);
              case 3:
                return _context12.abrupt("return", _context12.sent);
              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));
      function truncate() {
        return _truncate.apply(this, arguments);
      }
      return truncate;
    }()
  }, {
    key: "acceptInvite",
    value: function() {
      var _acceptInvite = _asyncToGenerator(import_regenerator.default.mark(function _callee13() {
        var options, _args13 = arguments;
        return import_regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                options = _args13.length > 0 && _args13[0] !== void 0 ? _args13[0] : {};
                _context13.next = 3;
                return this._update(_objectSpread$5({
                  accept_invite: true
                }, options));
              case 3:
                return _context13.abrupt("return", _context13.sent);
              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));
      function acceptInvite() {
        return _acceptInvite.apply(this, arguments);
      }
      return acceptInvite;
    }()
  }, {
    key: "rejectInvite",
    value: function() {
      var _rejectInvite = _asyncToGenerator(import_regenerator.default.mark(function _callee14() {
        var options, _args14 = arguments;
        return import_regenerator.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                options = _args14.length > 0 && _args14[0] !== void 0 ? _args14[0] : {};
                _context14.next = 3;
                return this._update(_objectSpread$5({
                  reject_invite: true
                }, options));
              case 3:
                return _context14.abrupt("return", _context14.sent);
              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));
      function rejectInvite() {
        return _rejectInvite.apply(this, arguments);
      }
      return rejectInvite;
    }()
  }, {
    key: "addMembers",
    value: function() {
      var _addMembers = _asyncToGenerator(import_regenerator.default.mark(function _callee15(members, message) {
        var options, _args15 = arguments;
        return import_regenerator.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                options = _args15.length > 2 && _args15[2] !== void 0 ? _args15[2] : {};
                _context15.next = 3;
                return this._update(_objectSpread$5({
                  add_members: members,
                  message
                }, options));
              case 3:
                return _context15.abrupt("return", _context15.sent);
              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));
      function addMembers(_x11, _x12) {
        return _addMembers.apply(this, arguments);
      }
      return addMembers;
    }()
  }, {
    key: "addModerators",
    value: function() {
      var _addModerators = _asyncToGenerator(import_regenerator.default.mark(function _callee16(members, message) {
        var options, _args16 = arguments;
        return import_regenerator.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                options = _args16.length > 2 && _args16[2] !== void 0 ? _args16[2] : {};
                _context16.next = 3;
                return this._update(_objectSpread$5({
                  add_moderators: members,
                  message
                }, options));
              case 3:
                return _context16.abrupt("return", _context16.sent);
              case 4:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));
      function addModerators(_x13, _x14) {
        return _addModerators.apply(this, arguments);
      }
      return addModerators;
    }()
  }, {
    key: "assignRoles",
    value: function() {
      var _assignRoles = _asyncToGenerator(import_regenerator.default.mark(function _callee17(roles, message) {
        var options, _args17 = arguments;
        return import_regenerator.default.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                options = _args17.length > 2 && _args17[2] !== void 0 ? _args17[2] : {};
                _context17.next = 3;
                return this._update(_objectSpread$5({
                  assign_roles: roles,
                  message
                }, options));
              case 3:
                return _context17.abrupt("return", _context17.sent);
              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));
      function assignRoles(_x15, _x16) {
        return _assignRoles.apply(this, arguments);
      }
      return assignRoles;
    }()
  }, {
    key: "inviteMembers",
    value: function() {
      var _inviteMembers = _asyncToGenerator(import_regenerator.default.mark(function _callee18(members, message) {
        var options, _args18 = arguments;
        return import_regenerator.default.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                options = _args18.length > 2 && _args18[2] !== void 0 ? _args18[2] : {};
                _context18.next = 3;
                return this._update(_objectSpread$5({
                  invites: members,
                  message
                }, options));
              case 3:
                return _context18.abrupt("return", _context18.sent);
              case 4:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));
      function inviteMembers(_x17, _x18) {
        return _inviteMembers.apply(this, arguments);
      }
      return inviteMembers;
    }()
  }, {
    key: "removeMembers",
    value: function() {
      var _removeMembers = _asyncToGenerator(import_regenerator.default.mark(function _callee19(members, message) {
        var options, _args19 = arguments;
        return import_regenerator.default.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                options = _args19.length > 2 && _args19[2] !== void 0 ? _args19[2] : {};
                _context19.next = 3;
                return this._update(_objectSpread$5({
                  remove_members: members,
                  message
                }, options));
              case 3:
                return _context19.abrupt("return", _context19.sent);
              case 4:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));
      function removeMembers(_x19, _x20) {
        return _removeMembers.apply(this, arguments);
      }
      return removeMembers;
    }()
  }, {
    key: "demoteModerators",
    value: function() {
      var _demoteModerators = _asyncToGenerator(import_regenerator.default.mark(function _callee20(members, message) {
        var options, _args20 = arguments;
        return import_regenerator.default.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                options = _args20.length > 2 && _args20[2] !== void 0 ? _args20[2] : {};
                _context20.next = 3;
                return this._update(_objectSpread$5({
                  demote_moderators: members,
                  message
                }, options));
              case 3:
                return _context20.abrupt("return", _context20.sent);
              case 4:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));
      function demoteModerators(_x21, _x22) {
        return _demoteModerators.apply(this, arguments);
      }
      return demoteModerators;
    }()
  }, {
    key: "_update",
    value: function() {
      var _update3 = _asyncToGenerator(import_regenerator.default.mark(function _callee21(payload) {
        var data;
        return import_regenerator.default.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.getClient().post(this._channelURL(), payload);
              case 2:
                data = _context21.sent;
                this.data = data.channel;
                return _context21.abrupt("return", data);
              case 5:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));
      function _update(_x23) {
        return _update3.apply(this, arguments);
      }
      return _update;
    }()
  }, {
    key: "mute",
    value: function() {
      var _mute = _asyncToGenerator(import_regenerator.default.mark(function _callee22() {
        var opts, _args22 = arguments;
        return import_regenerator.default.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                opts = _args22.length > 0 && _args22[0] !== void 0 ? _args22[0] : {};
                _context22.next = 3;
                return this.getClient().post(this.getClient().baseURL + "/moderation/mute/channel", _objectSpread$5({
                  channel_cid: this.cid
                }, opts));
              case 3:
                return _context22.abrupt("return", _context22.sent);
              case 4:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));
      function mute() {
        return _mute.apply(this, arguments);
      }
      return mute;
    }()
  }, {
    key: "unmute",
    value: function() {
      var _unmute = _asyncToGenerator(import_regenerator.default.mark(function _callee23() {
        var opts, _args23 = arguments;
        return import_regenerator.default.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                opts = _args23.length > 0 && _args23[0] !== void 0 ? _args23[0] : {};
                _context23.next = 3;
                return this.getClient().post(this.getClient().baseURL + "/moderation/unmute/channel", _objectSpread$5({
                  channel_cid: this.cid
                }, opts));
              case 3:
                return _context23.abrupt("return", _context23.sent);
              case 4:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));
      function unmute() {
        return _unmute.apply(this, arguments);
      }
      return unmute;
    }()
  }, {
    key: "muteStatus",
    value: function muteStatus() {
      this._checkInitialized();
      return this.getClient()._muteStatus(this.cid);
    }
  }, {
    key: "sendAction",
    value: function sendAction(messageID, formData) {
      this._checkInitialized();
      if (!messageID) {
        throw Error("Message id is missing");
      }
      return this.getClient().post(this.getClient().baseURL + "/messages/".concat(messageID, "/action"), {
        message_id: messageID,
        form_data: formData,
        id: this.id,
        type: this.type
      });
    }
  }, {
    key: "keystroke",
    value: function() {
      var _keystroke = _asyncToGenerator(import_regenerator.default.mark(function _callee24(parent_id) {
        var _this$getConfig;
        var now, diff;
        return import_regenerator.default.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                if ((_this$getConfig = this.getConfig()) !== null && _this$getConfig !== void 0 && _this$getConfig.typing_events) {
                  _context24.next = 2;
                  break;
                }
                return _context24.abrupt("return");
              case 2:
                now = new Date();
                diff = this.lastTypingEvent && now.getTime() - this.lastTypingEvent.getTime();
                this.lastKeyStroke = now;
                this.isTyping = true;
                if (!(diff === null || diff > 2e3)) {
                  _context24.next = 10;
                  break;
                }
                this.lastTypingEvent = new Date();
                _context24.next = 10;
                return this.sendEvent({
                  type: "typing.start",
                  parent_id
                });
              case 10:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));
      function keystroke(_x24) {
        return _keystroke.apply(this, arguments);
      }
      return keystroke;
    }()
  }, {
    key: "stopTyping",
    value: function() {
      var _stopTyping = _asyncToGenerator(import_regenerator.default.mark(function _callee25(parent_id) {
        var _this$getConfig2;
        return import_regenerator.default.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if ((_this$getConfig2 = this.getConfig()) !== null && _this$getConfig2 !== void 0 && _this$getConfig2.typing_events) {
                  _context25.next = 2;
                  break;
                }
                return _context25.abrupt("return");
              case 2:
                this.lastTypingEvent = null;
                this.isTyping = false;
                _context25.next = 6;
                return this.sendEvent({
                  type: "typing.stop",
                  parent_id
                });
              case 6:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));
      function stopTyping(_x25) {
        return _stopTyping.apply(this, arguments);
      }
      return stopTyping;
    }()
  }, {
    key: "lastMessage",
    value: function lastMessage() {
      var min = this.state.latestMessages.length - 5;
      if (min < 0) {
        min = 0;
      }
      var max = this.state.latestMessages.length + 1;
      var messageSlice = this.state.latestMessages.slice(min, max);
      messageSlice.sort(function(a, b) {
        return b.created_at.getTime() - a.created_at.getTime();
      });
      return messageSlice[0];
    }
  }, {
    key: "markRead",
    value: function() {
      var _markRead = _asyncToGenerator(import_regenerator.default.mark(function _callee26() {
        var _this$getConfig3;
        var data, _args26 = arguments;
        return import_regenerator.default.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                data = _args26.length > 0 && _args26[0] !== void 0 ? _args26[0] : {};
                this._checkInitialized();
                if ((_this$getConfig3 = this.getConfig()) !== null && _this$getConfig3 !== void 0 && _this$getConfig3.read_events) {
                  _context26.next = 4;
                  break;
                }
                return _context26.abrupt("return", Promise.resolve(null));
              case 4:
                _context26.next = 6;
                return this.getClient().post(this._channelURL() + "/read", _objectSpread$5({}, data));
              case 6:
                return _context26.abrupt("return", _context26.sent);
              case 7:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));
      function markRead() {
        return _markRead.apply(this, arguments);
      }
      return markRead;
    }()
  }, {
    key: "clean",
    value: function clean() {
      if (this.lastKeyStroke) {
        var now = new Date();
        var diff = now.getTime() - this.lastKeyStroke.getTime();
        if (diff > 1e3 && this.isTyping) {
          logChatPromiseExecution(this.stopTyping(), "stop typing event");
        }
      }
      this.state.clean();
    }
  }, {
    key: "watch",
    value: function() {
      var _watch = _asyncToGenerator(import_regenerator.default.mark(function _callee27(options) {
        var defaultOptions, combined, state;
        return import_regenerator.default.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                defaultOptions = {
                  state: true,
                  watch: true,
                  presence: false
                };
                _context27.next = 3;
                return this.getClient().wsPromise;
              case 3:
                if (!this.getClient()._hasConnectionID()) {
                  defaultOptions.watch = false;
                }
                combined = _objectSpread$5(_objectSpread$5({}, defaultOptions), options);
                _context27.next = 7;
                return this.query(combined, "latest");
              case 7:
                state = _context27.sent;
                this.initialized = true;
                this.data = state.channel;
                this._client.logger("info", "channel:watch() - started watching channel ".concat(this.cid), {
                  tags: ["channel"],
                  channel: this
                });
                return _context27.abrupt("return", state);
              case 12:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));
      function watch(_x26) {
        return _watch.apply(this, arguments);
      }
      return watch;
    }()
  }, {
    key: "stopWatching",
    value: function() {
      var _stopWatching = _asyncToGenerator(import_regenerator.default.mark(function _callee28() {
        var response;
        return import_regenerator.default.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getClient().post(this._channelURL() + "/stop-watching", {});
              case 2:
                response = _context28.sent;
                this._client.logger("info", "channel:watch() - stopped watching channel ".concat(this.cid), {
                  tags: ["channel"],
                  channel: this
                });
                return _context28.abrupt("return", response);
              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));
      function stopWatching() {
        return _stopWatching.apply(this, arguments);
      }
      return stopWatching;
    }()
  }, {
    key: "getReplies",
    value: function() {
      var _getReplies = _asyncToGenerator(import_regenerator.default.mark(function _callee29(parent_id, options) {
        var data;
        return import_regenerator.default.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.getClient().get(this.getClient().baseURL + "/messages/".concat(parent_id, "/replies"), _objectSpread$5({}, options));
              case 2:
                data = _context29.sent;
                if (data.messages) {
                  this.state.addMessagesSorted(data.messages);
                }
                return _context29.abrupt("return", data);
              case 5:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));
      function getReplies(_x27, _x28) {
        return _getReplies.apply(this, arguments);
      }
      return getReplies;
    }()
  }, {
    key: "getPinnedMessages",
    value: function() {
      var _getPinnedMessages = _asyncToGenerator(import_regenerator.default.mark(function _callee30(options) {
        var sort, _args30 = arguments;
        return import_regenerator.default.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                sort = _args30.length > 1 && _args30[1] !== void 0 ? _args30[1] : [];
                _context30.next = 3;
                return this.getClient().get(this.getClient().baseURL + "/channels/".concat(this.type, "/").concat(this.id, "/pinned_messages"), {
                  payload: _objectSpread$5(_objectSpread$5({}, options), {}, {
                    sort: normalizeQuerySort(sort)
                  })
                });
              case 3:
                return _context30.abrupt("return", _context30.sent);
              case 4:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));
      function getPinnedMessages(_x29) {
        return _getPinnedMessages.apply(this, arguments);
      }
      return getPinnedMessages;
    }()
  }, {
    key: "getReactions",
    value: function getReactions(message_id, options) {
      return this.getClient().get(this.getClient().baseURL + "/messages/".concat(message_id, "/reactions"), _objectSpread$5({}, options));
    }
  }, {
    key: "getMessagesById",
    value: function getMessagesById(messageIds) {
      return this.getClient().get(this._channelURL() + "/messages", {
        ids: messageIds.join(",")
      });
    }
  }, {
    key: "lastRead",
    value: function lastRead() {
      this._checkInitialized();
      var _this$getClient = this.getClient(), userID = _this$getClient.userID;
      if (userID) {
        return this.state.read[userID] ? this.state.read[userID].last_read : null;
      }
    }
  }, {
    key: "_countMessageAsUnread",
    value: function _countMessageAsUnread(message) {
      var _message$user, _message$user2, _this$data2, _this$data3;
      if (message.shadowed)
        return false;
      if (message.silent)
        return false;
      if (message.parent_id && !message.show_in_channel)
        return false;
      if (((_message$user = message.user) === null || _message$user === void 0 ? void 0 : _message$user.id) === this.getClient().userID)
        return false;
      if ((_message$user2 = message.user) !== null && _message$user2 !== void 0 && _message$user2.id && this.getClient().userMuteStatus(message.user.id))
        return false;
      if (message.type === "system")
        return false;
      if (Array.isArray((_this$data2 = this.data) === null || _this$data2 === void 0 ? void 0 : _this$data2.own_capabilities) && !((_this$data3 = this.data) !== null && _this$data3 !== void 0 && _this$data3.own_capabilities.includes("read-events")))
        return false;
      if (this.muteStatus().muted)
        return false;
      return true;
    }
  }, {
    key: "countUnread",
    value: function countUnread(lastRead) {
      if (!lastRead)
        return this.state.unreadCount;
      var count = 0;
      for (var i = 0; i < this.state.latestMessages.length; i += 1) {
        var message = this.state.latestMessages[i];
        if (message.created_at > lastRead && this._countMessageAsUnread(message)) {
          count++;
        }
      }
      return count;
    }
  }, {
    key: "countUnreadMentions",
    value: function countUnreadMentions() {
      var lastRead = this.lastRead();
      var userID = this.getClient().userID;
      var count = 0;
      for (var i = 0; i < this.state.latestMessages.length; i += 1) {
        var _message$mentioned_us;
        var message = this.state.latestMessages[i];
        if (this._countMessageAsUnread(message) && (!lastRead || message.created_at > lastRead) && (_message$mentioned_us = message.mentioned_users) !== null && _message$mentioned_us !== void 0 && _message$mentioned_us.some(function(user) {
          return user.id === userID;
        })) {
          count++;
        }
      }
      return count;
    }
  }, {
    key: "query",
    value: function() {
      var _query = _asyncToGenerator(import_regenerator.default.mark(function _callee31(options) {
        var messageSetToAddToIfDoesNotExist, queryURL, state, membersStr, tempChannelCid, _args31 = arguments;
        return import_regenerator.default.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                messageSetToAddToIfDoesNotExist = _args31.length > 1 && _args31[1] !== void 0 ? _args31[1] : "current";
                _context31.next = 3;
                return this.getClient().wsPromise;
              case 3:
                queryURL = "".concat(this.getClient().baseURL, "/channels/").concat(this.type);
                if (this.id) {
                  queryURL += "/".concat(this.id);
                }
                _context31.next = 7;
                return this.getClient().post(queryURL + "/query", _objectSpread$5({
                  data: this._data,
                  state: true
                }, options));
              case 7:
                state = _context31.sent;
                if (!this.id) {
                  this.id = state.channel.id;
                  this.cid = state.channel.cid;
                  membersStr = state.members.map(function(member) {
                    var _member$user;
                    return member.user_id || ((_member$user = member.user) === null || _member$user === void 0 ? void 0 : _member$user.id);
                  }).sort().join(",");
                  tempChannelCid = "".concat(this.type, ":!members-").concat(membersStr);
                  if (tempChannelCid in this.getClient().activeChannels) {
                    delete this.getClient().activeChannels[tempChannelCid];
                  }
                  if (!(this.cid in this.getClient().activeChannels)) {
                    this.getClient().activeChannels[this.cid] = this;
                  }
                }
                this.getClient()._addChannelConfig(state);
                this._initializeState(state, messageSetToAddToIfDoesNotExist);
                this.data = state.channel;
                return _context31.abrupt("return", state);
              case 13:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));
      function query(_x30) {
        return _query.apply(this, arguments);
      }
      return query;
    }()
  }, {
    key: "banUser",
    value: function() {
      var _banUser = _asyncToGenerator(import_regenerator.default.mark(function _callee32(targetUserID, options) {
        return import_regenerator.default.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                this._checkInitialized();
                _context32.next = 3;
                return this.getClient().banUser(targetUserID, _objectSpread$5(_objectSpread$5({}, options), {}, {
                  type: this.type,
                  id: this.id
                }));
              case 3:
                return _context32.abrupt("return", _context32.sent);
              case 4:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));
      function banUser(_x31, _x32) {
        return _banUser.apply(this, arguments);
      }
      return banUser;
    }()
  }, {
    key: "hide",
    value: function() {
      var _hide = _asyncToGenerator(import_regenerator.default.mark(function _callee33() {
        var userId, clearHistory, _args33 = arguments;
        return import_regenerator.default.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                userId = _args33.length > 0 && _args33[0] !== void 0 ? _args33[0] : null;
                clearHistory = _args33.length > 1 && _args33[1] !== void 0 ? _args33[1] : false;
                this._checkInitialized();
                _context33.next = 5;
                return this.getClient().post("".concat(this._channelURL(), "/hide"), {
                  user_id: userId,
                  clear_history: clearHistory
                });
              case 5:
                return _context33.abrupt("return", _context33.sent);
              case 6:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));
      function hide() {
        return _hide.apply(this, arguments);
      }
      return hide;
    }()
  }, {
    key: "show",
    value: function() {
      var _show = _asyncToGenerator(import_regenerator.default.mark(function _callee34() {
        var userId, _args34 = arguments;
        return import_regenerator.default.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                userId = _args34.length > 0 && _args34[0] !== void 0 ? _args34[0] : null;
                this._checkInitialized();
                _context34.next = 4;
                return this.getClient().post("".concat(this._channelURL(), "/show"), {
                  user_id: userId
                });
              case 4:
                return _context34.abrupt("return", _context34.sent);
              case 5:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));
      function show() {
        return _show.apply(this, arguments);
      }
      return show;
    }()
  }, {
    key: "unbanUser",
    value: function() {
      var _unbanUser = _asyncToGenerator(import_regenerator.default.mark(function _callee35(targetUserID) {
        return import_regenerator.default.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                this._checkInitialized();
                _context35.next = 3;
                return this.getClient().unbanUser(targetUserID, {
                  type: this.type,
                  id: this.id
                });
              case 3:
                return _context35.abrupt("return", _context35.sent);
              case 4:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));
      function unbanUser(_x33) {
        return _unbanUser.apply(this, arguments);
      }
      return unbanUser;
    }()
  }, {
    key: "shadowBan",
    value: function() {
      var _shadowBan = _asyncToGenerator(import_regenerator.default.mark(function _callee36(targetUserID, options) {
        return import_regenerator.default.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                this._checkInitialized();
                _context36.next = 3;
                return this.getClient().shadowBan(targetUserID, _objectSpread$5(_objectSpread$5({}, options), {}, {
                  type: this.type,
                  id: this.id
                }));
              case 3:
                return _context36.abrupt("return", _context36.sent);
              case 4:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));
      function shadowBan(_x34, _x35) {
        return _shadowBan.apply(this, arguments);
      }
      return shadowBan;
    }()
  }, {
    key: "removeShadowBan",
    value: function() {
      var _removeShadowBan = _asyncToGenerator(import_regenerator.default.mark(function _callee37(targetUserID) {
        return import_regenerator.default.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                this._checkInitialized();
                _context37.next = 3;
                return this.getClient().removeShadowBan(targetUserID, {
                  type: this.type,
                  id: this.id
                });
              case 3:
                return _context37.abrupt("return", _context37.sent);
              case 4:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));
      function removeShadowBan(_x36) {
        return _removeShadowBan.apply(this, arguments);
      }
      return removeShadowBan;
    }()
  }, {
    key: "createCall",
    value: function() {
      var _createCall = _asyncToGenerator(import_regenerator.default.mark(function _callee38(options) {
        return import_regenerator.default.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getClient().post(this._channelURL() + "/call", options);
              case 2:
                return _context38.abrupt("return", _context38.sent);
              case 3:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));
      function createCall(_x37) {
        return _createCall.apply(this, arguments);
      }
      return createCall;
    }()
  }, {
    key: "on",
    value: function on(callbackOrString, callbackOrNothing) {
      var _this2 = this;
      var key = callbackOrNothing ? callbackOrString : "all";
      var valid = isValidEventType(key);
      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }
      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;
      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }
      this._client.logger("info", "Attaching listener for ".concat(key, " event on channel ").concat(this.cid), {
        tags: ["event", "channel"],
        channel: this
      });
      this.listeners[key].push(callback);
      return {
        unsubscribe: function unsubscribe() {
          _this2._client.logger("info", "Removing listener for ".concat(key, " event from channel ").concat(_this2.cid), {
            tags: ["event", "channel"],
            channel: _this2
          });
          _this2.listeners[key] = _this2.listeners[key].filter(function(el) {
            return el !== callback;
          });
        }
      };
    }
  }, {
    key: "off",
    value: function off(callbackOrString, callbackOrNothing) {
      var key = callbackOrNothing ? callbackOrString : "all";
      var valid = isValidEventType(key);
      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }
      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;
      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }
      this._client.logger("info", "Removing listener for ".concat(key, " event from channel ").concat(this.cid), {
        tags: ["event", "channel"],
        channel: this
      });
      this.listeners[key] = this.listeners[key].filter(function(value) {
        return value !== callback;
      });
    }
  }, {
    key: "_handleChannelEvent",
    value: function _handleChannelEvent(event) {
      var _event$user, _event$user2, _event$user3, _event$user5, _event$user6, _event$channel, _event$member, _event$user9;
      var channel = this;
      this._client.logger("info", "channel:_handleChannelEvent - Received event of type { ".concat(event.type, " } on ").concat(this.cid), {
        tags: ["event", "channel"],
        channel: this
      });
      var channelState = channel.state;
      switch (event.type) {
        case "typing.start":
          if ((_event$user = event.user) !== null && _event$user !== void 0 && _event$user.id) {
            channelState.typing[event.user.id] = event;
          }
          break;
        case "typing.stop":
          if ((_event$user2 = event.user) !== null && _event$user2 !== void 0 && _event$user2.id) {
            delete channelState.typing[event.user.id];
          }
          break;
        case "message.read":
          if ((_event$user3 = event.user) !== null && _event$user3 !== void 0 && _event$user3.id) {
            var _event$user4, _this$getClient$user;
            channelState.read[event.user.id] = {
              last_read: event.received_at,
              user: event.user,
              unread_messages: 0
            };
            if (((_event$user4 = event.user) === null || _event$user4 === void 0 ? void 0 : _event$user4.id) === ((_this$getClient$user = this.getClient().user) === null || _this$getClient$user === void 0 ? void 0 : _this$getClient$user.id)) {
              channelState.unreadCount = 0;
            }
          }
          break;
        case "user.watching.start":
        case "user.updated":
          if ((_event$user5 = event.user) !== null && _event$user5 !== void 0 && _event$user5.id) {
            channelState.watchers[event.user.id] = event.user;
          }
          break;
        case "user.watching.stop":
          if ((_event$user6 = event.user) !== null && _event$user6 !== void 0 && _event$user6.id) {
            delete channelState.watchers[event.user.id];
          }
          break;
        case "message.deleted":
          if (event.message) {
            this._extendEventWithOwnReactions(event);
            if (event.hard_delete)
              channelState.removeMessage(event.message);
            else
              channelState.addMessageSorted(event.message, false, false);
            channelState.removeQuotedMessageReferences(event.message);
            if (event.message.pinned) {
              channelState.removePinnedMessage(event.message);
            }
          }
          break;
        case "message.new":
          if (event.message) {
            var _event$user7, _this$getClient$user2, _event$user8;
            var ownMessage = ((_event$user7 = event.user) === null || _event$user7 === void 0 ? void 0 : _event$user7.id) === ((_this$getClient$user2 = this.getClient().user) === null || _this$getClient$user2 === void 0 ? void 0 : _this$getClient$user2.id);
            var isThreadMessage = event.message.parent_id && !event.message.show_in_channel;
            if (this.state.isUpToDate || isThreadMessage) {
              channelState.addMessageSorted(event.message, ownMessage);
            }
            if (event.message.pinned) {
              channelState.addPinnedMessage(event.message);
            }
            if (ownMessage && (_event$user8 = event.user) !== null && _event$user8 !== void 0 && _event$user8.id) {
              channelState.unreadCount = 0;
              channelState.read[event.user.id] = {
                last_read: new Date(event.created_at),
                user: event.user,
                unread_messages: 0
              };
            } else if (this._countMessageAsUnread(event.message)) {
              channelState.unreadCount = channelState.unreadCount + 1;
            }
          }
          break;
        case "message.updated":
          if (event.message) {
            this._extendEventWithOwnReactions(event);
            channelState.addMessageSorted(event.message, false, false);
            if (event.message.pinned) {
              channelState.addPinnedMessage(event.message);
            } else {
              channelState.removePinnedMessage(event.message);
            }
          }
          break;
        case "channel.truncated":
          if ((_event$channel = event.channel) !== null && _event$channel !== void 0 && _event$channel.truncated_at) {
            var truncatedAt = +new Date(event.channel.truncated_at);
            channelState.messageSets.forEach(function(messageSet, messageSetIndex) {
              messageSet.messages.forEach(function(_ref2) {
                var createdAt = _ref2.created_at, id = _ref2.id;
                if (truncatedAt > +createdAt)
                  channelState.removeMessage({
                    id,
                    messageSetIndex
                  });
              });
            });
            channelState.pinnedMessages.forEach(function(_ref3) {
              var id = _ref3.id, createdAt = _ref3.created_at;
              if (truncatedAt > +createdAt)
                channelState.removePinnedMessage({
                  id
                });
            });
          } else {
            channelState.clearMessages();
          }
          channelState.unreadCount = 0;
          if (event.message) {
            channelState.addMessageSorted(event.message);
            if (event.message.pinned) {
              channelState.addPinnedMessage(event.message);
            }
          }
          break;
        case "member.added":
        case "member.updated":
          if ((_event$member = event.member) !== null && _event$member !== void 0 && _event$member.user_id) {
            channelState.members[event.member.user_id] = event.member;
          }
          break;
        case "member.removed":
          if ((_event$user9 = event.user) !== null && _event$user9 !== void 0 && _event$user9.id) {
            delete channelState.members[event.user.id];
          }
          break;
        case "channel.updated":
          if (event.channel) {
            var _event$channel$hidden, _event$channel2, _channel$data, _event$channel$own_ca, _event$channel3, _channel$data2;
            channel.data = _objectSpread$5(_objectSpread$5({}, event.channel), {}, {
              hidden: (_event$channel$hidden = (_event$channel2 = event.channel) === null || _event$channel2 === void 0 ? void 0 : _event$channel2.hidden) !== null && _event$channel$hidden !== void 0 ? _event$channel$hidden : (_channel$data = channel.data) === null || _channel$data === void 0 ? void 0 : _channel$data.hidden,
              own_capabilities: (_event$channel$own_ca = (_event$channel3 = event.channel) === null || _event$channel3 === void 0 ? void 0 : _event$channel3.own_capabilities) !== null && _event$channel$own_ca !== void 0 ? _event$channel$own_ca : (_channel$data2 = channel.data) === null || _channel$data2 === void 0 ? void 0 : _channel$data2.own_capabilities
            });
          }
          break;
        case "reaction.new":
          if (event.message && event.reaction) {
            event.message = channelState.addReaction(event.reaction, event.message);
          }
          break;
        case "reaction.deleted":
          if (event.reaction) {
            event.message = channelState.removeReaction(event.reaction, event.message);
          }
          break;
        case "reaction.updated":
          if (event.reaction) {
            event.message = channelState.addReaction(event.reaction, event.message, true);
          }
          break;
        case "channel.hidden":
          if (event.clear_history) {
            channelState.clearMessages();
          }
          break;
      }
      if (event.watcher_count !== void 0) {
        channel.state.watcher_count = event.watcher_count;
      }
    }
  }, {
    key: "_checkInitialized",
    value: function _checkInitialized() {
      if (!this.initialized && !this.getClient()._isUsingServerAuth()) {
        throw Error("Channel ".concat(this.cid, " hasn't been initialized yet. Make sure to call .watch() and wait for it to resolve"));
      }
    }
  }, {
    key: "_initializeState",
    value: function _initializeState(state) {
      var messageSetToAddToIfDoesNotExist = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "latest";
      var _this$getClient2 = this.getClient(), clientState = _this$getClient2.state, user = _this$getClient2.user, userID = _this$getClient2.userID;
      if (state.members) {
        var _iterator = _createForOfIteratorHelper$2(state.members), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var member = _step.value;
            if (member.user) {
              clientState.updateUserReference(member.user, this.cid);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      this.state.membership = state.membership || {};
      var messages = state.messages || [];
      if (!this.state.messages) {
        this.state.initMessages();
      }
      this.state.addMessagesSorted(messages, false, true, true, messageSetToAddToIfDoesNotExist);
      if (!this.state.pinnedMessages) {
        this.state.pinnedMessages = [];
      }
      this.state.addPinnedMessages(state.pinned_messages || []);
      if (state.pending_messages) {
        this.state.pending_messages = state.pending_messages;
      }
      this.state.watcher_count = state.watcher_count || 0;
      if (state.watchers) {
        var _iterator2 = _createForOfIteratorHelper$2(state.watchers), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var watcher = _step2.value;
            if (watcher) {
              clientState.updateUserReference(watcher, this.cid);
              this.state.watchers[watcher.id] = watcher;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      if (userID != null) {
        var last_read = this.state.last_message_at || new Date();
        if (user) {
          this.state.read[user.id] = {
            user,
            last_read,
            unread_messages: 0
          };
        }
      }
      if (state.read) {
        var _iterator3 = _createForOfIteratorHelper$2(state.read), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _read$unread_messages;
            var read = _step3.value;
            this.state.read[read.user.id] = {
              last_read: new Date(read.last_read),
              unread_messages: (_read$unread_messages = read.unread_messages) !== null && _read$unread_messages !== void 0 ? _read$unread_messages : 0,
              user: read.user
            };
            if (read.user.id === (user === null || user === void 0 ? void 0 : user.id)) {
              this.state.unreadCount = this.state.read[read.user.id].unread_messages;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      if (state.members) {
        var _iterator4 = _createForOfIteratorHelper$2(state.members), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _member = _step4.value;
            if (_member.user) {
              this.state.members[_member.user.id] = _member;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }
  }, {
    key: "_extendEventWithOwnReactions",
    value: function _extendEventWithOwnReactions(event) {
      if (!event.message) {
        return;
      }
      var message = this.state.findMessage(event.message.id, event.message.parent_id);
      if (message) {
        event.message.own_reactions = message.own_reactions;
      }
    }
  }, {
    key: "_disconnect",
    value: function _disconnect() {
      this._client.logger("info", "channel:disconnect() - Disconnecting the channel ".concat(this.cid), {
        tags: ["connection", "channel"],
        channel: this
      });
      this.disconnected = true;
      this.state.setIsUpToDate(false);
    }
  }]);
  return Channel2;
}();
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var ClientState = function() {
  function ClientState2() {
    _classCallCheck(this, ClientState2);
    _defineProperty(this, "users", void 0);
    _defineProperty(this, "userChannelReferences", void 0);
    this.users = {};
    this.userChannelReferences = {};
  }
  _createClass(ClientState2, [{
    key: "updateUsers",
    value: function updateUsers(users) {
      var _iterator = _createForOfIteratorHelper$1(users), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var user = _step.value;
          this.updateUser(user);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "updateUser",
    value: function updateUser(user) {
      if (user != null) {
        this.users[user.id] = user;
      }
    }
  }, {
    key: "updateUserReference",
    value: function updateUserReference(user, channelID) {
      if (user == null) {
        return;
      }
      this.updateUser(user);
      if (!this.userChannelReferences[user.id]) {
        this.userChannelReferences[user.id] = {};
      }
      this.userChannelReferences[user.id][channelID] = true;
    }
  }, {
    key: "deleteAllChannelReference",
    value: function deleteAllChannelReference(channelID) {
      for (var userID in this.userChannelReferences) {
        delete this.userChannelReferences[userID][channelID];
      }
    }
  }]);
  return ClientState2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var InsightMetrics = function InsightMetrics2() {
  _classCallCheck(this, InsightMetrics2);
  _defineProperty(this, "connectionStartTimestamp", void 0);
  _defineProperty(this, "wsConsecutiveFailures", void 0);
  _defineProperty(this, "wsTotalFailures", void 0);
  _defineProperty(this, "instanceClientId", void 0);
  this.connectionStartTimestamp = null;
  this.wsTotalFailures = 0;
  this.wsConsecutiveFailures = 0;
  this.instanceClientId = randomId();
};
var postInsights = function() {
  var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee(insightType, insights) {
    var maxAttempts, i;
    return import_regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            maxAttempts = 3;
            i = 0;
          case 2:
            if (!(i < maxAttempts)) {
              _context.next = 17;
              break;
            }
            _context.prev = 3;
            _context.next = 6;
            return import_axios.default.post("https://chat-insights.getstream.io/insights/".concat(insightType), insights);
          case 6:
            _context.next = 13;
            break;
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](3);
            _context.next = 12;
            return sleep((i + 1) * 3e3);
          case 12:
            return _context.abrupt("continue", 14);
          case 13:
            return _context.abrupt("break", 17);
          case 14:
            i++;
            _context.next = 2;
            break;
          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 8]]);
  }));
  return function postInsights2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
function buildWsFatalInsight(connection, event) {
  return _objectSpread$4(_objectSpread$4({}, event), buildWsBaseInsight(connection));
}
function buildWsBaseInsight(connection) {
  var _connection$ws, _navigator, _navigator2;
  var client = connection.client;
  return {
    ready_state: (_connection$ws = connection.ws) === null || _connection$ws === void 0 ? void 0 : _connection$ws.readyState,
    url: connection._buildUrl(),
    api_key: client.key,
    start_ts: client.insightMetrics.connectionStartTimestamp,
    end_ts: new Date().getTime(),
    auth_type: client.getAuthType(),
    token: client.tokenManager.token,
    user_id: client.userID,
    user_details: client._user,
    device: client.options.device,
    client_id: connection.connectionID,
    ws_details: connection.ws,
    ws_consecutive_failures: client.insightMetrics.wsConsecutiveFailures,
    ws_total_failures: client.insightMetrics.wsTotalFailures,
    request_id: connection.requestID,
    online: typeof navigator !== "undefined" ? (_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.onLine : null,
    user_agent: typeof navigator !== "undefined" ? (_navigator2 = navigator) === null || _navigator2 === void 0 ? void 0 : _navigator2.userAgent : null,
    instance_client_id: client.insightMetrics.instanceClientId
  };
}
function buildWsSuccessAfterFailureInsight(connection) {
  return buildWsBaseInsight(connection);
}
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var isCloseEvent = function isCloseEvent2(res) {
  return res.code !== void 0;
};
var isErrorEvent = function isErrorEvent2(res) {
  return res.error !== void 0;
};
var StableWSConnection = function() {
  function StableWSConnection2(_ref) {
    var _this = this;
    var client = _ref.client;
    _classCallCheck(this, StableWSConnection2);
    _defineProperty(this, "client", void 0);
    _defineProperty(this, "connectionID", void 0);
    _defineProperty(this, "connectionOpen", void 0);
    _defineProperty(this, "consecutiveFailures", void 0);
    _defineProperty(this, "pingInterval", void 0);
    _defineProperty(this, "healthCheckTimeoutRef", void 0);
    _defineProperty(this, "isConnecting", void 0);
    _defineProperty(this, "isDisconnected", void 0);
    _defineProperty(this, "isHealthy", void 0);
    _defineProperty(this, "isResolved", void 0);
    _defineProperty(this, "lastEvent", void 0);
    _defineProperty(this, "connectionCheckTimeout", void 0);
    _defineProperty(this, "connectionCheckTimeoutRef", void 0);
    _defineProperty(this, "rejectPromise", void 0);
    _defineProperty(this, "requestID", void 0);
    _defineProperty(this, "resolvePromise", void 0);
    _defineProperty(this, "totalFailures", void 0);
    _defineProperty(this, "ws", void 0);
    _defineProperty(this, "wsID", void 0);
    _defineProperty(this, "_buildUrl", function() {
      var qs = encodeURIComponent(_this.client._buildWSPayload(_this.requestID));
      var token = _this.client.tokenManager.getToken();
      return "".concat(_this.client.wsBaseURL, "/connect?json=").concat(qs, "&api_key=").concat(_this.client.key, "&authorization=").concat(token, "&stream-auth-type=").concat(_this.client.getAuthType(), "&X-Stream-Client=").concat(_this.client.getUserAgent());
    });
    _defineProperty(this, "onlineStatusChanged", function(event) {
      if (event.type === "offline") {
        _this._log("onlineStatusChanged() - Status changing to offline");
        _this._setHealth(false);
      } else if (event.type === "online") {
        _this._log("onlineStatusChanged() - Status changing to online. isHealthy: ".concat(_this.isHealthy));
        if (!_this.isHealthy) {
          _this._reconnect({
            interval: 10
          });
        }
      }
    });
    _defineProperty(this, "onopen", function(wsID) {
      if (_this.wsID !== wsID)
        return;
      _this._log("onopen() - onopen callback", {
        wsID
      });
    });
    _defineProperty(this, "onmessage", function(wsID, event) {
      if (_this.wsID !== wsID)
        return;
      _this._log("onmessage() - onmessage callback", {
        event,
        wsID
      });
      var data = typeof event.data === "string" ? JSON.parse(event.data) : null;
      if (!_this.isResolved && data) {
        var _this$resolvePromise;
        _this.isResolved = true;
        if (data.error) {
          var _this$rejectPromise;
          (_this$rejectPromise = _this.rejectPromise) === null || _this$rejectPromise === void 0 ? void 0 : _this$rejectPromise.call(_this, _this._errorFromWSEvent(data, false));
          return;
        }
        (_this$resolvePromise = _this.resolvePromise) === null || _this$resolvePromise === void 0 ? void 0 : _this$resolvePromise.call(_this, data);
        _this._setHealth(true);
      }
      _this.lastEvent = new Date();
      if (data && data.type === "health.check") {
        _this.scheduleNextPing();
      }
      _this.client.handleEvent(event);
      _this.scheduleConnectionCheck();
    });
    _defineProperty(this, "onclose", function(wsID, event) {
      if (_this.wsID !== wsID)
        return;
      _this._log("onclose() - onclose callback - " + event.code, {
        event,
        wsID
      });
      if (event.code === chatCodes.WS_CLOSED_SUCCESS) {
        var _this$rejectPromise2;
        var error = new Error("WS connection reject with error ".concat(event.reason));
        error.reason = event.reason;
        error.code = event.code;
        error.wasClean = event.wasClean;
        error.target = event.target;
        (_this$rejectPromise2 = _this.rejectPromise) === null || _this$rejectPromise2 === void 0 ? void 0 : _this$rejectPromise2.call(_this, error);
        _this._log("onclose() - WS connection reject with error ".concat(event.reason), {
          event
        });
      } else {
        var _this$rejectPromise3;
        _this.consecutiveFailures += 1;
        _this.totalFailures += 1;
        _this._setHealth(false);
        _this.isConnecting = false;
        (_this$rejectPromise3 = _this.rejectPromise) === null || _this$rejectPromise3 === void 0 ? void 0 : _this$rejectPromise3.call(_this, _this._errorFromWSEvent(event));
        _this._log("onclose() - WS connection closed. Calling reconnect ...", {
          event
        });
        _this._reconnect();
      }
    });
    _defineProperty(this, "onerror", function(wsID, event) {
      var _this$rejectPromise4;
      if (_this.wsID !== wsID)
        return;
      _this.consecutiveFailures += 1;
      _this.totalFailures += 1;
      _this._setHealth(false);
      _this.isConnecting = false;
      (_this$rejectPromise4 = _this.rejectPromise) === null || _this$rejectPromise4 === void 0 ? void 0 : _this$rejectPromise4.call(_this, _this._errorFromWSEvent(event));
      _this._log("onerror() - WS connection resulted into error", {
        event
      });
      _this._reconnect();
    });
    _defineProperty(this, "_setHealth", function(healthy) {
      if (healthy === _this.isHealthy)
        return;
      _this.isHealthy = healthy;
      if (_this.isHealthy) {
        _this.client.dispatchEvent({
          type: "connection.changed",
          online: _this.isHealthy
        });
        return;
      }
      setTimeout(function() {
        if (_this.isHealthy)
          return;
        _this.client.dispatchEvent({
          type: "connection.changed",
          online: _this.isHealthy
        });
      }, 5e3);
    });
    _defineProperty(this, "_errorFromWSEvent", function(event) {
      var isWSFailure2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var code;
      var statusCode;
      var message;
      if (isCloseEvent(event)) {
        code = event.code;
        statusCode = "unknown";
        message = event.reason;
      }
      if (isErrorEvent(event)) {
        code = event.error.code;
        statusCode = event.error.StatusCode;
        message = event.error.message;
      }
      _this._log("_errorFromWSEvent() - WS failed with code ".concat(code), {
        event
      }, "warn");
      var error = new Error("WS failed with code ".concat(code, " and reason - ").concat(message));
      error.code = code;
      error.StatusCode = statusCode;
      error.isWSFailure = isWSFailure2;
      return error;
    });
    _defineProperty(this, "_setupConnectionPromise", function() {
      _this.isResolved = false;
      _this.connectionOpen = new Promise(function(resolve, reject) {
        _this.resolvePromise = resolve;
        _this.rejectPromise = reject;
      });
    });
    _defineProperty(this, "scheduleNextPing", function() {
      if (_this.healthCheckTimeoutRef) {
        clearTimeout(_this.healthCheckTimeoutRef);
      }
      _this.healthCheckTimeoutRef = setTimeout(function() {
        var data = [{
          type: "health.check",
          client_id: _this.client.clientID
        }];
        try {
          var _this$ws;
          (_this$ws = _this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.send(JSON.stringify(data));
        } catch (e) {
        }
      }, _this.pingInterval);
    });
    _defineProperty(this, "scheduleConnectionCheck", function() {
      if (_this.connectionCheckTimeoutRef) {
        clearTimeout(_this.connectionCheckTimeoutRef);
      }
      _this.connectionCheckTimeoutRef = setTimeout(function() {
        var now = new Date();
        if (_this.lastEvent && now.getTime() - _this.lastEvent.getTime() > _this.connectionCheckTimeout) {
          _this._log("scheduleConnectionCheck - going to reconnect");
          _this._setHealth(false);
          _this._reconnect();
        }
      }, _this.connectionCheckTimeout);
    });
    this.client = client;
    this.consecutiveFailures = 0;
    this.totalFailures = 0;
    this.isConnecting = false;
    this.isDisconnected = false;
    this.isResolved = false;
    this.isHealthy = false;
    this.wsID = 1;
    this.lastEvent = null;
    this.pingInterval = 25 * 1e3;
    this.connectionCheckTimeout = this.pingInterval + 10 * 1e3;
    addConnectionEventListeners(this.onlineStatusChanged);
  }
  _createClass(StableWSConnection2, [{
    key: "_log",
    value: function _log(msg) {
      var extra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "info";
      this.client.logger(level, "connection:" + msg, _objectSpread$3({
        tags: ["connection"]
      }, extra));
    }
  }, {
    key: "setClient",
    value: function setClient(client) {
      this.client = client;
    }
  }, {
    key: "connect",
    value: function() {
      var _connect2 = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
        var timeout, healthCheck, _args = arguments;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                timeout = _args.length > 0 && _args[0] !== void 0 ? _args[0] : 15e3;
                if (!this.isConnecting) {
                  _context.next = 3;
                  break;
                }
                throw Error("You've called connect twice, can only attempt 1 connection at the time");
              case 3:
                this.isDisconnected = false;
                _context.prev = 4;
                _context.next = 7;
                return this._connect();
              case 7:
                healthCheck = _context.sent;
                this.consecutiveFailures = 0;
                this._log("connect() - Established ws connection with healthcheck: ".concat(healthCheck));
                _context.next = 23;
                break;
              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](4);
                this.isHealthy = false;
                this.consecutiveFailures += 1;
                if (!(_context.t0.code === chatCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic())) {
                  _context.next = 21;
                  break;
                }
                this._log("connect() - WS failure due to expired token, so going to try to reload token and reconnect");
                this._reconnect({
                  refreshToken: true
                });
                _context.next = 23;
                break;
              case 21:
                if (_context.t0.isWSFailure) {
                  _context.next = 23;
                  break;
                }
                throw new Error(JSON.stringify({
                  code: _context.t0.code,
                  StatusCode: _context.t0.StatusCode,
                  message: _context.t0.message,
                  isWSFailure: _context.t0.isWSFailure
                }));
              case 23:
                _context.next = 25;
                return this._waitForHealthy(timeout);
              case 25:
                return _context.abrupt("return", _context.sent);
              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 12]]);
      }));
      function connect() {
        return _connect2.apply(this, arguments);
      }
      return connect;
    }()
  }, {
    key: "_waitForHealthy",
    value: function() {
      var _waitForHealthy2 = _asyncToGenerator(import_regenerator.default.mark(function _callee4() {
        var _this2 = this;
        var timeout, _args4 = arguments;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                timeout = _args4.length > 0 && _args4[0] !== void 0 ? _args4[0] : 15e3;
                return _context4.abrupt("return", Promise.race([_asyncToGenerator(import_regenerator.default.mark(function _callee2() {
                  var interval, i;
                  return import_regenerator.default.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          interval = 50;
                          i = 0;
                        case 2:
                          if (!(i <= timeout)) {
                            _context2.next = 18;
                            break;
                          }
                          _context2.prev = 3;
                          _context2.next = 6;
                          return _this2.connectionOpen;
                        case 6:
                          return _context2.abrupt("return", _context2.sent);
                        case 9:
                          _context2.prev = 9;
                          _context2.t0 = _context2["catch"](3);
                          if (!(i === timeout)) {
                            _context2.next = 13;
                            break;
                          }
                          throw new Error(JSON.stringify({
                            code: _context2.t0.code,
                            StatusCode: _context2.t0.StatusCode,
                            message: _context2.t0.message,
                            isWSFailure: _context2.t0.isWSFailure
                          }));
                        case 13:
                          _context2.next = 15;
                          return sleep(interval);
                        case 15:
                          i += interval;
                          _context2.next = 2;
                          break;
                        case 18:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2, null, [[3, 9]]);
                }))(), _asyncToGenerator(import_regenerator.default.mark(function _callee3() {
                  return import_regenerator.default.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return sleep(timeout);
                        case 2:
                          _this2.isConnecting = false;
                          throw new Error(JSON.stringify({
                            code: "",
                            StatusCode: "",
                            message: "initial WS connection could not be established",
                            isWSFailure: true
                          }));
                        case 4:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }))()]));
              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function _waitForHealthy() {
        return _waitForHealthy2.apply(this, arguments);
      }
      return _waitForHealthy;
    }()
  }, {
    key: "disconnect",
    value: function disconnect(timeout) {
      var _this3 = this;
      this._log("disconnect() - Closing the websocket connection for wsID ".concat(this.wsID));
      this.wsID += 1;
      this.isConnecting = false;
      this.isDisconnected = true;
      if (this.healthCheckTimeoutRef) {
        clearInterval(this.healthCheckTimeoutRef);
      }
      if (this.connectionCheckTimeoutRef) {
        clearInterval(this.connectionCheckTimeoutRef);
      }
      removeConnectionEventListeners(this.onlineStatusChanged);
      this.isHealthy = false;
      if (this.ws && this.ws.removeAllListeners) {
        this.ws.removeAllListeners();
      }
      var isClosedPromise;
      var ws = this.ws;
      if (ws && ws.close && ws.readyState === ws.OPEN) {
        isClosedPromise = new Promise(function(resolve) {
          var onclose = function onclose2(event) {
            _this3._log("disconnect() - resolving isClosedPromise ".concat(event ? "with" : "without", " close frame"), {
              event
            });
            resolve();
          };
          ws.onclose = onclose;
          setTimeout(onclose, timeout != null ? timeout : 1e3);
        });
        this._log("disconnect() - Manually closed connection by calling client.disconnect()");
        ws.close(chatCodes.WS_CLOSED_SUCCESS, "Manually closed connection by calling client.disconnect()");
      } else {
        this._log("disconnect() - ws connection doesn't exist or it is already closed.");
        isClosedPromise = Promise.resolve();
      }
      delete this.ws;
      return isClosedPromise;
    }
  }, {
    key: "_connect",
    value: function() {
      var _connect3 = _asyncToGenerator(import_regenerator.default.mark(function _callee5() {
        var wsURL, response, insights;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(this.isConnecting || this.isDisconnected)) {
                  _context5.next = 2;
                  break;
                }
                return _context5.abrupt("return");
              case 2:
                this.isConnecting = true;
                this.requestID = randomId();
                this.client.insightMetrics.connectionStartTimestamp = new Date().getTime();
                _context5.prev = 5;
                this._log("_connect() - waiting for token");
                _context5.next = 9;
                return this.client.tokenManager.tokenReady();
              case 9:
                this._setupConnectionPromise();
                wsURL = this._buildUrl();
                this._log("_connect() - Connecting to ".concat(wsURL), {
                  wsURL,
                  requestID: this.requestID
                });
                this.ws = new import_isomorphic_ws.default(wsURL);
                this.ws.onopen = this.onopen.bind(this, this.wsID);
                this.ws.onclose = this.onclose.bind(this, this.wsID);
                this.ws.onerror = this.onerror.bind(this, this.wsID);
                this.ws.onmessage = this.onmessage.bind(this, this.wsID);
                _context5.next = 19;
                return this.connectionOpen;
              case 19:
                response = _context5.sent;
                this.isConnecting = false;
                if (!response) {
                  _context5.next = 25;
                  break;
                }
                this.connectionID = response.connection_id;
                if (this.client.insightMetrics.wsConsecutiveFailures > 0 && this.client.options.enableInsights) {
                  postInsights("ws_success_after_failure", buildWsSuccessAfterFailureInsight(this));
                  this.client.insightMetrics.wsConsecutiveFailures = 0;
                }
                return _context5.abrupt("return", response);
              case 25:
                _context5.next = 32;
                break;
              case 27:
                _context5.prev = 27;
                _context5.t0 = _context5["catch"](5);
                this.isConnecting = false;
                if (this.client.options.enableInsights) {
                  this.client.insightMetrics.wsConsecutiveFailures++;
                  this.client.insightMetrics.wsTotalFailures++;
                  insights = buildWsFatalInsight(this, convertErrorToJson(_context5.t0));
                  postInsights === null || postInsights === void 0 ? void 0 : postInsights("ws_fatal", insights);
                }
                throw _context5.t0;
              case 32:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[5, 27]]);
      }));
      function _connect() {
        return _connect3.apply(this, arguments);
      }
      return _connect;
    }()
  }, {
    key: "_reconnect",
    value: function() {
      var _reconnect2 = _asyncToGenerator(import_regenerator.default.mark(function _callee6() {
        var options, interval, _args6 = arguments;
        return import_regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 0 && _args6[0] !== void 0 ? _args6[0] : {};
                this._log("_reconnect() - Initiating the reconnect");
                if (!(this.isConnecting || this.isHealthy)) {
                  _context6.next = 5;
                  break;
                }
                this._log("_reconnect() - Abort (1) since already connecting or healthy");
                return _context6.abrupt("return");
              case 5:
                interval = options.interval;
                if (!interval) {
                  interval = retryInterval(this.consecutiveFailures);
                }
                _context6.next = 9;
                return sleep(interval);
              case 9:
                if (!(this.isConnecting || this.isHealthy)) {
                  _context6.next = 12;
                  break;
                }
                this._log("_reconnect() - Abort (2) since already connecting or healthy");
                return _context6.abrupt("return");
              case 12:
                if (!this.isDisconnected) {
                  _context6.next = 15;
                  break;
                }
                this._log("_reconnect() - Abort (3) since disconnect() is called");
                return _context6.abrupt("return");
              case 15:
                this._log("_reconnect() - Destroying current WS connection");
                this._destroyCurrentWSConnection();
                if (!options.refreshToken) {
                  _context6.next = 20;
                  break;
                }
                _context6.next = 20;
                return this.client.tokenManager.loadToken();
              case 20:
                _context6.prev = 20;
                _context6.next = 23;
                return this._connect();
              case 23:
                this._log("_reconnect() - Waiting for recoverCallBack");
                _context6.next = 26;
                return this.client.recoverState();
              case 26:
                this._log("_reconnect() - Finished recoverCallBack");
                this.consecutiveFailures = 0;
                _context6.next = 38;
                break;
              case 30:
                _context6.prev = 30;
                _context6.t0 = _context6["catch"](20);
                this.isHealthy = false;
                this.consecutiveFailures += 1;
                if (!(_context6.t0.code === chatCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic())) {
                  _context6.next = 37;
                  break;
                }
                this._log("_reconnect() - WS failure due to expired token, so going to try to reload token and reconnect");
                return _context6.abrupt("return", this._reconnect({
                  refreshToken: true
                }));
              case 37:
                if (_context6.t0.isWSFailure) {
                  this._log("_reconnect() - WS failure, so going to try to reconnect");
                  this._reconnect();
                }
              case 38:
                this._log("_reconnect() - == END ==");
              case 39:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[20, 30]]);
      }));
      function _reconnect() {
        return _reconnect2.apply(this, arguments);
      }
      return _reconnect;
    }()
  }, {
    key: "_destroyCurrentWSConnection",
    value: function _destroyCurrentWSConnection() {
      this.wsID += 1;
      try {
        var _this$ws2, _this$ws3;
        this === null || this === void 0 ? void 0 : (_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.removeAllListeners();
        this === null || this === void 0 ? void 0 : (_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.close();
      } catch (e) {
      }
    }
  }]);
  return StableWSConnection2;
}();
var jwt = null;
var crypto$1 = null;
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function JWTUserToken(apiSecret, userId) {
  var extraData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var jwtOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (typeof userId !== "string") {
    throw new TypeError("userId should be a string");
  }
  var payload = _objectSpread$2({
    user_id: userId
  }, extraData);
  {
    throw Error("Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.");
  }
  var opts = _extends({
    algorithm: "HS256",
    noTimestamp: true
  }, jwtOptions);
}
function JWTServerToken(apiSecret) {
  var jwtOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var payload = {
    server: true
  };
  var opts = _extends({
    algorithm: "HS256",
    noTimestamp: true
  }, jwtOptions);
  return jwt.sign(payload, apiSecret, opts);
}
function UserFromToken(token) {
  var fragments = token.split(".");
  if (fragments.length !== 3) {
    return "";
  }
  var b64Payload = fragments[1];
  var payload = decodeBase64(b64Payload);
  var data = JSON.parse(payload);
  return data.user_id;
}
function DevToken(userId) {
  return [
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
    encodeBase64(JSON.stringify({
      user_id: userId
    })),
    "devtoken"
  ].join(".");
}
function CheckSignature(body, secret, signature) {
  var key = Buffer.from(secret, "ascii");
  var hash = crypto$1.createHmac("sha256", key).update(body).digest("hex");
  return hash === signature;
}
var TokenManager = function TokenManager2(secret) {
  var _this = this;
  _classCallCheck(this, TokenManager2);
  _defineProperty(this, "loadTokenPromise", void 0);
  _defineProperty(this, "type", void 0);
  _defineProperty(this, "secret", void 0);
  _defineProperty(this, "token", void 0);
  _defineProperty(this, "tokenProvider", void 0);
  _defineProperty(this, "user", void 0);
  _defineProperty(this, "setTokenOrProvider", function() {
    var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee(tokenOrProvider, user) {
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this.validateToken(tokenOrProvider, user);
              _this.user = user;
              if (isFunction(tokenOrProvider)) {
                _this.tokenProvider = tokenOrProvider;
                _this.type = "provider";
              }
              if (typeof tokenOrProvider === "string") {
                _this.token = tokenOrProvider;
                _this.type = "static";
              }
              if (!tokenOrProvider && _this.user && _this.secret) {
                _this.token = JWTUserToken(_this.secret, user.id, {}, {});
                _this.type = "static";
              }
              _context.next = 7;
              return _this.loadToken();
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
  _defineProperty(this, "reset", function() {
    _this.token = void 0;
    _this.user = void 0;
    _this.loadTokenPromise = null;
  });
  _defineProperty(this, "validateToken", function(tokenOrProvider, user) {
    if (user && user.anon && !tokenOrProvider)
      return;
    if (!_this.secret && !tokenOrProvider) {
      throw new Error("User token can not be empty");
    }
    if (tokenOrProvider && typeof tokenOrProvider !== "string" && !isFunction(tokenOrProvider)) {
      throw new Error("user token should either be a string or a function");
    }
    if (typeof tokenOrProvider === "string") {
      if (user.anon && tokenOrProvider === "")
        return;
      var tokenUserId = UserFromToken(tokenOrProvider);
      if (tokenOrProvider != null && (tokenUserId == null || tokenUserId === "" || tokenUserId !== user.id)) {
        throw new Error("userToken does not have a user_id or is not matching with user.id");
      }
    }
  });
  _defineProperty(this, "tokenReady", function() {
    return _this.loadTokenPromise;
  });
  _defineProperty(this, "loadToken", function() {
    _this.loadTokenPromise = new Promise(function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee2(resolve, reject) {
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(_this.type === "static")) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return", resolve(_this.token));
              case 2:
                if (!(_this.tokenProvider && typeof _this.tokenProvider !== "string")) {
                  _context2.next = 13;
                  break;
                }
                _context2.prev = 3;
                _context2.next = 6;
                return _this.tokenProvider();
              case 6:
                _this.token = _context2.sent;
                _context2.next = 12;
                break;
              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](3);
                return _context2.abrupt("return", reject(new Error("Call to tokenProvider failed with message: ".concat(_context2.t0))));
              case 12:
                resolve(_this.token);
              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[3, 9]]);
      }));
      return function(_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }());
    return _this.loadTokenPromise;
  });
  _defineProperty(this, "getToken", function() {
    if (_this.token) {
      return _this.token;
    }
    if (_this.user && _this.user.anon && !_this.token) {
      return _this.token;
    }
    if (_this.secret) {
      return JWTServerToken(_this.secret);
    }
    throw new Error("Both secret and user tokens are not set. Either client.connectUser wasn't called or client.disconnect was called");
  });
  _defineProperty(this, "isStatic", function() {
    return _this.type === "static";
  });
  this.loadTokenPromise = null;
  if (secret) {
    this.secret = secret;
  }
  this.type = "static";
  if (this.secret) {
    this.token = JWTServerToken(this.secret);
  }
};
var APIErrorCodes = {
  "-1": {
    name: "InternalSystemError",
    retryable: true
  },
  "2": {
    name: "AccessKeyError",
    retryable: false
  },
  "3": {
    name: "AuthenticationFailedError",
    retryable: true
  },
  "4": {
    name: "InputError",
    retryable: false
  },
  "6": {
    name: "DuplicateUsernameError",
    retryable: false
  },
  "9": {
    name: "RateLimitError",
    retryable: true
  },
  "16": {
    name: "DoesNotExistError",
    retryable: false
  },
  "17": {
    name: "NotAllowedError",
    retryable: false
  },
  "18": {
    name: "EventNotSupportedError",
    retryable: false
  },
  "19": {
    name: "ChannelFeatureNotSupportedError",
    retryable: false
  },
  "20": {
    name: "MessageTooLongError",
    retryable: false
  },
  "21": {
    name: "MultipleNestingLevelError",
    retryable: false
  },
  "22": {
    name: "PayloadTooBigError",
    retryable: false
  },
  "23": {
    name: "RequestTimeoutError",
    retryable: true
  },
  "24": {
    name: "MaxHeaderSizeExceededError",
    retryable: false
  },
  "40": {
    name: "AuthErrorTokenExpired",
    retryable: false
  },
  "41": {
    name: "AuthErrorTokenNotValidYet",
    retryable: false
  },
  "42": {
    name: "AuthErrorTokenUsedBeforeIssuedAt",
    retryable: false
  },
  "43": {
    name: "AuthErrorTokenSignatureInvalid",
    retryable: false
  },
  "44": {
    name: "CustomCommandEndpointMissingError",
    retryable: false
  },
  "45": {
    name: "CustomCommandEndpointCallError",
    retryable: true
  },
  "46": {
    name: "ConnectionIDNotFoundError",
    retryable: false
  },
  "60": {
    name: "CoolDownError",
    retryable: true
  },
  "69": {
    name: "ErrWrongRegion",
    retryable: false
  },
  "70": {
    name: "ErrQueryChannelPermissions",
    retryable: false
  },
  "71": {
    name: "ErrTooManyConnections",
    retryable: true
  },
  "99": {
    name: "AppSuspendedError",
    retryable: false
  }
};
function isAPIError(error) {
  return error.code !== void 0;
}
function isErrorRetryable(error) {
  if (!error.code)
    return false;
  var err = APIErrorCodes["".concat(error.code)];
  if (!err)
    return false;
  return err.retryable;
}
function isConnectionIDError(error) {
  return error.code === 46;
}
function isWSFailure(err) {
  if (typeof err.isWSFailure === "boolean") {
    return err.isWSFailure;
  }
  try {
    return JSON.parse(err.message).isWSFailure;
  } catch (_) {
    return false;
  }
}
function isErrorResponse(res) {
  return !res.status || res.status < 200 || 300 <= res.status;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2["Closed"] = "CLOSED";
  ConnectionState2["Connected"] = "CONNECTED";
  ConnectionState2["Connecting"] = "CONNECTING";
  ConnectionState2["Disconnected"] = "DISCONNECTED";
  ConnectionState2["Init"] = "INIT";
})(ConnectionState || (ConnectionState = {}));
var WSConnectionFallback = function() {
  function WSConnectionFallback2(_ref) {
    var _this = this;
    var client = _ref.client;
    _classCallCheck(this, WSConnectionFallback2);
    _defineProperty(this, "client", void 0);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "consecutiveFailures", void 0);
    _defineProperty(this, "connectionID", void 0);
    _defineProperty(this, "cancelToken", void 0);
    _defineProperty(this, "_onlineStatusChanged", function(event) {
      _this._log("_onlineStatusChanged() - ".concat(event.type));
      if (event.type === "offline") {
        var _this$cancelToken;
        _this._setState(ConnectionState.Closed);
        (_this$cancelToken = _this.cancelToken) === null || _this$cancelToken === void 0 ? void 0 : _this$cancelToken.cancel("disconnect() is called");
        _this.cancelToken = void 0;
        return;
      }
      if (event.type === "online" && _this.state === ConnectionState.Closed) {
        _this.connect(true);
      }
    });
    _defineProperty(this, "_req", function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee(params, config, retry) {
        var _this$cancelToken2, res;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!_this.cancelToken && !params.close) {
                  _this.cancelToken = import_axios.default.CancelToken.source();
                }
                _context.prev = 1;
                _context.next = 4;
                return _this.client.doAxiosRequest(
                  "get",
                  _this.client.baseURL.replace(":3030", ":8900") + "/longpoll",
                  void 0,
                  {
                    config: _objectSpread$1(_objectSpread$1({}, config), {}, {
                      cancelToken: (_this$cancelToken2 = _this.cancelToken) === null || _this$cancelToken2 === void 0 ? void 0 : _this$cancelToken2.token
                    }),
                    params
                  }
                );
              case 4:
                res = _context.sent;
                _this.consecutiveFailures = 0;
                return _context.abrupt("return", res);
              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](1);
                _this.consecutiveFailures += 1;
                if (!(retry && isErrorRetryable(_context.t0))) {
                  _context.next = 17;
                  break;
                }
                _this._log("_req() - Retryable error, retrying request");
                _context.next = 16;
                return sleep(retryInterval(_this.consecutiveFailures));
              case 16:
                return _context.abrupt("return", _this._req(params, config, retry));
              case 17:
                throw _context.t0;
              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 9]]);
      }));
      return function(_x, _x2, _x3) {
        return _ref2.apply(this, arguments);
      };
    }());
    _defineProperty(this, "_poll", _asyncToGenerator(import_regenerator.default.mark(function _callee2() {
      var _data$events, data, i;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(_this.state === ConnectionState.Connected)) {
                _context2.next = 25;
                break;
              }
              _context2.prev = 1;
              _context2.next = 4;
              return _this._req({}, {
                timeout: 3e4
              }, true);
            case 4:
              data = _context2.sent;
              if ((_data$events = data.events) !== null && _data$events !== void 0 && _data$events.length) {
                for (i = 0; i < data.events.length; i++) {
                  _this.client.dispatchEvent(data.events[i]);
                }
              }
              _context2.next = 23;
              break;
            case 8:
              _context2.prev = 8;
              _context2.t0 = _context2["catch"](1);
              if (!import_axios.default.isCancel(_context2.t0)) {
                _context2.next = 13;
                break;
              }
              _this._log("_poll() - axios canceled request");
              return _context2.abrupt("return");
            case 13:
              if (!isConnectionIDError(_context2.t0)) {
                _context2.next = 18;
                break;
              }
              _this._log("_poll() - ConnectionID error, connecting without ID...");
              _this._setState(ConnectionState.Disconnected);
              _this.connect(true);
              return _context2.abrupt("return");
            case 18:
              if (!(isAPIError(_context2.t0) && !isErrorRetryable(_context2.t0))) {
                _context2.next = 21;
                break;
              }
              _this._setState(ConnectionState.Closed);
              return _context2.abrupt("return");
            case 21:
              _context2.next = 23;
              return sleep(retryInterval(_this.consecutiveFailures));
            case 23:
              _context2.next = 0;
              break;
            case 25:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 8]]);
    })));
    _defineProperty(this, "connect", _asyncToGenerator(import_regenerator.default.mark(function _callee3() {
      var reconnect, _yield$_this$_req, event, _args3 = arguments;
      return import_regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reconnect = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : false;
              if (!(_this.state === ConnectionState.Connecting)) {
                _context3.next = 4;
                break;
              }
              _this._log("connect() - connecting already in progress", {
                reconnect
              }, "warn");
              return _context3.abrupt("return");
            case 4:
              if (!(_this.state === ConnectionState.Connected)) {
                _context3.next = 7;
                break;
              }
              _this._log("connect() - already connected and polling", {
                reconnect
              }, "warn");
              return _context3.abrupt("return");
            case 7:
              _this._setState(ConnectionState.Connecting);
              _this.connectionID = void 0;
              _context3.prev = 9;
              _context3.next = 12;
              return _this._req(
                {
                  json: _this.client._buildWSPayload()
                },
                {
                  timeout: 8e3
                },
                reconnect
              );
            case 12:
              _yield$_this$_req = _context3.sent;
              event = _yield$_this$_req.event;
              _this._setState(ConnectionState.Connected);
              _this.connectionID = event.connection_id;
              _this.client.dispatchEvent(event);
              _this._poll();
              if (reconnect) {
                _this.client.recoverState();
              }
              return _context3.abrupt("return", event);
            case 22:
              _context3.prev = 22;
              _context3.t0 = _context3["catch"](9);
              _this._setState(ConnectionState.Closed);
              throw _context3.t0;
            case 26:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[9, 22]]);
    })));
    _defineProperty(this, "isHealthy", function() {
      return !!_this.connectionID && _this.state === ConnectionState.Connected;
    });
    _defineProperty(this, "disconnect", _asyncToGenerator(import_regenerator.default.mark(function _callee4() {
      var _this$cancelToken3;
      var timeout, connection_id, _args4 = arguments;
      return import_regenerator.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              timeout = _args4.length > 0 && _args4[0] !== void 0 ? _args4[0] : 2e3;
              removeConnectionEventListeners(_this._onlineStatusChanged);
              _this._setState(ConnectionState.Disconnected);
              (_this$cancelToken3 = _this.cancelToken) === null || _this$cancelToken3 === void 0 ? void 0 : _this$cancelToken3.cancel("disconnect() is called");
              _this.cancelToken = void 0;
              connection_id = _this.connectionID;
              _this.connectionID = void 0;
              _context4.prev = 7;
              _context4.next = 10;
              return _this._req({
                close: true,
                connection_id
              }, {
                timeout
              }, false);
            case 10:
              _this._log("disconnect() - Closed connectionID");
              _context4.next = 16;
              break;
            case 13:
              _context4.prev = 13;
              _context4.t0 = _context4["catch"](7);
              _this._log("disconnect() - Failed", {
                err: _context4.t0
              }, "error");
            case 16:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[7, 13]]);
    })));
    this.client = client;
    this.state = ConnectionState.Init;
    this.consecutiveFailures = 0;
    addConnectionEventListeners(this._onlineStatusChanged);
  }
  _createClass(WSConnectionFallback2, [{
    key: "_log",
    value: function _log(msg) {
      var extra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "info";
      this.client.logger(level, "WSConnectionFallback:" + msg, _objectSpread$1({
        tags: ["connection_fallback", "connection"]
      }, extra));
    }
  }, {
    key: "_setState",
    value: function _setState(state) {
      this._log("_setState() - ".concat(state));
      if (this.state === ConnectionState.Connecting && state === ConnectionState.Connected) {
        this.client.dispatchEvent({
          type: "connection.changed",
          online: true
        });
      }
      if (state === ConnectionState.Closed || state === ConnectionState.Disconnected) {
        this.client.dispatchEvent({
          type: "connection.changed",
          online: false
        });
      }
      this.state = state;
    }
  }]);
  return WSConnectionFallback2;
}();
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ErrorFromResponse = function(_Error) {
  _inherits(ErrorFromResponse2, _Error);
  var _super = _createSuper(ErrorFromResponse2);
  function ErrorFromResponse2() {
    var _this;
    _classCallCheck(this, ErrorFromResponse2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "code", void 0);
    _defineProperty(_assertThisInitialized(_this), "response", void 0);
    _defineProperty(_assertThisInitialized(_this), "status", void 0);
    return _this;
  }
  return ErrorFromResponse2;
}(_wrapNativeSuper(Error));
var _excluded = ["created_at", "updated_at", "last_active", "online"];
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function isString(x) {
  return typeof x === "string" || x instanceof String;
}
var StreamChat = function() {
  function StreamChat2(_key, secretOrOptions, _options) {
    var _this = this;
    _classCallCheck(this, StreamChat2);
    _defineProperty(this, "_user", void 0);
    _defineProperty(this, "activeChannels", void 0);
    _defineProperty(this, "anonymous", void 0);
    _defineProperty(this, "axiosInstance", void 0);
    _defineProperty(this, "baseURL", void 0);
    _defineProperty(this, "browser", void 0);
    _defineProperty(this, "cleaningIntervalRef", void 0);
    _defineProperty(this, "clientID", void 0);
    _defineProperty(this, "configs", void 0);
    _defineProperty(this, "key", void 0);
    _defineProperty(this, "listeners", void 0);
    _defineProperty(this, "logger", void 0);
    _defineProperty(this, "recoverStateOnReconnect", void 0);
    _defineProperty(this, "mutedChannels", void 0);
    _defineProperty(this, "mutedUsers", void 0);
    _defineProperty(this, "node", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "secret", void 0);
    _defineProperty(this, "setUserPromise", void 0);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "tokenManager", void 0);
    _defineProperty(this, "user", void 0);
    _defineProperty(this, "userAgent", void 0);
    _defineProperty(this, "userID", void 0);
    _defineProperty(this, "wsBaseURL", void 0);
    _defineProperty(this, "wsConnection", void 0);
    _defineProperty(this, "wsFallback", void 0);
    _defineProperty(this, "wsPromise", void 0);
    _defineProperty(this, "consecutiveFailures", void 0);
    _defineProperty(this, "insightMetrics", void 0);
    _defineProperty(this, "defaultWSTimeoutWithFallback", void 0);
    _defineProperty(this, "defaultWSTimeout", void 0);
    _defineProperty(this, "_getConnectionID", function() {
      var _this$wsConnection, _this$wsFallback;
      return ((_this$wsConnection = _this.wsConnection) === null || _this$wsConnection === void 0 ? void 0 : _this$wsConnection.connectionID) || ((_this$wsFallback = _this.wsFallback) === null || _this$wsFallback === void 0 ? void 0 : _this$wsFallback.connectionID);
    });
    _defineProperty(this, "_hasConnectionID", function() {
      return Boolean(_this._getConnectionID());
    });
    _defineProperty(this, "connectUser", function() {
      var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee(user, userTokenOrProvider) {
        var setTokenPromise, wsPromise;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (user.id) {
                  _context.next = 2;
                  break;
                }
                throw new Error('The "id" field on the user is missing');
              case 2:
                if (!(_this.userID === user.id && _this.setUserPromise)) {
                  _context.next = 5;
                  break;
                }
                console.warn("Consecutive calls to connectUser is detected, ideally you should only call this function once in your app.");
                return _context.abrupt("return", _this.setUserPromise);
              case 5:
                if (!_this.userID) {
                  _context.next = 7;
                  break;
                }
                throw new Error("Use client.disconnect() before trying to connect as a different user. connectUser was called twice.");
              case 7:
                if ((_this._isUsingServerAuth() || _this.node) && !_this.options.allowServerSideConnect) {
                  console.warn('Please do not use connectUser server side. connectUser impacts MAU and concurrent connection usage and thus your bill. If you have a valid use-case, add "allowServerSideConnect: true" to the client options to disable this warning.');
                }
                _this.userID = user.id;
                _this.anonymous = false;
                setTokenPromise = _this._setToken(user, userTokenOrProvider);
                _this._setUser(user);
                wsPromise = _this.openConnection();
                _this.setUserPromise = Promise.all([setTokenPromise, wsPromise]).then(
                  function(result) {
                    return result[1];
                  }
                );
                _context.prev = 14;
                _context.next = 17;
                return _this.setUserPromise;
              case 17:
                return _context.abrupt("return", _context.sent);
              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](14);
                _this.disconnectUser();
                throw _context.t0;
              case 24:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[14, 20]]);
      }));
      return function(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    _defineProperty(this, "setUser", this.connectUser);
    _defineProperty(this, "_setToken", function(user, userTokenOrProvider) {
      return _this.tokenManager.setTokenOrProvider(userTokenOrProvider, user);
    });
    _defineProperty(this, "closeConnection", function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee2(timeout) {
        var _this$wsConnection2, _this$wsFallback2;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (_this.cleaningIntervalRef != null) {
                  clearInterval(_this.cleaningIntervalRef);
                  _this.cleaningIntervalRef = void 0;
                }
                _context2.next = 3;
                return Promise.all([(_this$wsConnection2 = _this.wsConnection) === null || _this$wsConnection2 === void 0 ? void 0 : _this$wsConnection2.disconnect(timeout), (_this$wsFallback2 = _this.wsFallback) === null || _this$wsFallback2 === void 0 ? void 0 : _this$wsFallback2.disconnect(timeout)]);
              case 3:
                return _context2.abrupt("return", Promise.resolve());
              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function(_x3) {
        return _ref2.apply(this, arguments);
      };
    }());
    _defineProperty(this, "openConnection", _asyncToGenerator(import_regenerator.default.mark(function _callee3() {
      var _this$wsConnection3, _this$wsConnection4, _this$wsFallback3;
      return import_regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (_this.userID) {
                _context3.next = 2;
                break;
              }
              throw Error("User is not set on client, use client.connectUser or client.connectAnonymousUser instead");
            case 2:
              if (!((_this$wsConnection3 = _this.wsConnection) !== null && _this$wsConnection3 !== void 0 && _this$wsConnection3.isConnecting && _this.wsPromise)) {
                _context3.next = 5;
                break;
              }
              _this.logger("info", "client:openConnection() - connection already in progress", {
                tags: ["connection", "client"]
              });
              return _context3.abrupt("return", _this.wsPromise);
            case 5:
              if (!(((_this$wsConnection4 = _this.wsConnection) !== null && _this$wsConnection4 !== void 0 && _this$wsConnection4.isHealthy || (_this$wsFallback3 = _this.wsFallback) !== null && _this$wsFallback3 !== void 0 && _this$wsFallback3.isHealthy()) && _this._hasConnectionID())) {
                _context3.next = 8;
                break;
              }
              _this.logger("info", "client:openConnection() - openConnection called twice, healthy connection already exists", {
                tags: ["connection", "client"]
              });
              return _context3.abrupt("return", Promise.resolve());
            case 8:
              _this.clientID = "".concat(_this.userID, "--").concat(randomId());
              _this.wsPromise = _this.connect();
              _this._startCleaning();
              return _context3.abrupt("return", _this.wsPromise);
            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    _defineProperty(this, "_setupConnection", this.openConnection);
    _defineProperty(this, "_normalizeDate", function(before) {
      if (before instanceof Date) {
        before = before.toISOString();
      }
      if (before === "") {
        throw new Error("Don't pass blank string for since, use null instead if resetting the token revoke");
      }
      return before;
    });
    _defineProperty(this, "disconnectUser", function() {
      var _ref4 = _asyncToGenerator(import_regenerator.default.mark(function _callee4(timeout) {
        var closePromise, _i, _Object$values, _channel;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _this.logger("info", "client:disconnect() - Disconnecting the client", {
                  tags: ["connection", "client"]
                });
                delete _this.user;
                delete _this._user;
                delete _this.userID;
                _this.anonymous = false;
                closePromise = _this.closeConnection(timeout);
                for (_i = 0, _Object$values = Object.values(_this.activeChannels); _i < _Object$values.length; _i++) {
                  _channel = _Object$values[_i];
                  _channel._disconnect();
                }
                _this.activeChannels = {};
                _this.state = new ClientState();
                setTimeout(_this.tokenManager.reset);
                return _context4.abrupt("return", closePromise);
              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return function(_x4) {
        return _ref4.apply(this, arguments);
      };
    }());
    _defineProperty(this, "disconnect", this.disconnectUser);
    _defineProperty(this, "connectAnonymousUser", function() {
      if ((_this._isUsingServerAuth() || _this.node) && !_this.options.allowServerSideConnect) {
        console.warn('Please do not use connectUser server side. connectUser impacts MAU and concurrent connection usage and thus your bill. If you have a valid use-case, add "allowServerSideConnect: true" to the client options to disable this warning.');
      }
      _this.anonymous = true;
      _this.userID = randomId();
      var anonymousUser = {
        id: _this.userID,
        anon: true
      };
      _this._setToken(anonymousUser, "");
      _this._setUser(anonymousUser);
      return _this._setupConnection();
    });
    _defineProperty(this, "setAnonymousUser", this.connectAnonymousUser);
    _defineProperty(this, "doAxiosRequest", function() {
      var _ref5 = _asyncToGenerator(import_regenerator.default.mark(function _callee5(type, url, data) {
        var options, requestConfig, response, _requestConfig$header, _args5 = arguments;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 3 && _args5[3] !== void 0 ? _args5[3] : {};
                _context5.next = 3;
                return _this.tokenManager.tokenReady();
              case 3:
                requestConfig = _this._enrichAxiosOptions(options);
                _context5.prev = 4;
                _this._logApiRequest(type, url, data, requestConfig);
                _context5.t0 = type;
                _context5.next = _context5.t0 === "get" ? 9 : _context5.t0 === "delete" ? 13 : _context5.t0 === "post" ? 17 : _context5.t0 === "put" ? 21 : _context5.t0 === "patch" ? 25 : _context5.t0 === "options" ? 29 : 33;
                break;
              case 9:
                _context5.next = 11;
                return _this.axiosInstance.get(url, requestConfig);
              case 11:
                response = _context5.sent;
                return _context5.abrupt("break", 34);
              case 13:
                _context5.next = 15;
                return _this.axiosInstance.delete(url, requestConfig);
              case 15:
                response = _context5.sent;
                return _context5.abrupt("break", 34);
              case 17:
                _context5.next = 19;
                return _this.axiosInstance.post(url, data, requestConfig);
              case 19:
                response = _context5.sent;
                return _context5.abrupt("break", 34);
              case 21:
                _context5.next = 23;
                return _this.axiosInstance.put(url, data, requestConfig);
              case 23:
                response = _context5.sent;
                return _context5.abrupt("break", 34);
              case 25:
                _context5.next = 27;
                return _this.axiosInstance.patch(url, data, requestConfig);
              case 27:
                response = _context5.sent;
                return _context5.abrupt("break", 34);
              case 29:
                _context5.next = 31;
                return _this.axiosInstance.options(url, requestConfig);
              case 31:
                response = _context5.sent;
                return _context5.abrupt("break", 34);
              case 33:
                throw new Error("Invalid request type");
              case 34:
                _this._logApiResponse(type, url, response);
                _this.consecutiveFailures = 0;
                return _context5.abrupt("return", _this.handleResponse(response));
              case 39:
                _context5.prev = 39;
                _context5.t1 = _context5["catch"](4);
                _context5.t1.client_request_id = (_requestConfig$header = requestConfig.headers) === null || _requestConfig$header === void 0 ? void 0 : _requestConfig$header["x-client-request-id"];
                _this._logApiError(type, url, _context5.t1);
                _this.consecutiveFailures += 1;
                if (!_context5.t1.response) {
                  _context5.next = 56;
                  break;
                }
                if (!(_context5.t1.response.data.code === chatCodes.TOKEN_EXPIRED && !_this.tokenManager.isStatic())) {
                  _context5.next = 53;
                  break;
                }
                if (!(_this.consecutiveFailures > 1)) {
                  _context5.next = 49;
                  break;
                }
                _context5.next = 49;
                return sleep(retryInterval(_this.consecutiveFailures));
              case 49:
                _this.tokenManager.loadToken();
                _context5.next = 52;
                return _this.doAxiosRequest(type, url, data, options);
              case 52:
                return _context5.abrupt("return", _context5.sent);
              case 53:
                return _context5.abrupt("return", _this.handleResponse(_context5.t1.response));
              case 56:
                throw _context5.t1;
              case 57:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[4, 39]]);
      }));
      return function(_x5, _x6, _x7) {
        return _ref5.apply(this, arguments);
      };
    }());
    _defineProperty(this, "dispatchEvent", function(event) {
      if (!event.received_at)
        event.received_at = new Date();
      var postListenerCallbacks = _this._handleClientEvent(event);
      var cid = event.cid;
      var channel = cid ? _this.activeChannels[cid] : void 0;
      if (channel) {
        channel._handleChannelEvent(event);
      }
      _this._callClientListeners(event);
      if (channel) {
        channel._callChannelListeners(event);
      }
      postListenerCallbacks.forEach(function(c) {
        return c();
      });
    });
    _defineProperty(this, "handleEvent", function(messageEvent) {
      var jsonString = messageEvent.data;
      var event = JSON.parse(jsonString);
      _this.dispatchEvent(event);
    });
    _defineProperty(this, "_updateMemberWatcherReferences", function(user) {
      var refMap = _this.state.userChannelReferences[user.id] || {};
      for (var _channelID in refMap) {
        var _channel2 = _this.activeChannels[_channelID];
        if (_channel2 !== null && _channel2 !== void 0 && _channel2.state) {
          if (_channel2.state.members[user.id]) {
            _channel2.state.members[user.id].user = user;
          }
          if (_channel2.state.watchers[user.id]) {
            _channel2.state.watchers[user.id] = user;
          }
        }
      }
    });
    _defineProperty(this, "_updateUserReferences", this._updateMemberWatcherReferences);
    _defineProperty(this, "_updateUserMessageReferences", function(user) {
      var refMap = _this.state.userChannelReferences[user.id] || {};
      for (var _channelID2 in refMap) {
        var _channel3 = _this.activeChannels[_channelID2];
        var state = _channel3.state;
        state === null || state === void 0 ? void 0 : state.updateUserMessages(user);
      }
    });
    _defineProperty(this, "_deleteUserMessageReference", function(user) {
      var hardDelete = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var refMap = _this.state.userChannelReferences[user.id] || {};
      for (var _channelID3 in refMap) {
        var _channel4 = _this.activeChannels[_channelID3];
        var state = _channel4.state;
        state === null || state === void 0 ? void 0 : state.deleteUserMessages(user, hardDelete);
      }
    });
    _defineProperty(this, "_handleUserEvent", function(event) {
      if (!event.user) {
        return;
      }
      if (event.type === "user.presence.changed" || event.type === "user.updated") {
        if (event.user.id === _this.userID) {
          var user = _objectSpread({}, _this.user || {});
          var _user = _objectSpread({}, _this._user || {});
          for (var _key2 in _this.user) {
            if (_key2 in event.user || isOwnUserBaseProperty(_key2)) {
              continue;
            }
            delete user[_key2];
            delete _user[_key2];
          }
          for (var _key3 in event.user) {
            if (_user && _key3 in _user) {
              _user[_key3] = event.user[_key3];
            }
          }
          _this._user = _objectSpread({}, _user);
          _this.user = _objectSpread(_objectSpread({}, user), event.user);
        }
        _this.state.updateUser(event.user);
        _this._updateMemberWatcherReferences(event.user);
      }
      if (event.type === "user.updated") {
        _this._updateUserMessageReferences(event.user);
      }
      if (event.type === "user.deleted" && event.user.deleted_at && (event.mark_messages_deleted || event.hard_delete)) {
        _this._deleteUserMessageReference(event.user, event.hard_delete);
      }
    });
    _defineProperty(this, "_callClientListeners", function(event) {
      var client = _this;
      var listeners = [];
      if (client.listeners.all) {
        listeners.push.apply(listeners, _toConsumableArray(client.listeners.all));
      }
      if (client.listeners[event.type]) {
        listeners.push.apply(listeners, _toConsumableArray(client.listeners[event.type]));
      }
      for (var _i2 = 0, _listeners = listeners; _i2 < _listeners.length; _i2++) {
        var listener = _listeners[_i2];
        listener(event);
      }
    });
    _defineProperty(this, "recoverState", _asyncToGenerator(import_regenerator.default.mark(function _callee6() {
      var cids;
      return import_regenerator.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _this.logger("info", "client:recoverState() - Start of recoverState with connectionID ".concat(_this._getConnectionID()), {
                tags: ["connection"]
              });
              cids = Object.keys(_this.activeChannels);
              if (!(cids.length && _this.recoverStateOnReconnect)) {
                _context6.next = 10;
                break;
              }
              _this.logger("info", "client:recoverState() - Start the querying of ".concat(cids.length, " channels"), {
                tags: ["connection", "client"]
              });
              _context6.next = 6;
              return _this.queryChannels({
                cid: {
                  $in: cids
                }
              }, {
                last_message_at: -1
              }, {
                limit: 30
              });
            case 6:
              _this.logger("info", "client:recoverState() - Querying channels finished", {
                tags: ["connection", "client"]
              });
              _this.dispatchEvent({
                type: "connection.recovered"
              });
              _context6.next = 11;
              break;
            case 10:
              _this.dispatchEvent({
                type: "connection.recovered"
              });
            case 11:
              _this.wsPromise = Promise.resolve();
              _this.setUserPromise = Promise.resolve();
            case 13:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    _defineProperty(this, "getChannelByMembers", function(channelType, custom) {
      var membersStr = _toConsumableArray(custom.members || []).sort().join(",");
      var tempCid = "".concat(channelType, ":!members-").concat(membersStr);
      if (!membersStr) {
        throw Error("Please specify atleast one member when creating unique conversation");
      }
      for (var _key4 in _this.activeChannels) {
        var _channel5 = _this.activeChannels[_key4];
        if (_channel5.disconnected) {
          continue;
        }
        if (_key4 === tempCid) {
          return _channel5;
        }
        if (_key4.indexOf("".concat(channelType, ":!members-")) === 0) {
          var membersStrInExistingChannel = Object.keys(_channel5.state.members).sort().join(",");
          if (membersStrInExistingChannel === membersStr) {
            return _channel5;
          }
        }
      }
      var channel = new Channel(_this, channelType, void 0, custom);
      _this.activeChannels[tempCid] = channel;
      return channel;
    });
    _defineProperty(this, "getChannelById", function(channelType, channelID, custom) {
      if (typeof channelID === "string" && ~channelID.indexOf(":")) {
        throw Error("Invalid channel id ".concat(channelID, ", can't contain the : character"));
      }
      var cid = "".concat(channelType, ":").concat(channelID);
      if (cid in _this.activeChannels && !_this.activeChannels[cid].disconnected) {
        var _channel6 = _this.activeChannels[cid];
        if (Object.keys(custom).length > 0) {
          _channel6.data = custom;
          _channel6._data = custom;
        }
        return _channel6;
      }
      var channel = new Channel(_this, channelType, channelID, custom);
      _this.activeChannels[channel.cid] = channel;
      return channel;
    });
    _defineProperty(this, "updateUsers", this.upsertUsers);
    _defineProperty(this, "updateUser", this.upsertUser);
    _defineProperty(this, "markAllRead", this.markChannelsRead);
    _defineProperty(this, "_isUsingServerAuth", function() {
      return !!_this.secret;
    });
    _defineProperty(this, "_buildWSPayload", function(client_request_id) {
      return JSON.stringify({
        user_id: _this.userID,
        user_details: _this._user,
        device: _this.options.device,
        client_request_id
      });
    });
    this.key = _key;
    this.listeners = {};
    this.state = new ClientState();
    this.mutedChannels = [];
    this.mutedUsers = [];
    if (secretOrOptions && isString(secretOrOptions)) {
      this.secret = secretOrOptions;
    }
    var inputOptions = _options ? _options : secretOrOptions && !isString(secretOrOptions) ? secretOrOptions : {};
    this.browser = typeof inputOptions.browser !== "undefined" ? inputOptions.browser : typeof window !== "undefined";
    this.node = !this.browser;
    this.options = _objectSpread({
      timeout: 3e3,
      withCredentials: false,
      warmUp: false,
      recoverStateOnReconnect: true
    }, inputOptions);
    if (this.node && !this.options.httpsAgent) {
      this.options.httpsAgent = new https.Agent({
        keepAlive: true,
        keepAliveMsecs: 3e3
      });
    }
    this.axiosInstance = import_axios.default.create(this.options);
    this.setBaseURL(this.options.baseURL || "https://chat.stream-io-api.com");
    if (typeof process !== "undefined" && process.env.STREAM_LOCAL_TEST_RUN) {
      this.setBaseURL("http://localhost:3030");
    }
    if (typeof process !== "undefined" && process.env.STREAM_LOCAL_TEST_HOST) {
      this.setBaseURL("http://" + process.env.STREAM_LOCAL_TEST_HOST);
    }
    this.wsConnection = null;
    this.wsPromise = null;
    this.setUserPromise = null;
    this.activeChannels = {};
    this.configs = {};
    this.anonymous = false;
    this.tokenManager = new TokenManager(this.secret);
    this.consecutiveFailures = 0;
    this.insightMetrics = new InsightMetrics();
    this.defaultWSTimeoutWithFallback = 6e3;
    this.defaultWSTimeout = 15e3;
    this.logger = isFunction(inputOptions.logger) ? inputOptions.logger : function() {
      return null;
    };
    this.recoverStateOnReconnect = this.options.recoverStateOnReconnect;
  }
  _createClass(StreamChat2, [{
    key: "devToken",
    value: function devToken(userID) {
      return DevToken(userID);
    }
  }, {
    key: "getAuthType",
    value: function getAuthType() {
      return this.anonymous ? "anonymous" : "jwt";
    }
  }, {
    key: "setBaseURL",
    value: function setBaseURL(baseURL) {
      this.baseURL = baseURL;
      this.wsBaseURL = this.baseURL.replace("http", "ws").replace(":3030", ":8800");
    }
  }, {
    key: "_setUser",
    value: function _setUser(user) {
      this.user = user;
      this._user = _objectSpread({}, user);
    }
  }, {
    key: "updateAppSettings",
    value: function() {
      var _updateAppSettings = _asyncToGenerator(import_regenerator.default.mark(function _callee7(options) {
        var apn_config;
        return import_regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                apn_config = options.apn_config;
                if (apn_config !== null && apn_config !== void 0 && apn_config.p12_cert) {
                  options = _objectSpread(_objectSpread({}, options), {}, {
                    apn_config: _objectSpread(_objectSpread({}, apn_config), {}, {
                      p12_cert: Buffer.from(apn_config.p12_cert).toString("base64")
                    })
                  });
                }
                _context7.next = 4;
                return this.patch(this.baseURL + "/app", options);
              case 4:
                return _context7.abrupt("return", _context7.sent);
              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
      function updateAppSettings(_x8) {
        return _updateAppSettings.apply(this, arguments);
      }
      return updateAppSettings;
    }()
  }, {
    key: "revokeTokens",
    value: function() {
      var _revokeTokens = _asyncToGenerator(import_regenerator.default.mark(function _callee8(before) {
        return import_regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.updateAppSettings({
                  revoke_tokens_issued_before: this._normalizeDate(before)
                });
              case 2:
                return _context8.abrupt("return", _context8.sent);
              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function revokeTokens(_x9) {
        return _revokeTokens.apply(this, arguments);
      }
      return revokeTokens;
    }()
  }, {
    key: "revokeUserToken",
    value: function() {
      var _revokeUserToken = _asyncToGenerator(import_regenerator.default.mark(function _callee9(userID, before) {
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.revokeUsersToken([userID], before);
              case 2:
                return _context9.abrupt("return", _context9.sent);
              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));
      function revokeUserToken(_x10, _x11) {
        return _revokeUserToken.apply(this, arguments);
      }
      return revokeUserToken;
    }()
  }, {
    key: "revokeUsersToken",
    value: function() {
      var _revokeUsersToken = _asyncToGenerator(import_regenerator.default.mark(function _callee10(userIDs, before) {
        var users, _iterator, _step, userID;
        return import_regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (before === void 0) {
                  before = new Date().toISOString();
                } else {
                  before = this._normalizeDate(before);
                }
                users = [];
                _iterator = _createForOfIteratorHelper(userIDs);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    userID = _step.value;
                    users.push({
                      id: userID,
                      set: {
                        revoke_tokens_issued_before: before
                      }
                    });
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                _context10.next = 6;
                return this.partialUpdateUsers(users);
              case 6:
                return _context10.abrupt("return", _context10.sent);
              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));
      function revokeUsersToken(_x12, _x13) {
        return _revokeUsersToken.apply(this, arguments);
      }
      return revokeUsersToken;
    }()
  }, {
    key: "getAppSettings",
    value: function() {
      var _getAppSettings = _asyncToGenerator(import_regenerator.default.mark(function _callee11() {
        return import_regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.get(this.baseURL + "/app");
              case 2:
                return _context11.abrupt("return", _context11.sent);
              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));
      function getAppSettings() {
        return _getAppSettings.apply(this, arguments);
      }
      return getAppSettings;
    }()
  }, {
    key: "testPushSettings",
    value: function() {
      var _testPushSettings = _asyncToGenerator(import_regenerator.default.mark(function _callee12(userID) {
        var data, _args12 = arguments;
        return import_regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                data = _args12.length > 1 && _args12[1] !== void 0 ? _args12[1] : {};
                _context12.next = 3;
                return this.post(this.baseURL + "/check_push", _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
                  user_id: userID
                }, data.messageID ? {
                  message_id: data.messageID
                } : {}), data.apnTemplate ? {
                  apn_template: data.apnTemplate
                } : {}), data.firebaseTemplate ? {
                  firebase_template: data.firebaseTemplate
                } : {}), data.firebaseDataTemplate ? {
                  firebase_data_template: data.firebaseDataTemplate
                } : {}), data.skipDevices ? {
                  skip_devices: true
                } : {}), data.pushProviderName ? {
                  push_provider_name: data.pushProviderName
                } : {}), data.pushProviderType ? {
                  push_provider_type: data.pushProviderType
                } : {}));
              case 3:
                return _context12.abrupt("return", _context12.sent);
              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));
      function testPushSettings(_x14) {
        return _testPushSettings.apply(this, arguments);
      }
      return testPushSettings;
    }()
  }, {
    key: "testSQSSettings",
    value: function() {
      var _testSQSSettings = _asyncToGenerator(import_regenerator.default.mark(function _callee13() {
        var data, _args13 = arguments;
        return import_regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                data = _args13.length > 0 && _args13[0] !== void 0 ? _args13[0] : {};
                _context13.next = 3;
                return this.post(this.baseURL + "/check_sqs", data);
              case 3:
                return _context13.abrupt("return", _context13.sent);
              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));
      function testSQSSettings() {
        return _testSQSSettings.apply(this, arguments);
      }
      return testSQSSettings;
    }()
  }, {
    key: "setGuestUser",
    value: function() {
      var _setGuestUser = _asyncToGenerator(import_regenerator.default.mark(function _callee14(user) {
        var response, _response$user, guestUser;
        return import_regenerator.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this.anonymous = true;
                _context14.prev = 1;
                _context14.next = 4;
                return this.post(this.baseURL + "/guest", {
                  user
                });
              case 4:
                response = _context14.sent;
                _context14.next = 11;
                break;
              case 7:
                _context14.prev = 7;
                _context14.t0 = _context14["catch"](1);
                this.anonymous = false;
                throw _context14.t0;
              case 11:
                this.anonymous = false;
                _response$user = response.user, _response$user.created_at, _response$user.updated_at, _response$user.last_active, _response$user.online, guestUser = _objectWithoutProperties(_response$user, _excluded);
                _context14.next = 15;
                return this.connectUser(guestUser, response.access_token);
              case 15:
                return _context14.abrupt("return", _context14.sent);
              case 16:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[1, 7]]);
      }));
      function setGuestUser(_x15) {
        return _setGuestUser.apply(this, arguments);
      }
      return setGuestUser;
    }()
  }, {
    key: "createToken",
    value: function createToken(userID, exp, iat) {
      if (this.secret == null) {
        throw Error("tokens can only be created server-side using the API Secret");
      }
      var extra = {};
      if (exp) {
        extra.exp = exp;
      }
      if (iat) {
        extra.iat = iat;
      }
      return JWTUserToken(this.secret, userID, extra, {});
    }
  }, {
    key: "on",
    value: function on(callbackOrString, callbackOrNothing) {
      var _this2 = this;
      var key = callbackOrNothing ? callbackOrString : "all";
      var valid = isValidEventType(key);
      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }
      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;
      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }
      this.logger("info", "Attaching listener for ".concat(key, " event"), {
        tags: ["event", "client"]
      });
      this.listeners[key].push(callback);
      return {
        unsubscribe: function unsubscribe() {
          _this2.logger("info", "Removing listener for ".concat(key, " event"), {
            tags: ["event", "client"]
          });
          _this2.listeners[key] = _this2.listeners[key].filter(function(el) {
            return el !== callback;
          });
        }
      };
    }
  }, {
    key: "off",
    value: function off(callbackOrString, callbackOrNothing) {
      var key = callbackOrNothing ? callbackOrString : "all";
      var valid = isValidEventType(key);
      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }
      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;
      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }
      this.logger("info", "Removing listener for ".concat(key, " event"), {
        tags: ["event", "client"]
      });
      this.listeners[key] = this.listeners[key].filter(function(value) {
        return value !== callback;
      });
    }
  }, {
    key: "_logApiRequest",
    value: function _logApiRequest(type, url, data, config) {
      this.logger("info", "client: ".concat(type, " - Request - ").concat(url), {
        tags: ["api", "api_request", "client"],
        url,
        payload: data,
        config
      });
    }
  }, {
    key: "_logApiResponse",
    value: function _logApiResponse(type, url, response) {
      this.logger("info", "client:".concat(type, " - Response - url: ").concat(url, " > status ").concat(response.status), {
        tags: ["api", "api_response", "client"],
        url,
        response
      });
    }
  }, {
    key: "_logApiError",
    value: function _logApiError(type, url, error) {
      this.logger("error", "client:".concat(type, " - Error - url: ").concat(url), {
        tags: ["api", "api_response", "client"],
        url,
        error
      });
    }
  }, {
    key: "get",
    value: function get(url, params) {
      return this.doAxiosRequest("get", url, null, {
        params
      });
    }
  }, {
    key: "put",
    value: function put(url, data) {
      return this.doAxiosRequest("put", url, data);
    }
  }, {
    key: "post",
    value: function post(url, data) {
      return this.doAxiosRequest("post", url, data);
    }
  }, {
    key: "patch",
    value: function patch(url, data) {
      return this.doAxiosRequest("patch", url, data);
    }
  }, {
    key: "delete",
    value: function _delete(url, params) {
      return this.doAxiosRequest("delete", url, null, {
        params
      });
    }
  }, {
    key: "sendFile",
    value: function sendFile(url, uri, name, contentType, user) {
      var data = addFileToFormData(uri, name, contentType);
      if (user != null)
        data.append("user", JSON.stringify(user));
      return this.doAxiosRequest("post", url, data, {
        headers: data.getHeaders ? data.getHeaders() : {},
        config: {
          timeout: 0,
          maxContentLength: Infinity,
          maxBodyLength: Infinity
        }
      });
    }
  }, {
    key: "errorFromResponse",
    value: function errorFromResponse(response) {
      var err;
      err = new ErrorFromResponse("StreamChat error HTTP code: ".concat(response.status));
      if (response.data && response.data.code) {
        err = new Error("StreamChat error code ".concat(response.data.code, ": ").concat(response.data.message));
        err.code = response.data.code;
      }
      err.response = response;
      err.status = response.status;
      return err;
    }
  }, {
    key: "handleResponse",
    value: function handleResponse(response) {
      var data = response.data;
      if (isErrorResponse(response)) {
        throw this.errorFromResponse(response);
      }
      return data;
    }
  }, {
    key: "_handleClientEvent",
    value: function _handleClientEvent(event) {
      var _event$me, _this3 = this, _event$me2;
      var client = this;
      var postListenerCallbacks = [];
      this.logger("info", "client:_handleClientEvent - Received event of type { ".concat(event.type, " }"), {
        tags: ["event", "client"],
        event
      });
      if (event.type === "user.presence.changed" || event.type === "user.updated" || event.type === "user.deleted") {
        this._handleUserEvent(event);
      }
      if (event.type === "health.check" && event.me) {
        client.user = event.me;
        client.state.updateUser(event.me);
        client.mutedChannels = event.me.channel_mutes;
        client.mutedUsers = event.me.mutes;
      }
      if (event.channel && event.type === "notification.message_new") {
        this.configs[event.channel.type] = event.channel.config;
      }
      if (event.type === "notification.channel_mutes_updated" && (_event$me = event.me) !== null && _event$me !== void 0 && _event$me.channel_mutes) {
        var currentMutedChannelIds = [];
        var nextMutedChannelIds = [];
        this.mutedChannels.forEach(function(mute) {
          return mute.channel && currentMutedChannelIds.push(mute.channel.cid);
        });
        event.me.channel_mutes.forEach(function(mute) {
          return mute.channel && nextMutedChannelIds.push(mute.channel.cid);
        });
        currentMutedChannelIds.forEach(function(cid) {
          if (!nextMutedChannelIds.includes(cid) && _this3.activeChannels[cid]) {
            _this3.activeChannels[cid].state.unreadCount = 0;
          }
        });
        this.mutedChannels = event.me.channel_mutes;
      }
      if (event.type === "notification.mutes_updated" && (_event$me2 = event.me) !== null && _event$me2 !== void 0 && _event$me2.mutes) {
        this.mutedUsers = event.me.mutes;
      }
      if (event.type === "notification.mark_read" && event.unread_channels === 0) {
        var activeChannelKeys = Object.keys(this.activeChannels);
        activeChannelKeys.forEach(function(activeChannelKey) {
          return _this3.activeChannels[activeChannelKey].state.unreadCount = 0;
        });
      }
      if ((event.type === "channel.deleted" || event.type === "notification.channel_deleted") && event.cid) {
        var _this$activeChannels$;
        client.state.deleteAllChannelReference(event.cid);
        (_this$activeChannels$ = this.activeChannels[event.cid]) === null || _this$activeChannels$ === void 0 ? void 0 : _this$activeChannels$._disconnect();
        postListenerCallbacks.push(function() {
          if (!event.cid)
            return;
          delete _this3.activeChannels[event.cid];
        });
      }
      return postListenerCallbacks;
    }
  }, {
    key: "_muteStatus",
    value: function _muteStatus(cid) {
      var muteStatus;
      for (var i = 0; i < this.mutedChannels.length; i++) {
        var _mute$channel;
        var mute = this.mutedChannels[i];
        if (((_mute$channel = mute.channel) === null || _mute$channel === void 0 ? void 0 : _mute$channel.cid) === cid) {
          muteStatus = {
            muted: mute.expires ? new Date(mute.expires).getTime() > new Date().getTime() : true,
            createdAt: mute.created_at ? new Date(mute.created_at) : new Date(),
            expiresAt: mute.expires ? new Date(mute.expires) : null
          };
          break;
        }
      }
      if (muteStatus) {
        return muteStatus;
      }
      return {
        muted: false,
        createdAt: null,
        expiresAt: null
      };
    }
  }, {
    key: "connect",
    value: function() {
      var _connect = _asyncToGenerator(import_regenerator.default.mark(function _callee15() {
        return import_regenerator.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(!this.userID || !this._user)) {
                  _context15.next = 2;
                  break;
                }
                throw Error("Call connectUser or connectAnonymousUser before starting the connection");
              case 2:
                if (this.wsBaseURL) {
                  _context15.next = 4;
                  break;
                }
                throw Error("Websocket base url not set");
              case 4:
                if (this.clientID) {
                  _context15.next = 6;
                  break;
                }
                throw Error("clientID is not set");
              case 6:
                if (!this.wsConnection && (this.options.warmUp || this.options.enableInsights)) {
                  this._sayHi();
                }
                if (this.options.wsConnection && this.node) {
                  this.options.wsConnection.setClient(this);
                  this.wsConnection = this.options.wsConnection;
                } else {
                  this.wsConnection = new StableWSConnection({
                    client: this
                  });
                }
                _context15.prev = 8;
                if (!this.wsFallback) {
                  _context15.next = 13;
                  break;
                }
                _context15.next = 12;
                return this.wsFallback.connect();
              case 12:
                return _context15.abrupt("return", _context15.sent);
              case 13:
                _context15.next = 15;
                return this.wsConnection.connect(this.options.enableWSFallback ? this.defaultWSTimeoutWithFallback : this.defaultWSTimeout);
              case 15:
                return _context15.abrupt("return", _context15.sent);
              case 18:
                _context15.prev = 18;
                _context15.t0 = _context15["catch"](8);
                if (!(this.options.enableWSFallback && isWSFailure(_context15.t0) && isOnline())) {
                  _context15.next = 29;
                  break;
                }
                this.logger("info", "client:connect() - WS failed, fallback to longpoll", {
                  tags: ["connection", "client"]
                });
                this.dispatchEvent({
                  type: "transport.changed",
                  mode: "longpoll"
                });
                this.wsConnection._destroyCurrentWSConnection();
                this.wsConnection.disconnect().then();
                this.wsFallback = new WSConnectionFallback({
                  client: this
                });
                _context15.next = 28;
                return this.wsFallback.connect();
              case 28:
                return _context15.abrupt("return", _context15.sent);
              case 29:
                throw _context15.t0;
              case 30:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[8, 18]]);
      }));
      function connect() {
        return _connect.apply(this, arguments);
      }
      return connect;
    }()
  }, {
    key: "_sayHi",
    value: function _sayHi() {
      var _this4 = this;
      var client_request_id = randomId();
      var opts = {
        headers: {
          "x-client-request-id": client_request_id
        }
      };
      this.doAxiosRequest("get", this.baseURL + "/hi", null, opts).catch(function(e) {
        if (_this4.options.enableInsights) {
          postInsights("http_hi_failed", {
            api_key: _this4.key,
            err: e,
            client_request_id
          });
        }
      });
    }
  }, {
    key: "queryUsers",
    value: function() {
      var _queryUsers = _asyncToGenerator(import_regenerator.default.mark(function _callee16(filterConditions) {
        var sort, options, defaultOptions, data, _args16 = arguments;
        return import_regenerator.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                sort = _args16.length > 1 && _args16[1] !== void 0 ? _args16[1] : [];
                options = _args16.length > 2 && _args16[2] !== void 0 ? _args16[2] : {};
                defaultOptions = {
                  presence: false
                };
                _context16.next = 5;
                return this.wsPromise;
              case 5:
                if (!this._hasConnectionID()) {
                  defaultOptions.presence = false;
                }
                _context16.next = 8;
                return this.get(this.baseURL + "/users", {
                  payload: _objectSpread(_objectSpread({
                    filter_conditions: filterConditions,
                    sort: normalizeQuerySort(sort)
                  }, defaultOptions), options)
                });
              case 8:
                data = _context16.sent;
                this.state.updateUsers(data.users);
                return _context16.abrupt("return", data);
              case 11:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));
      function queryUsers(_x16) {
        return _queryUsers.apply(this, arguments);
      }
      return queryUsers;
    }()
  }, {
    key: "queryBannedUsers",
    value: function() {
      var _queryBannedUsers = _asyncToGenerator(import_regenerator.default.mark(function _callee17() {
        var filterConditions, sort, options, _args17 = arguments;
        return import_regenerator.default.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                filterConditions = _args17.length > 0 && _args17[0] !== void 0 ? _args17[0] : {};
                sort = _args17.length > 1 && _args17[1] !== void 0 ? _args17[1] : [];
                options = _args17.length > 2 && _args17[2] !== void 0 ? _args17[2] : {};
                _context17.next = 5;
                return this.get(this.baseURL + "/query_banned_users", {
                  payload: _objectSpread({
                    filter_conditions: filterConditions,
                    sort: normalizeQuerySort(sort)
                  }, options)
                });
              case 5:
                return _context17.abrupt("return", _context17.sent);
              case 6:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));
      function queryBannedUsers() {
        return _queryBannedUsers.apply(this, arguments);
      }
      return queryBannedUsers;
    }()
  }, {
    key: "queryMessageFlags",
    value: function() {
      var _queryMessageFlags = _asyncToGenerator(import_regenerator.default.mark(function _callee18() {
        var filterConditions, options, _args18 = arguments;
        return import_regenerator.default.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                filterConditions = _args18.length > 0 && _args18[0] !== void 0 ? _args18[0] : {};
                options = _args18.length > 1 && _args18[1] !== void 0 ? _args18[1] : {};
                _context18.next = 4;
                return this.get(this.baseURL + "/moderation/flags/message", {
                  payload: _objectSpread({
                    filter_conditions: filterConditions
                  }, options)
                });
              case 4:
                return _context18.abrupt("return", _context18.sent);
              case 5:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));
      function queryMessageFlags() {
        return _queryMessageFlags.apply(this, arguments);
      }
      return queryMessageFlags;
    }()
  }, {
    key: "queryChannels",
    value: function() {
      var _queryChannels = _asyncToGenerator(import_regenerator.default.mark(function _callee19(filterConditions) {
        var sort, options, stateOptions, skipInitialization, defaultOptions, payload, data, channels, _iterator2, _step2, channelState, _iterator3, _step3, _channelState, c, _args19 = arguments;
        return import_regenerator.default.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                sort = _args19.length > 1 && _args19[1] !== void 0 ? _args19[1] : [];
                options = _args19.length > 2 && _args19[2] !== void 0 ? _args19[2] : {};
                stateOptions = _args19.length > 3 && _args19[3] !== void 0 ? _args19[3] : {};
                skipInitialization = stateOptions.skipInitialization;
                defaultOptions = {
                  state: true,
                  watch: true,
                  presence: false
                };
                _context19.next = 7;
                return this.wsPromise;
              case 7:
                if (!this._hasConnectionID()) {
                  defaultOptions.watch = false;
                }
                payload = _objectSpread(_objectSpread({
                  filter_conditions: filterConditions,
                  sort: normalizeQuerySort(sort)
                }, defaultOptions), options);
                _context19.next = 11;
                return this.post(this.baseURL + "/channels", payload);
              case 11:
                data = _context19.sent;
                channels = [];
                _iterator2 = _createForOfIteratorHelper(data.channels);
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                    channelState = _step2.value;
                    this._addChannelConfig(channelState);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
                _iterator3 = _createForOfIteratorHelper(data.channels);
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                    _channelState = _step3.value;
                    c = this.channel(_channelState.channel.type, _channelState.channel.id);
                    c.data = _channelState.channel;
                    c.initialized = true;
                    if (skipInitialization === void 0) {
                      c._initializeState(_channelState, "latest");
                    } else if (!skipInitialization.includes(_channelState.channel.id)) {
                      c.state.clearMessages();
                      c._initializeState(_channelState, "latest");
                    }
                    channels.push(c);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
                return _context19.abrupt("return", channels);
              case 18:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));
      function queryChannels(_x17) {
        return _queryChannels.apply(this, arguments);
      }
      return queryChannels;
    }()
  }, {
    key: "search",
    value: function() {
      var _search = _asyncToGenerator(import_regenerator.default.mark(function _callee20(filterConditions, query) {
        var options, payload, _args20 = arguments;
        return import_regenerator.default.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                options = _args20.length > 2 && _args20[2] !== void 0 ? _args20[2] : {};
                if (!(options.offset && (options.sort || options.next))) {
                  _context20.next = 3;
                  break;
                }
                throw Error("Cannot specify offset with sort or next parameters");
              case 3:
                payload = _objectSpread(_objectSpread({
                  filter_conditions: filterConditions
                }, options), {}, {
                  sort: options.sort ? normalizeQuerySort(options.sort) : void 0
                });
                if (!(typeof query === "string")) {
                  _context20.next = 8;
                  break;
                }
                payload.query = query;
                _context20.next = 13;
                break;
              case 8:
                if (!(_typeof(query) === "object")) {
                  _context20.next = 12;
                  break;
                }
                payload.message_filter_conditions = query;
                _context20.next = 13;
                break;
              case 12:
                throw Error("Invalid type ".concat(_typeof(query), " for query parameter"));
              case 13:
                _context20.next = 15;
                return this.wsPromise;
              case 15:
                _context20.next = 17;
                return this.get(this.baseURL + "/search", {
                  payload
                });
              case 17:
                return _context20.abrupt("return", _context20.sent);
              case 18:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));
      function search(_x18, _x19) {
        return _search.apply(this, arguments);
      }
      return search;
    }()
  }, {
    key: "setLocalDevice",
    value: function setLocalDevice(device) {
      if (this.wsConnection || this.wsFallback) {
        throw new Error("you can only set device before opening a websocket connection");
      }
      this.options.device = device;
    }
  }, {
    key: "addDevice",
    value: function() {
      var _addDevice = _asyncToGenerator(import_regenerator.default.mark(function _callee21(id, push_provider, userID, push_provider_name) {
        return import_regenerator.default.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.post(this.baseURL + "/devices", _objectSpread(_objectSpread({
                  id,
                  push_provider
                }, userID != null ? {
                  user_id: userID
                } : {}), push_provider_name != null ? {
                  push_provider_name
                } : {}));
              case 2:
                return _context21.abrupt("return", _context21.sent);
              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));
      function addDevice(_x20, _x21, _x22, _x23) {
        return _addDevice.apply(this, arguments);
      }
      return addDevice;
    }()
  }, {
    key: "getDevices",
    value: function() {
      var _getDevices = _asyncToGenerator(import_regenerator.default.mark(function _callee22(userID) {
        return import_regenerator.default.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.get(this.baseURL + "/devices", userID ? {
                  user_id: userID
                } : {});
              case 2:
                return _context22.abrupt("return", _context22.sent);
              case 3:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));
      function getDevices(_x24) {
        return _getDevices.apply(this, arguments);
      }
      return getDevices;
    }()
  }, {
    key: "removeDevice",
    value: function() {
      var _removeDevice = _asyncToGenerator(import_regenerator.default.mark(function _callee23(id, userID) {
        return import_regenerator.default.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.delete(this.baseURL + "/devices", _objectSpread({
                  id
                }, userID ? {
                  user_id: userID
                } : {}));
              case 2:
                return _context23.abrupt("return", _context23.sent);
              case 3:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));
      function removeDevice(_x25, _x26) {
        return _removeDevice.apply(this, arguments);
      }
      return removeDevice;
    }()
  }, {
    key: "getRateLimits",
    value: function() {
      var _getRateLimits = _asyncToGenerator(import_regenerator.default.mark(function _callee24(params) {
        var _ref7, serverSide, web, android, ios, endpoints;
        return import_regenerator.default.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _ref7 = params || {}, serverSide = _ref7.serverSide, web = _ref7.web, android = _ref7.android, ios = _ref7.ios, endpoints = _ref7.endpoints;
                return _context24.abrupt("return", this.get(this.baseURL + "/rate_limits", {
                  server_side: serverSide,
                  web,
                  android,
                  ios,
                  endpoints: endpoints ? endpoints.join(",") : void 0
                }));
              case 2:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));
      function getRateLimits(_x27) {
        return _getRateLimits.apply(this, arguments);
      }
      return getRateLimits;
    }()
  }, {
    key: "_addChannelConfig",
    value: function _addChannelConfig(channelState) {
      this.configs[channelState.channel.type] = channelState.channel.config;
    }
  }, {
    key: "channel",
    value: function channel(channelType, channelIDOrCustom) {
      var custom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!this.userID && !this._isUsingServerAuth()) {
        throw Error("Call connectUser or connectAnonymousUser before creating a channel");
      }
      if (~channelType.indexOf(":")) {
        throw Error("Invalid channel group ".concat(channelType, ", can't contain the : character"));
      }
      if (channelIDOrCustom == null || channelIDOrCustom === "") {
        return new Channel(this, channelType, void 0, custom);
      }
      if (_typeof(channelIDOrCustom) === "object") {
        return this.getChannelByMembers(channelType, channelIDOrCustom);
      }
      return this.getChannelById(channelType, channelIDOrCustom, custom);
    }
  }, {
    key: "partialUpdateUser",
    value: function() {
      var _partialUpdateUser = _asyncToGenerator(import_regenerator.default.mark(function _callee25(partialUserObject) {
        return import_regenerator.default.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.partialUpdateUsers([partialUserObject]);
              case 2:
                return _context25.abrupt("return", _context25.sent);
              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));
      function partialUpdateUser(_x28) {
        return _partialUpdateUser.apply(this, arguments);
      }
      return partialUpdateUser;
    }()
  }, {
    key: "upsertUsers",
    value: function() {
      var _upsertUsers = _asyncToGenerator(import_regenerator.default.mark(function _callee26(users) {
        var userMap, _iterator4, _step4, userObject;
        return import_regenerator.default.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                userMap = {};
                _iterator4 = _createForOfIteratorHelper(users);
                _context26.prev = 2;
                _iterator4.s();
              case 4:
                if ((_step4 = _iterator4.n()).done) {
                  _context26.next = 11;
                  break;
                }
                userObject = _step4.value;
                if (userObject.id) {
                  _context26.next = 8;
                  break;
                }
                throw Error("User ID is required when updating a user");
              case 8:
                userMap[userObject.id] = userObject;
              case 9:
                _context26.next = 4;
                break;
              case 11:
                _context26.next = 16;
                break;
              case 13:
                _context26.prev = 13;
                _context26.t0 = _context26["catch"](2);
                _iterator4.e(_context26.t0);
              case 16:
                _context26.prev = 16;
                _iterator4.f();
                return _context26.finish(16);
              case 19:
                _context26.next = 21;
                return this.post(this.baseURL + "/users", {
                  users: userMap
                });
              case 21:
                return _context26.abrupt("return", _context26.sent);
              case 22:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this, [[2, 13, 16, 19]]);
      }));
      function upsertUsers(_x29) {
        return _upsertUsers.apply(this, arguments);
      }
      return upsertUsers;
    }()
  }, {
    key: "upsertUser",
    value: function upsertUser(userObject) {
      return this.upsertUsers([userObject]);
    }
  }, {
    key: "partialUpdateUsers",
    value: function() {
      var _partialUpdateUsers = _asyncToGenerator(import_regenerator.default.mark(function _callee27(users) {
        var _iterator5, _step5, userObject;
        return import_regenerator.default.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _iterator5 = _createForOfIteratorHelper(users);
                _context27.prev = 1;
                _iterator5.s();
              case 3:
                if ((_step5 = _iterator5.n()).done) {
                  _context27.next = 9;
                  break;
                }
                userObject = _step5.value;
                if (userObject.id) {
                  _context27.next = 7;
                  break;
                }
                throw Error("User ID is required when updating a user");
              case 7:
                _context27.next = 3;
                break;
              case 9:
                _context27.next = 14;
                break;
              case 11:
                _context27.prev = 11;
                _context27.t0 = _context27["catch"](1);
                _iterator5.e(_context27.t0);
              case 14:
                _context27.prev = 14;
                _iterator5.f();
                return _context27.finish(14);
              case 17:
                _context27.next = 19;
                return this.patch(this.baseURL + "/users", {
                  users
                });
              case 19:
                return _context27.abrupt("return", _context27.sent);
              case 20:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this, [[1, 11, 14, 17]]);
      }));
      function partialUpdateUsers(_x30) {
        return _partialUpdateUsers.apply(this, arguments);
      }
      return partialUpdateUsers;
    }()
  }, {
    key: "deleteUser",
    value: function() {
      var _deleteUser = _asyncToGenerator(import_regenerator.default.mark(function _callee28(userID, params) {
        return import_regenerator.default.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.delete(this.baseURL + "/users/".concat(userID), params);
              case 2:
                return _context28.abrupt("return", _context28.sent);
              case 3:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));
      function deleteUser(_x31, _x32) {
        return _deleteUser.apply(this, arguments);
      }
      return deleteUser;
    }()
  }, {
    key: "reactivateUser",
    value: function() {
      var _reactivateUser = _asyncToGenerator(import_regenerator.default.mark(function _callee29(userID, options) {
        return import_regenerator.default.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.post(this.baseURL + "/users/".concat(userID, "/reactivate"), _objectSpread({}, options));
              case 2:
                return _context29.abrupt("return", _context29.sent);
              case 3:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));
      function reactivateUser(_x33, _x34) {
        return _reactivateUser.apply(this, arguments);
      }
      return reactivateUser;
    }()
  }, {
    key: "deactivateUser",
    value: function() {
      var _deactivateUser = _asyncToGenerator(import_regenerator.default.mark(function _callee30(userID, options) {
        return import_regenerator.default.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.post(this.baseURL + "/users/".concat(userID, "/deactivate"), _objectSpread({}, options));
              case 2:
                return _context30.abrupt("return", _context30.sent);
              case 3:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));
      function deactivateUser(_x35, _x36) {
        return _deactivateUser.apply(this, arguments);
      }
      return deactivateUser;
    }()
  }, {
    key: "exportUser",
    value: function() {
      var _exportUser = _asyncToGenerator(import_regenerator.default.mark(function _callee31(userID, options) {
        return import_regenerator.default.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return this.get(this.baseURL + "/users/".concat(userID, "/export"), _objectSpread({}, options));
              case 2:
                return _context31.abrupt("return", _context31.sent);
              case 3:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));
      function exportUser(_x37, _x38) {
        return _exportUser.apply(this, arguments);
      }
      return exportUser;
    }()
  }, {
    key: "banUser",
    value: function() {
      var _banUser = _asyncToGenerator(import_regenerator.default.mark(function _callee32(targetUserID, options) {
        return import_regenerator.default.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.post(this.baseURL + "/moderation/ban", _objectSpread({
                  target_user_id: targetUserID
                }, options));
              case 2:
                return _context32.abrupt("return", _context32.sent);
              case 3:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));
      function banUser(_x39, _x40) {
        return _banUser.apply(this, arguments);
      }
      return banUser;
    }()
  }, {
    key: "unbanUser",
    value: function() {
      var _unbanUser = _asyncToGenerator(import_regenerator.default.mark(function _callee33(targetUserID, options) {
        return import_regenerator.default.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.delete(this.baseURL + "/moderation/ban", _objectSpread({
                  target_user_id: targetUserID
                }, options));
              case 2:
                return _context33.abrupt("return", _context33.sent);
              case 3:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));
      function unbanUser(_x41, _x42) {
        return _unbanUser.apply(this, arguments);
      }
      return unbanUser;
    }()
  }, {
    key: "shadowBan",
    value: function() {
      var _shadowBan = _asyncToGenerator(import_regenerator.default.mark(function _callee34(targetUserID, options) {
        return import_regenerator.default.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.banUser(targetUserID, _objectSpread({
                  shadow: true
                }, options));
              case 2:
                return _context34.abrupt("return", _context34.sent);
              case 3:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));
      function shadowBan(_x43, _x44) {
        return _shadowBan.apply(this, arguments);
      }
      return shadowBan;
    }()
  }, {
    key: "removeShadowBan",
    value: function() {
      var _removeShadowBan = _asyncToGenerator(import_regenerator.default.mark(function _callee35(targetUserID, options) {
        return import_regenerator.default.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return this.unbanUser(targetUserID, _objectSpread({
                  shadow: true
                }, options));
              case 2:
                return _context35.abrupt("return", _context35.sent);
              case 3:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));
      function removeShadowBan(_x45, _x46) {
        return _removeShadowBan.apply(this, arguments);
      }
      return removeShadowBan;
    }()
  }, {
    key: "muteUser",
    value: function() {
      var _muteUser = _asyncToGenerator(import_regenerator.default.mark(function _callee36(targetID, userID) {
        var options, _args36 = arguments;
        return import_regenerator.default.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                options = _args36.length > 2 && _args36[2] !== void 0 ? _args36[2] : {};
                _context36.next = 3;
                return this.post(this.baseURL + "/moderation/mute", _objectSpread(_objectSpread({
                  target_id: targetID
                }, userID ? {
                  user_id: userID
                } : {}), options));
              case 3:
                return _context36.abrupt("return", _context36.sent);
              case 4:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));
      function muteUser(_x47, _x48) {
        return _muteUser.apply(this, arguments);
      }
      return muteUser;
    }()
  }, {
    key: "unmuteUser",
    value: function() {
      var _unmuteUser = _asyncToGenerator(import_regenerator.default.mark(function _callee37(targetID, currentUserID) {
        return import_regenerator.default.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                _context37.next = 2;
                return this.post(this.baseURL + "/moderation/unmute", _objectSpread({
                  target_id: targetID
                }, currentUserID ? {
                  user_id: currentUserID
                } : {}));
              case 2:
                return _context37.abrupt("return", _context37.sent);
              case 3:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));
      function unmuteUser(_x49, _x50) {
        return _unmuteUser.apply(this, arguments);
      }
      return unmuteUser;
    }()
  }, {
    key: "userMuteStatus",
    value: function userMuteStatus(targetID) {
      if (!this.user || !this.wsPromise) {
        throw new Error("Make sure to await connectUser() first.");
      }
      for (var i = 0; i < this.mutedUsers.length; i += 1) {
        if (this.mutedUsers[i].target.id === targetID)
          return true;
      }
      return false;
    }
  }, {
    key: "flagMessage",
    value: function() {
      var _flagMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee38(targetMessageID) {
        var options, _args38 = arguments;
        return import_regenerator.default.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                options = _args38.length > 1 && _args38[1] !== void 0 ? _args38[1] : {};
                _context38.next = 3;
                return this.post(this.baseURL + "/moderation/flag", _objectSpread({
                  target_message_id: targetMessageID
                }, options));
              case 3:
                return _context38.abrupt("return", _context38.sent);
              case 4:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));
      function flagMessage(_x51) {
        return _flagMessage.apply(this, arguments);
      }
      return flagMessage;
    }()
  }, {
    key: "flagUser",
    value: function() {
      var _flagUser = _asyncToGenerator(import_regenerator.default.mark(function _callee39(targetID) {
        var options, _args39 = arguments;
        return import_regenerator.default.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                options = _args39.length > 1 && _args39[1] !== void 0 ? _args39[1] : {};
                _context39.next = 3;
                return this.post(this.baseURL + "/moderation/flag", _objectSpread({
                  target_user_id: targetID
                }, options));
              case 3:
                return _context39.abrupt("return", _context39.sent);
              case 4:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));
      function flagUser(_x52) {
        return _flagUser.apply(this, arguments);
      }
      return flagUser;
    }()
  }, {
    key: "unflagMessage",
    value: function() {
      var _unflagMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee40(targetMessageID) {
        var options, _args40 = arguments;
        return import_regenerator.default.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                options = _args40.length > 1 && _args40[1] !== void 0 ? _args40[1] : {};
                _context40.next = 3;
                return this.post(this.baseURL + "/moderation/unflag", _objectSpread({
                  target_message_id: targetMessageID
                }, options));
              case 3:
                return _context40.abrupt("return", _context40.sent);
              case 4:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));
      function unflagMessage(_x53) {
        return _unflagMessage.apply(this, arguments);
      }
      return unflagMessage;
    }()
  }, {
    key: "unflagUser",
    value: function() {
      var _unflagUser = _asyncToGenerator(import_regenerator.default.mark(function _callee41(targetID) {
        var options, _args41 = arguments;
        return import_regenerator.default.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                options = _args41.length > 1 && _args41[1] !== void 0 ? _args41[1] : {};
                _context41.next = 3;
                return this.post(this.baseURL + "/moderation/unflag", _objectSpread({
                  target_user_id: targetID
                }, options));
              case 3:
                return _context41.abrupt("return", _context41.sent);
              case 4:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));
      function unflagUser(_x54) {
        return _unflagUser.apply(this, arguments);
      }
      return unflagUser;
    }()
  }, {
    key: "getCallToken",
    value: function() {
      var _getCallToken = _asyncToGenerator(import_regenerator.default.mark(function _callee42(callID) {
        var options, _args42 = arguments;
        return import_regenerator.default.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                options = _args42.length > 1 && _args42[1] !== void 0 ? _args42[1] : {};
                _context42.next = 3;
                return this.post(this.baseURL + "/calls/".concat(callID), _objectSpread({}, options));
              case 3:
                return _context42.abrupt("return", _context42.sent);
              case 4:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));
      function getCallToken(_x55) {
        return _getCallToken.apply(this, arguments);
      }
      return getCallToken;
    }()
  }, {
    key: "_queryFlags",
    value: function() {
      var _queryFlags2 = _asyncToGenerator(import_regenerator.default.mark(function _callee43() {
        var filterConditions, options, _args43 = arguments;
        return import_regenerator.default.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                filterConditions = _args43.length > 0 && _args43[0] !== void 0 ? _args43[0] : {};
                options = _args43.length > 1 && _args43[1] !== void 0 ? _args43[1] : {};
                _context43.next = 4;
                return this.post(this.baseURL + "/moderation/flags", _objectSpread({
                  filter_conditions: filterConditions
                }, options));
              case 4:
                return _context43.abrupt("return", _context43.sent);
              case 5:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));
      function _queryFlags() {
        return _queryFlags2.apply(this, arguments);
      }
      return _queryFlags;
    }()
  }, {
    key: "_queryFlagReports",
    value: function() {
      var _queryFlagReports2 = _asyncToGenerator(import_regenerator.default.mark(function _callee44() {
        var filterConditions, options, _args44 = arguments;
        return import_regenerator.default.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                filterConditions = _args44.length > 0 && _args44[0] !== void 0 ? _args44[0] : {};
                options = _args44.length > 1 && _args44[1] !== void 0 ? _args44[1] : {};
                _context44.next = 4;
                return this.post(this.baseURL + "/moderation/reports", _objectSpread({
                  filter_conditions: filterConditions
                }, options));
              case 4:
                return _context44.abrupt("return", _context44.sent);
              case 5:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));
      function _queryFlagReports() {
        return _queryFlagReports2.apply(this, arguments);
      }
      return _queryFlagReports;
    }()
  }, {
    key: "_reviewFlagReport",
    value: function() {
      var _reviewFlagReport2 = _asyncToGenerator(import_regenerator.default.mark(function _callee45(id, reviewResult) {
        var options, _args45 = arguments;
        return import_regenerator.default.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                options = _args45.length > 2 && _args45[2] !== void 0 ? _args45[2] : {};
                _context45.next = 3;
                return this.patch(this.baseURL + "/moderation/reports/".concat(id), _objectSpread({
                  review_result: reviewResult
                }, options));
              case 3:
                return _context45.abrupt("return", _context45.sent);
              case 4:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));
      function _reviewFlagReport(_x56, _x57) {
        return _reviewFlagReport2.apply(this, arguments);
      }
      return _reviewFlagReport;
    }()
  }, {
    key: "_unblockMessage",
    value: function() {
      var _unblockMessage2 = _asyncToGenerator(import_regenerator.default.mark(function _callee46(targetMessageID) {
        var options, _args46 = arguments;
        return import_regenerator.default.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                options = _args46.length > 1 && _args46[1] !== void 0 ? _args46[1] : {};
                _context46.next = 3;
                return this.post(this.baseURL + "/moderation/unblock_message", _objectSpread({
                  target_message_id: targetMessageID
                }, options));
              case 3:
                return _context46.abrupt("return", _context46.sent);
              case 4:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));
      function _unblockMessage(_x58) {
        return _unblockMessage2.apply(this, arguments);
      }
      return _unblockMessage;
    }()
  }, {
    key: "markChannelsRead",
    value: function() {
      var _markChannelsRead = _asyncToGenerator(import_regenerator.default.mark(function _callee47() {
        var data, _args47 = arguments;
        return import_regenerator.default.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                data = _args47.length > 0 && _args47[0] !== void 0 ? _args47[0] : {};
                _context47.next = 3;
                return this.post(this.baseURL + "/channels/read", _objectSpread({}, data));
              case 3:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));
      function markChannelsRead() {
        return _markChannelsRead.apply(this, arguments);
      }
      return markChannelsRead;
    }()
  }, {
    key: "createCommand",
    value: function createCommand(data) {
      return this.post(this.baseURL + "/commands", data);
    }
  }, {
    key: "getCommand",
    value: function getCommand(name) {
      return this.get(this.baseURL + "/commands/".concat(name));
    }
  }, {
    key: "updateCommand",
    value: function updateCommand(name, data) {
      return this.put(this.baseURL + "/commands/".concat(name), data);
    }
  }, {
    key: "deleteCommand",
    value: function deleteCommand(name) {
      return this.delete(this.baseURL + "/commands/".concat(name));
    }
  }, {
    key: "listCommands",
    value: function listCommands() {
      return this.get(this.baseURL + "/commands");
    }
  }, {
    key: "createChannelType",
    value: function createChannelType(data) {
      var channelData = _extends({}, {
        commands: ["all"]
      }, data);
      return this.post(this.baseURL + "/channeltypes", channelData);
    }
  }, {
    key: "getChannelType",
    value: function getChannelType(channelType) {
      return this.get(this.baseURL + "/channeltypes/".concat(channelType));
    }
  }, {
    key: "updateChannelType",
    value: function updateChannelType(channelType, data) {
      return this.put(this.baseURL + "/channeltypes/".concat(channelType), data);
    }
  }, {
    key: "deleteChannelType",
    value: function deleteChannelType(channelType) {
      return this.delete(this.baseURL + "/channeltypes/".concat(channelType));
    }
  }, {
    key: "listChannelTypes",
    value: function listChannelTypes() {
      return this.get(this.baseURL + "/channeltypes");
    }
  }, {
    key: "translateMessage",
    value: function() {
      var _translateMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee48(messageId, language) {
        return import_regenerator.default.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                _context48.next = 2;
                return this.post(this.baseURL + "/messages/".concat(messageId, "/translate"), {
                  language
                });
              case 2:
                return _context48.abrupt("return", _context48.sent);
              case 3:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));
      function translateMessage(_x59, _x60) {
        return _translateMessage.apply(this, arguments);
      }
      return translateMessage;
    }()
  }, {
    key: "_normalizeExpiration",
    value: function _normalizeExpiration(timeoutOrExpirationDate) {
      var pinExpires = null;
      if (typeof timeoutOrExpirationDate === "number") {
        var now = new Date();
        now.setSeconds(now.getSeconds() + timeoutOrExpirationDate);
        pinExpires = now.toISOString();
      } else if (isString(timeoutOrExpirationDate)) {
        pinExpires = timeoutOrExpirationDate;
      } else if (timeoutOrExpirationDate instanceof Date) {
        pinExpires = timeoutOrExpirationDate.toISOString();
      }
      return pinExpires;
    }
  }, {
    key: "_validateAndGetMessageId",
    value: function _validateAndGetMessageId(messageOrMessageId, errorText) {
      var messageId;
      if (typeof messageOrMessageId === "string") {
        messageId = messageOrMessageId;
      } else {
        if (!messageOrMessageId.id) {
          throw Error(errorText);
        }
        messageId = messageOrMessageId.id;
      }
      return messageId;
    }
  }, {
    key: "pinMessage",
    value: function pinMessage(messageOrMessageId, timeoutOrExpirationDate, pinnedBy, pinnedAt) {
      var messageId = this._validateAndGetMessageId(messageOrMessageId, "Please specify the message id when calling unpinMessage");
      return this.partialUpdateMessage(messageId, {
        set: {
          pinned: true,
          pin_expires: this._normalizeExpiration(timeoutOrExpirationDate),
          pinned_at: this._normalizeExpiration(pinnedAt)
        }
      }, pinnedBy);
    }
  }, {
    key: "unpinMessage",
    value: function unpinMessage(messageOrMessageId, userId) {
      var messageId = this._validateAndGetMessageId(messageOrMessageId, "Please specify the message id when calling unpinMessage");
      return this.partialUpdateMessage(messageId, {
        set: {
          pinned: false
        }
      }, userId);
    }
  }, {
    key: "updateMessage",
    value: function() {
      var _updateMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee49(message, userId, options) {
        var clonedMessage, reservedMessageFields;
        return import_regenerator.default.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                if (message.id) {
                  _context49.next = 2;
                  break;
                }
                throw Error("Please specify the message id when calling updateMessage");
              case 2:
                clonedMessage = _extends({}, message);
                delete clonedMessage.id;
                reservedMessageFields = ["command", "created_at", "html", "latest_reactions", "own_reactions", "quoted_message", "reaction_counts", "reply_count", "type", "updated_at", "user", "__html"];
                reservedMessageFields.forEach(function(item) {
                  if (clonedMessage[item] != null) {
                    delete clonedMessage[item];
                  }
                });
                if (userId != null) {
                  if (isString(userId)) {
                    clonedMessage.user_id = userId;
                  } else {
                    clonedMessage.user = {
                      id: userId.id
                    };
                  }
                }
                if (Array.isArray(clonedMessage.mentioned_users) && !isString(clonedMessage.mentioned_users[0])) {
                  clonedMessage.mentioned_users = clonedMessage.mentioned_users.map(function(mu) {
                    return mu.id;
                  });
                }
                _context49.next = 10;
                return this.post(this.baseURL + "/messages/".concat(message.id), _objectSpread({
                  message: clonedMessage
                }, options));
              case 10:
                return _context49.abrupt("return", _context49.sent);
              case 11:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));
      function updateMessage(_x61, _x62, _x63) {
        return _updateMessage.apply(this, arguments);
      }
      return updateMessage;
    }()
  }, {
    key: "partialUpdateMessage",
    value: function() {
      var _partialUpdateMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee50(id, partialMessageObject, userId, options) {
        var user;
        return import_regenerator.default.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                if (id) {
                  _context50.next = 2;
                  break;
                }
                throw Error("Please specify the message id when calling partialUpdateMessage");
              case 2:
                user = userId;
                if (userId != null && isString(userId)) {
                  user = {
                    id: userId
                  };
                }
                _context50.next = 6;
                return this.put(this.baseURL + "/messages/".concat(id), _objectSpread(_objectSpread(_objectSpread({}, partialMessageObject), options), {}, {
                  user
                }));
              case 6:
                return _context50.abrupt("return", _context50.sent);
              case 7:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));
      function partialUpdateMessage(_x64, _x65, _x66, _x67) {
        return _partialUpdateMessage.apply(this, arguments);
      }
      return partialUpdateMessage;
    }()
  }, {
    key: "deleteMessage",
    value: function() {
      var _deleteMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee51(messageID, hardDelete) {
        var params;
        return import_regenerator.default.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                params = {};
                if (hardDelete) {
                  params = {
                    hard: true
                  };
                }
                _context51.next = 4;
                return this.delete(this.baseURL + "/messages/".concat(messageID), params);
              case 4:
                return _context51.abrupt("return", _context51.sent);
              case 5:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));
      function deleteMessage(_x68, _x69) {
        return _deleteMessage.apply(this, arguments);
      }
      return deleteMessage;
    }()
  }, {
    key: "getMessage",
    value: function() {
      var _getMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee52(messageID) {
        return import_regenerator.default.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                _context52.next = 2;
                return this.get(this.baseURL + "/messages/".concat(messageID));
              case 2:
                return _context52.abrupt("return", _context52.sent);
              case 3:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this);
      }));
      function getMessage(_x70) {
        return _getMessage.apply(this, arguments);
      }
      return getMessage;
    }()
  }, {
    key: "getUserAgent",
    value: function getUserAgent() {
      return this.userAgent || "stream-chat-javascript-client-".concat(this.node ? "node" : "browser", "-", "6.9.0");
    }
  }, {
    key: "setUserAgent",
    value: function setUserAgent(userAgent) {
      this.userAgent = userAgent;
    }
  }, {
    key: "_enrichAxiosOptions",
    value: function _enrichAxiosOptions() {
      var _options$headers;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        params: {},
        headers: {},
        config: {}
      };
      var token = this._getToken();
      var authorization = token ? {
        Authorization: token
      } : void 0;
      if (!((_options$headers = options.headers) !== null && _options$headers !== void 0 && _options$headers["x-client-request-id"])) {
        options.headers = _objectSpread(_objectSpread({}, options.headers), {}, {
          "x-client-request-id": randomId()
        });
      }
      return _objectSpread({
        params: _objectSpread({
          user_id: this.userID,
          connection_id: this._getConnectionID(),
          api_key: this.key
        }, options.params),
        headers: _objectSpread(_objectSpread({}, authorization), {}, {
          "stream-auth-type": this.getAuthType(),
          "X-Stream-Client": this.getUserAgent()
        }, options.headers)
      }, options.config);
    }
  }, {
    key: "_getToken",
    value: function _getToken() {
      if (!this.tokenManager || this.anonymous)
        return null;
      return this.tokenManager.getToken();
    }
  }, {
    key: "_startCleaning",
    value: function _startCleaning() {
      var that = this;
      if (this.cleaningIntervalRef != null) {
        return;
      }
      this.cleaningIntervalRef = setInterval(function() {
        for (var _i3 = 0, _Object$values2 = Object.values(that.activeChannels); _i3 < _Object$values2.length; _i3++) {
          var _channel7 = _Object$values2[_i3];
          _channel7.clean();
        }
      }, 500);
    }
  }, {
    key: "verifyWebhook",
    value: function verifyWebhook(requestBody, xSignature) {
      return !!this.secret && CheckSignature(requestBody, this.secret, xSignature);
    }
  }, {
    key: "getPermission",
    value: function getPermission(name) {
      return this.get("".concat(this.baseURL, "/permissions/").concat(name));
    }
  }, {
    key: "createPermission",
    value: function createPermission(permissionData) {
      return this.post("".concat(this.baseURL, "/permissions"), _objectSpread({}, permissionData));
    }
  }, {
    key: "updatePermission",
    value: function updatePermission(id, permissionData) {
      return this.put("".concat(this.baseURL, "/permissions/").concat(id), _objectSpread({}, permissionData));
    }
  }, {
    key: "deletePermission",
    value: function deletePermission(name) {
      return this.delete("".concat(this.baseURL, "/permissions/").concat(name));
    }
  }, {
    key: "listPermissions",
    value: function listPermissions() {
      return this.get("".concat(this.baseURL, "/permissions"));
    }
  }, {
    key: "createRole",
    value: function createRole(name) {
      return this.post("".concat(this.baseURL, "/roles"), {
        name
      });
    }
  }, {
    key: "listRoles",
    value: function listRoles() {
      return this.get("".concat(this.baseURL, "/roles"));
    }
  }, {
    key: "deleteRole",
    value: function deleteRole(name) {
      return this.delete("".concat(this.baseURL, "/roles/").concat(name));
    }
  }, {
    key: "sync",
    value: function sync(channel_cids, last_sync_at) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.post("".concat(this.baseURL, "/sync"), _objectSpread({
        channel_cids,
        last_sync_at
      }, options));
    }
  }, {
    key: "sendUserCustomEvent",
    value: function() {
      var _sendUserCustomEvent = _asyncToGenerator(import_regenerator.default.mark(function _callee53(targetUserID, event) {
        return import_regenerator.default.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                _context53.next = 2;
                return this.post("".concat(this.baseURL, "/users/").concat(targetUserID, "/event"), {
                  event
                });
              case 2:
                return _context53.abrupt("return", _context53.sent);
              case 3:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this);
      }));
      function sendUserCustomEvent(_x71, _x72) {
        return _sendUserCustomEvent.apply(this, arguments);
      }
      return sendUserCustomEvent;
    }()
  }, {
    key: "createBlockList",
    value: function createBlockList(blockList) {
      return this.post("".concat(this.baseURL, "/blocklists"), blockList);
    }
  }, {
    key: "listBlockLists",
    value: function listBlockLists() {
      return this.get("".concat(this.baseURL, "/blocklists"));
    }
  }, {
    key: "getBlockList",
    value: function getBlockList(name) {
      return this.get("".concat(this.baseURL, "/blocklists/").concat(name));
    }
  }, {
    key: "updateBlockList",
    value: function updateBlockList(name, data) {
      return this.put("".concat(this.baseURL, "/blocklists/").concat(name), data);
    }
  }, {
    key: "deleteBlockList",
    value: function deleteBlockList(name) {
      return this.delete("".concat(this.baseURL, "/blocklists/").concat(name));
    }
  }, {
    key: "exportChannels",
    value: function exportChannels(request) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var payload = _objectSpread({
        channels: request
      }, options);
      return this.post("".concat(this.baseURL, "/export_channels"), payload);
    }
  }, {
    key: "exportUsers",
    value: function exportUsers(request) {
      return this.post("".concat(this.baseURL, "/export/users"), request);
    }
  }, {
    key: "exportChannel",
    value: function exportChannel(request, options) {
      return this.exportChannels([request], options);
    }
  }, {
    key: "getExportChannelStatus",
    value: function getExportChannelStatus(id) {
      return this.get("".concat(this.baseURL, "/export_channels/").concat(id));
    }
  }, {
    key: "createSegment",
    value: function() {
      var _createSegment = _asyncToGenerator(import_regenerator.default.mark(function _callee54(params) {
        var _yield$this$post, segment;
        return import_regenerator.default.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                _context54.next = 2;
                return this.post(this.baseURL + "/segments", {
                  segment: params
                });
              case 2:
                _yield$this$post = _context54.sent;
                segment = _yield$this$post.segment;
                return _context54.abrupt("return", segment);
              case 5:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));
      function createSegment(_x73) {
        return _createSegment.apply(this, arguments);
      }
      return createSegment;
    }()
  }, {
    key: "getSegment",
    value: function() {
      var _getSegment = _asyncToGenerator(import_regenerator.default.mark(function _callee55(id) {
        var _yield$this$get, segment;
        return import_regenerator.default.wrap(function _callee55$(_context55) {
          while (1) {
            switch (_context55.prev = _context55.next) {
              case 0:
                _context55.next = 2;
                return this.get(this.baseURL + "/segments/".concat(id));
              case 2:
                _yield$this$get = _context55.sent;
                segment = _yield$this$get.segment;
                return _context55.abrupt("return", segment);
              case 5:
              case "end":
                return _context55.stop();
            }
          }
        }, _callee55, this);
      }));
      function getSegment(_x74) {
        return _getSegment.apply(this, arguments);
      }
      return getSegment;
    }()
  }, {
    key: "listSegments",
    value: function() {
      var _listSegments = _asyncToGenerator(import_regenerator.default.mark(function _callee56(options) {
        var _yield$this$get2, segments;
        return import_regenerator.default.wrap(function _callee56$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                _context56.next = 2;
                return this.get(this.baseURL + "/segments", options);
              case 2:
                _yield$this$get2 = _context56.sent;
                segments = _yield$this$get2.segments;
                return _context56.abrupt("return", segments);
              case 5:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee56, this);
      }));
      function listSegments(_x75) {
        return _listSegments.apply(this, arguments);
      }
      return listSegments;
    }()
  }, {
    key: "updateSegment",
    value: function() {
      var _updateSegment = _asyncToGenerator(import_regenerator.default.mark(function _callee57(id, params) {
        var _yield$this$put, segment;
        return import_regenerator.default.wrap(function _callee57$(_context57) {
          while (1) {
            switch (_context57.prev = _context57.next) {
              case 0:
                _context57.next = 2;
                return this.put(this.baseURL + "/segments/".concat(id), {
                  segment: params
                });
              case 2:
                _yield$this$put = _context57.sent;
                segment = _yield$this$put.segment;
                return _context57.abrupt("return", segment);
              case 5:
              case "end":
                return _context57.stop();
            }
          }
        }, _callee57, this);
      }));
      function updateSegment(_x76, _x77) {
        return _updateSegment.apply(this, arguments);
      }
      return updateSegment;
    }()
  }, {
    key: "deleteSegment",
    value: function() {
      var _deleteSegment = _asyncToGenerator(import_regenerator.default.mark(function _callee58(id) {
        return import_regenerator.default.wrap(function _callee58$(_context58) {
          while (1) {
            switch (_context58.prev = _context58.next) {
              case 0:
                return _context58.abrupt("return", this.delete(this.baseURL + "/segments/".concat(id)));
              case 1:
              case "end":
                return _context58.stop();
            }
          }
        }, _callee58, this);
      }));
      function deleteSegment(_x78) {
        return _deleteSegment.apply(this, arguments);
      }
      return deleteSegment;
    }()
  }, {
    key: "createCampaign",
    value: function() {
      var _createCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee59(params) {
        var _yield$this$post2, campaign;
        return import_regenerator.default.wrap(function _callee59$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                _context59.next = 2;
                return this.post(this.baseURL + "/campaigns", {
                  campaign: params
                });
              case 2:
                _yield$this$post2 = _context59.sent;
                campaign = _yield$this$post2.campaign;
                return _context59.abrupt("return", campaign);
              case 5:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee59, this);
      }));
      function createCampaign(_x79) {
        return _createCampaign.apply(this, arguments);
      }
      return createCampaign;
    }()
  }, {
    key: "getCampaign",
    value: function() {
      var _getCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee60(id) {
        var _yield$this$get3, campaign;
        return import_regenerator.default.wrap(function _callee60$(_context60) {
          while (1) {
            switch (_context60.prev = _context60.next) {
              case 0:
                _context60.next = 2;
                return this.get(this.baseURL + "/campaigns/".concat(id));
              case 2:
                _yield$this$get3 = _context60.sent;
                campaign = _yield$this$get3.campaign;
                return _context60.abrupt("return", campaign);
              case 5:
              case "end":
                return _context60.stop();
            }
          }
        }, _callee60, this);
      }));
      function getCampaign(_x80) {
        return _getCampaign.apply(this, arguments);
      }
      return getCampaign;
    }()
  }, {
    key: "listCampaigns",
    value: function() {
      var _listCampaigns = _asyncToGenerator(import_regenerator.default.mark(function _callee61(options) {
        var _yield$this$get4, campaigns;
        return import_regenerator.default.wrap(function _callee61$(_context61) {
          while (1) {
            switch (_context61.prev = _context61.next) {
              case 0:
                _context61.next = 2;
                return this.get(this.baseURL + "/campaigns", options);
              case 2:
                _yield$this$get4 = _context61.sent;
                campaigns = _yield$this$get4.campaigns;
                return _context61.abrupt("return", campaigns);
              case 5:
              case "end":
                return _context61.stop();
            }
          }
        }, _callee61, this);
      }));
      function listCampaigns(_x81) {
        return _listCampaigns.apply(this, arguments);
      }
      return listCampaigns;
    }()
  }, {
    key: "updateCampaign",
    value: function() {
      var _updateCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee62(id, params) {
        var _yield$this$put2, campaign;
        return import_regenerator.default.wrap(function _callee62$(_context62) {
          while (1) {
            switch (_context62.prev = _context62.next) {
              case 0:
                _context62.next = 2;
                return this.put(this.baseURL + "/campaigns/".concat(id), {
                  campaign: params
                });
              case 2:
                _yield$this$put2 = _context62.sent;
                campaign = _yield$this$put2.campaign;
                return _context62.abrupt("return", campaign);
              case 5:
              case "end":
                return _context62.stop();
            }
          }
        }, _callee62, this);
      }));
      function updateCampaign(_x82, _x83) {
        return _updateCampaign.apply(this, arguments);
      }
      return updateCampaign;
    }()
  }, {
    key: "deleteCampaign",
    value: function() {
      var _deleteCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee63(id) {
        return import_regenerator.default.wrap(function _callee63$(_context63) {
          while (1) {
            switch (_context63.prev = _context63.next) {
              case 0:
                return _context63.abrupt("return", this.delete(this.baseURL + "/campaigns/".concat(id)));
              case 1:
              case "end":
                return _context63.stop();
            }
          }
        }, _callee63, this);
      }));
      function deleteCampaign(_x84) {
        return _deleteCampaign.apply(this, arguments);
      }
      return deleteCampaign;
    }()
  }, {
    key: "scheduleCampaign",
    value: function() {
      var _scheduleCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee64(id, params) {
        var scheduledFor, _yield$this$patch, campaign;
        return import_regenerator.default.wrap(function _callee64$(_context64) {
          while (1) {
            switch (_context64.prev = _context64.next) {
              case 0:
                scheduledFor = params.scheduledFor;
                _context64.next = 3;
                return this.patch(this.baseURL + "/campaigns/".concat(id, "/schedule"), {
                  scheduled_for: scheduledFor
                });
              case 3:
                _yield$this$patch = _context64.sent;
                campaign = _yield$this$patch.campaign;
                return _context64.abrupt("return", campaign);
              case 6:
              case "end":
                return _context64.stop();
            }
          }
        }, _callee64, this);
      }));
      function scheduleCampaign(_x85, _x86) {
        return _scheduleCampaign.apply(this, arguments);
      }
      return scheduleCampaign;
    }()
  }, {
    key: "stopCampaign",
    value: function() {
      var _stopCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee65(id) {
        var _yield$this$patch2, campaign;
        return import_regenerator.default.wrap(function _callee65$(_context65) {
          while (1) {
            switch (_context65.prev = _context65.next) {
              case 0:
                _context65.next = 2;
                return this.patch(this.baseURL + "/campaigns/".concat(id, "/stop"));
              case 2:
                _yield$this$patch2 = _context65.sent;
                campaign = _yield$this$patch2.campaign;
                return _context65.abrupt("return", campaign);
              case 5:
              case "end":
                return _context65.stop();
            }
          }
        }, _callee65, this);
      }));
      function stopCampaign(_x87) {
        return _stopCampaign.apply(this, arguments);
      }
      return stopCampaign;
    }()
  }, {
    key: "resumeCampaign",
    value: function() {
      var _resumeCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee66(id) {
        var _yield$this$patch3, campaign;
        return import_regenerator.default.wrap(function _callee66$(_context66) {
          while (1) {
            switch (_context66.prev = _context66.next) {
              case 0:
                _context66.next = 2;
                return this.patch(this.baseURL + "/campaigns/".concat(id, "/resume"));
              case 2:
                _yield$this$patch3 = _context66.sent;
                campaign = _yield$this$patch3.campaign;
                return _context66.abrupt("return", campaign);
              case 5:
              case "end":
                return _context66.stop();
            }
          }
        }, _callee66, this);
      }));
      function resumeCampaign(_x88) {
        return _resumeCampaign.apply(this, arguments);
      }
      return resumeCampaign;
    }()
  }, {
    key: "testCampaign",
    value: function() {
      var _testCampaign = _asyncToGenerator(import_regenerator.default.mark(function _callee67(id, params) {
        var users;
        return import_regenerator.default.wrap(function _callee67$(_context67) {
          while (1) {
            switch (_context67.prev = _context67.next) {
              case 0:
                users = params.users;
                _context67.next = 3;
                return this.post(this.baseURL + "/campaigns/".concat(id, "/test"), {
                  users
                });
              case 3:
                return _context67.abrupt("return", _context67.sent);
              case 4:
              case "end":
                return _context67.stop();
            }
          }
        }, _callee67, this);
      }));
      function testCampaign(_x89, _x90) {
        return _testCampaign.apply(this, arguments);
      }
      return testCampaign;
    }()
  }, {
    key: "enrichURL",
    value: function() {
      var _enrichURL = _asyncToGenerator(import_regenerator.default.mark(function _callee68(url) {
        return import_regenerator.default.wrap(function _callee68$(_context68) {
          while (1) {
            switch (_context68.prev = _context68.next) {
              case 0:
                return _context68.abrupt("return", this.get(this.baseURL + "/og", {
                  url
                }));
              case 1:
              case "end":
                return _context68.stop();
            }
          }
        }, _callee68, this);
      }));
      function enrichURL(_x91) {
        return _enrichURL.apply(this, arguments);
      }
      return enrichURL;
    }()
  }, {
    key: "getTask",
    value: function() {
      var _getTask = _asyncToGenerator(import_regenerator.default.mark(function _callee69(id) {
        return import_regenerator.default.wrap(function _callee69$(_context69) {
          while (1) {
            switch (_context69.prev = _context69.next) {
              case 0:
                return _context69.abrupt("return", this.get("".concat(this.baseURL, "/tasks/").concat(id)));
              case 1:
              case "end":
                return _context69.stop();
            }
          }
        }, _callee69, this);
      }));
      function getTask(_x92) {
        return _getTask.apply(this, arguments);
      }
      return getTask;
    }()
  }, {
    key: "deleteChannels",
    value: function() {
      var _deleteChannels = _asyncToGenerator(import_regenerator.default.mark(function _callee70(cids) {
        var options, _args70 = arguments;
        return import_regenerator.default.wrap(function _callee70$(_context70) {
          while (1) {
            switch (_context70.prev = _context70.next) {
              case 0:
                options = _args70.length > 1 && _args70[1] !== void 0 ? _args70[1] : {};
                _context70.next = 3;
                return this.post(this.baseURL + "/channels/delete", _objectSpread({
                  cids
                }, options));
              case 3:
                return _context70.abrupt("return", _context70.sent);
              case 4:
              case "end":
                return _context70.stop();
            }
          }
        }, _callee70, this);
      }));
      function deleteChannels(_x93) {
        return _deleteChannels.apply(this, arguments);
      }
      return deleteChannels;
    }()
  }, {
    key: "deleteUsers",
    value: function() {
      var _deleteUsers = _asyncToGenerator(import_regenerator.default.mark(function _callee71(user_ids, options) {
        return import_regenerator.default.wrap(function _callee71$(_context71) {
          while (1) {
            switch (_context71.prev = _context71.next) {
              case 0:
                if (!((options === null || options === void 0 ? void 0 : options.user) !== "soft" && (options === null || options === void 0 ? void 0 : options.user) !== "hard")) {
                  _context71.next = 2;
                  break;
                }
                throw new Error("Invalid delete user options. user must be one of [soft hard]");
              case 2:
                if (!(options.messages !== void 0 && options.messages !== "soft" && options.messages !== "hard")) {
                  _context71.next = 4;
                  break;
                }
                throw new Error("Invalid delete user options. messages must be one of [soft hard]");
              case 4:
                if (!(options.conversations !== void 0 && options.conversations !== "soft" && options.conversations !== "hard")) {
                  _context71.next = 6;
                  break;
                }
                throw new Error("Invalid delete user options. conversations must be one of [soft hard]");
              case 6:
                _context71.next = 8;
                return this.post(this.baseURL + "/users/delete", _objectSpread({
                  user_ids
                }, options));
              case 8:
                return _context71.abrupt("return", _context71.sent);
              case 9:
              case "end":
                return _context71.stop();
            }
          }
        }, _callee71, this);
      }));
      function deleteUsers(_x94, _x95) {
        return _deleteUsers.apply(this, arguments);
      }
      return deleteUsers;
    }()
  }, {
    key: "_createImportURL",
    value: function() {
      var _createImportURL2 = _asyncToGenerator(import_regenerator.default.mark(function _callee72(filename) {
        return import_regenerator.default.wrap(function _callee72$(_context72) {
          while (1) {
            switch (_context72.prev = _context72.next) {
              case 0:
                _context72.next = 2;
                return this.post(this.baseURL + "/import_urls", {
                  filename
                });
              case 2:
                return _context72.abrupt("return", _context72.sent);
              case 3:
              case "end":
                return _context72.stop();
            }
          }
        }, _callee72, this);
      }));
      function _createImportURL(_x96) {
        return _createImportURL2.apply(this, arguments);
      }
      return _createImportURL;
    }()
  }, {
    key: "_createImport",
    value: function() {
      var _createImport2 = _asyncToGenerator(import_regenerator.default.mark(function _callee73(path) {
        var options, _args73 = arguments;
        return import_regenerator.default.wrap(function _callee73$(_context73) {
          while (1) {
            switch (_context73.prev = _context73.next) {
              case 0:
                options = _args73.length > 1 && _args73[1] !== void 0 ? _args73[1] : {
                  mode: "upsert"
                };
                _context73.next = 3;
                return this.post(this.baseURL + "/imports", _objectSpread({
                  path
                }, options));
              case 3:
                return _context73.abrupt("return", _context73.sent);
              case 4:
              case "end":
                return _context73.stop();
            }
          }
        }, _callee73, this);
      }));
      function _createImport(_x97) {
        return _createImport2.apply(this, arguments);
      }
      return _createImport;
    }()
  }, {
    key: "_getImport",
    value: function() {
      var _getImport2 = _asyncToGenerator(import_regenerator.default.mark(function _callee74(id) {
        return import_regenerator.default.wrap(function _callee74$(_context74) {
          while (1) {
            switch (_context74.prev = _context74.next) {
              case 0:
                _context74.next = 2;
                return this.get(this.baseURL + "/imports/".concat(id));
              case 2:
                return _context74.abrupt("return", _context74.sent);
              case 3:
              case "end":
                return _context74.stop();
            }
          }
        }, _callee74, this);
      }));
      function _getImport(_x98) {
        return _getImport2.apply(this, arguments);
      }
      return _getImport;
    }()
  }, {
    key: "_listImports",
    value: function() {
      var _listImports2 = _asyncToGenerator(import_regenerator.default.mark(function _callee75(options) {
        return import_regenerator.default.wrap(function _callee75$(_context75) {
          while (1) {
            switch (_context75.prev = _context75.next) {
              case 0:
                _context75.next = 2;
                return this.get(this.baseURL + "/imports", options);
              case 2:
                return _context75.abrupt("return", _context75.sent);
              case 3:
              case "end":
                return _context75.stop();
            }
          }
        }, _callee75, this);
      }));
      function _listImports(_x99) {
        return _listImports2.apply(this, arguments);
      }
      return _listImports;
    }()
  }, {
    key: "upsertPushProvider",
    value: function() {
      var _upsertPushProvider = _asyncToGenerator(import_regenerator.default.mark(function _callee76(pushProvider) {
        return import_regenerator.default.wrap(function _callee76$(_context76) {
          while (1) {
            switch (_context76.prev = _context76.next) {
              case 0:
                _context76.next = 2;
                return this.post(this.baseURL + "/push_providers", {
                  push_provider: pushProvider
                });
              case 2:
                return _context76.abrupt("return", _context76.sent);
              case 3:
              case "end":
                return _context76.stop();
            }
          }
        }, _callee76, this);
      }));
      function upsertPushProvider(_x100) {
        return _upsertPushProvider.apply(this, arguments);
      }
      return upsertPushProvider;
    }()
  }, {
    key: "deletePushProvider",
    value: function() {
      var _deletePushProvider = _asyncToGenerator(import_regenerator.default.mark(function _callee77(_ref8) {
        var type, name;
        return import_regenerator.default.wrap(function _callee77$(_context77) {
          while (1) {
            switch (_context77.prev = _context77.next) {
              case 0:
                type = _ref8.type, name = _ref8.name;
                _context77.next = 3;
                return this.delete(this.baseURL + "/push_providers/".concat(type, "/").concat(name));
              case 3:
                return _context77.abrupt("return", _context77.sent);
              case 4:
              case "end":
                return _context77.stop();
            }
          }
        }, _callee77, this);
      }));
      function deletePushProvider(_x101) {
        return _deletePushProvider.apply(this, arguments);
      }
      return deletePushProvider;
    }()
  }, {
    key: "listPushProviders",
    value: function() {
      var _listPushProviders = _asyncToGenerator(import_regenerator.default.mark(function _callee78() {
        return import_regenerator.default.wrap(function _callee78$(_context78) {
          while (1) {
            switch (_context78.prev = _context78.next) {
              case 0:
                _context78.next = 2;
                return this.get(this.baseURL + "/push_providers");
              case 2:
                return _context78.abrupt("return", _context78.sent);
              case 3:
              case "end":
                return _context78.stop();
            }
          }
        }, _callee78, this);
      }));
      function listPushProviders() {
        return _listPushProviders.apply(this, arguments);
      }
      return listPushProviders;
    }()
  }], [{
    key: "getInstance",
    value: function getInstance(key, secretOrOptions, options) {
      if (!StreamChat2._instance) {
        if (typeof secretOrOptions === "string") {
          StreamChat2._instance = new StreamChat2(key, secretOrOptions, options);
        } else {
          StreamChat2._instance = new StreamChat2(key, secretOrOptions);
        }
      }
      return StreamChat2._instance;
    }
  }]);
  return StreamChat2;
}();
_defineProperty(StreamChat, "_instance", void 0);
var Allow = "Allow";
var Deny = "Deny";
var AnyResource = ["*"];
var AnyRole = ["*"];
var MaxPriority = 999;
var MinPriority = 1;
var Permission = function Permission2(name, priority) {
  var resources = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : AnyResource;
  var roles = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : AnyRole;
  var owner = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var action = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : Allow;
  _classCallCheck(this, Permission2);
  _defineProperty(this, "name", void 0);
  _defineProperty(this, "action", void 0);
  _defineProperty(this, "owner", void 0);
  _defineProperty(this, "priority", void 0);
  _defineProperty(this, "resources", void 0);
  _defineProperty(this, "roles", void 0);
  this.name = name;
  this.action = action;
  this.owner = owner;
  this.priority = priority;
  this.resources = resources;
  this.roles = roles;
};
var AllowAll = new Permission("Allow all", MaxPriority, AnyResource, AnyRole, false, Allow);
var DenyAll = new Permission("Deny all", MinPriority, AnyResource, AnyRole, false, Deny);
var BuiltinRoles = {
  Admin: "admin",
  Anonymous: "anonymous",
  ChannelMember: "channel_member",
  ChannelModerator: "channel_moderator",
  Guest: "guest",
  User: "user"
};
var BuiltinPermissions = {
  AddLinks: "Add Links",
  BanUser: "Ban User",
  CreateChannel: "Create Channel",
  CreateMessage: "Create Message",
  CreateReaction: "Create Reaction",
  DeleteAnyAttachment: "Delete Any Attachment",
  DeleteAnyChannel: "Delete Any Channel",
  DeleteAnyMessage: "Delete Any Message",
  DeleteAnyReaction: "Delete Any Reaction",
  DeleteOwnAttachment: "Delete Own Attachment",
  DeleteOwnChannel: "Delete Own Channel",
  DeleteOwnMessage: "Delete Own Message",
  DeleteOwnReaction: "Delete Own Reaction",
  ReadAnyChannel: "Read Any Channel",
  ReadOwnChannel: "Read Own Channel",
  RunMessageAction: "Run Message Action",
  UpdateAnyChannel: "Update Any Channel",
  UpdateAnyMessage: "Update Any Message",
  UpdateMembersAnyChannel: "Update Members Any Channel",
  UpdateMembersOwnChannel: "Update Members Own Channel",
  UpdateOwnChannel: "Update Own Channel",
  UpdateOwnMessage: "Update Own Message",
  UploadAttachment: "Upload Attachment",
  UseFrozenChannel: "Send messages and reactions to frozen channels"
};

export {
  _typeof,
  _classCallCheck,
  _createClass,
  _assertThisInitialized,
  _inherits,
  _possibleConstructorReturn,
  _getPrototypeOf,
  _defineProperty,
  _arrayWithHoles,
  _iterableToArray,
  _unsupportedIterableToArray,
  _nonIterableRest,
  _extends,
  _objectWithoutPropertiesLoose,
  encodeBase64,
  decodeBase64,
  ChannelState,
  EVENT_MAP,
  isValidEventType,
  logChatPromiseExecution,
  chatCodes,
  isOwnUser,
  Channel,
  ClientState,
  InsightMetrics,
  postInsights,
  buildWsFatalInsight,
  buildWsSuccessAfterFailureInsight,
  StableWSConnection,
  JWTUserToken,
  JWTServerToken,
  UserFromToken,
  DevToken,
  CheckSignature,
  TokenManager,
  ErrorFromResponse,
  StreamChat,
  Allow,
  Deny,
  AnyResource,
  AnyRole,
  MaxPriority,
  MinPriority,
  Permission,
  AllowAll,
  DenyAll,
  BuiltinRoles,
  BuiltinPermissions
};
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
//# sourceMappingURL=chunk-E2GHL5YO.js.map
